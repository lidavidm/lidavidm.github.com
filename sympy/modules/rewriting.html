<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Term rewriting &mdash; SymPy 0.7.3 documentation</title>
    
    <link rel="stylesheet" href="../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="http://95.sympy-live-tests.appspot.com/static/live-core.css" type="text/css" />
    <link rel="stylesheet" href="http://95.sympy-live-tests.appspot.com/static/live-autocomplete.css" type="text/css" />
    <link rel="stylesheet" href="http://95.sympy-live-tests.appspot.com/static/live-sphinx.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '0.7.3',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="http://95.sympy-live-tests.appspot.com/static/utilities.js"></script>
    <script type="text/javascript" src="http://95.sympy-live-tests.appspot.com/static/external/classy.js"></script>
    <script type="text/javascript" src="http://95.sympy-live-tests.appspot.com/static/live-core.js"></script>
    <script type="text/javascript" src="http://95.sympy-live-tests.appspot.com/static/live-autocomplete.js"></script>
    <script type="text/javascript" src="http://95.sympy-live-tests.appspot.com/static/live-sphinx.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML-full"></script>
    <link rel="shortcut icon" href="../_static/sympy-notailtext-favicon.ico"/>
    <link rel="top" title="SymPy 0.7.3 documentation" href="../index.html" />
    <link rel="up" title="SymPy Modules Reference" href="index.html" />
    <link rel="next" title="Series Module" href="series/index.html" />
    <link rel="prev" title="Sets" href="assumptions/handlers/sets.html" />
   
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head>
  <body role="document">  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="term-rewriting">
<h1>Term rewriting<a class="headerlink" href="#term-rewriting" title="Permalink to this headline">¶</a></h1>
<p>Term rewriting is a very general class of functionalities which are used to
convert expressions of one type in terms of expressions of different kind. For
example expanding, combining and converting expressions apply to term
rewriting, and also simplification routines can be included here. Currently
SymPy has several functions and basic built-in methods for performing various
types of rewriting.</p>
<div class="section" id="expanding">
<h2>Expanding<a class="headerlink" href="#expanding" title="Permalink to this headline">¶</a></h2>
<p>The simplest rewrite rule is expanding expressions into a _sparse_ form.
Expanding has several flavors and include expanding complex valued expressions,
arithmetic expand of products and powers but also expanding functions in terms
of more general functions is possible. Below are listed all currently available
expand rules.</p>
<dl class="docutils">
<dt>Expanding of arithmetic expressions involving products and powers:</dt>
<dd><div class="first last highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;x,y,z&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">((</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">y</span><span class="p">))</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="n">basic</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">x**2 - y**2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">((</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">+</span> <span class="n">z</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="n">basic</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">x**2 + 2*x*y + 2*x*z + y**2 + 2*y*z + z**2</span>
</pre></div>
</div>
</dd>
</dl>
<p>Arithmetic expand is done by default in <code class="docutils literal"><span class="pre">expand()</span></code> so the keyword <code class="docutils literal"><span class="pre">basic</span></code> can
be omitted. However you can set <code class="docutils literal"><span class="pre">basic=False</span></code> to avoid this type of expand if
you use rules described below. This give complete control on what is done with
the expression.</p>
<p>Another type of expand rule is expanding complex valued expressions and putting
them into a normal form. For this <code class="docutils literal"><span class="pre">complex</span></code> keyword is used. Note that it will
always perform arithmetic expand to obtain the desired normal form:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">I</span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="nb">complex</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">re(x) + I*re(y) + I*im(x) - im(y)</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sin</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">I</span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="nb">complex</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">sin(re(x) - im(y))*cosh(re(y) + im(x)) + I*cos(re(x) - im(y))*sinh(re(y) + im(x))</span>
</pre></div>
</div>
<p>Note also that the same behavior can be obtained by using <code class="docutils literal"><span class="pre">as_real_imag()</span></code>
method. However it will return a tuple containing the real part in the first
place and the imaginary part in the other. This can be also done in a two step
process by using <code class="docutils literal"><span class="pre">collect</span></code> function:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">I</span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">as_real_imag</span><span class="p">()</span>
<span class="go">(re(x) - im(y), re(y) + im(x))</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">collect</span><span class="p">((</span><span class="n">x</span> <span class="o">+</span> <span class="n">I</span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="nb">complex</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span> <span class="n">I</span><span class="p">,</span> <span class="n">evaluate</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">{1: re(x) - im(y), I: re(y) + im(x)}</span>
</pre></div>
</div>
<p>There is also possibility for expanding expressions in terms of expressions of
different kind. This is very general type of expanding and usually you would
use <code class="docutils literal"><span class="pre">rewrite()</span></code> to do specific type of rewrite:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">GoldenRatio</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="n">func</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">1/2 + sqrt(5)/2</span>
</pre></div>
</div>
</div>
<div class="section" id="module-sympy.simplify.cse_main">
<span id="common-subexpression-detection-and-collection"></span><h2>Common Subexpression Detection and Collection<a class="headerlink" href="#module-sympy.simplify.cse_main" title="Permalink to this headline">¶</a></h2>
<p>Before evaluating a large expression, it is often useful to identify common
subexpressions, collect them and evaluate them at once. This is implemented
in the <code class="docutils literal"><span class="pre">cse</span></code> function. Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">cse</span><span class="p">,</span> <span class="n">sqrt</span><span class="p">,</span> <span class="n">sin</span><span class="p">,</span> <span class="n">pprint</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="k">import</span> <span class="n">x</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">cse</span><span class="p">(</span><span class="n">sqrt</span><span class="p">(</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">))),</span> <span class="n">use_unicode</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">⎛    ⎡  ________⎤⎞</span>
<span class="go">⎝[], ⎣╲╱ sin(x) ⎦⎠</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">cse</span><span class="p">(</span><span class="n">sqrt</span><span class="p">(</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">+</span><span class="mi">5</span><span class="p">)</span><span class="o">*</span><span class="n">sqrt</span><span class="p">(</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">+</span><span class="mi">4</span><span class="p">)),</span> <span class="n">use_unicode</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">⎛                ⎡  ________   ________⎤⎞</span>
<span class="go">⎝[(x₀, sin(x))], ⎣╲╱ x₀ + 4 ⋅╲╱ x₀ + 5 ⎦⎠</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">cse</span><span class="p">(</span><span class="n">sqrt</span><span class="p">(</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">5</span> <span class="o">+</span> <span class="n">cos</span><span class="p">(</span><span class="n">y</span><span class="p">))</span><span class="o">*</span><span class="n">sqrt</span><span class="p">(</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">4</span> <span class="o">+</span> <span class="n">cos</span><span class="p">(</span><span class="n">y</span><span class="p">))),</span>
<span class="gp">... </span>    <span class="n">use_unicode</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">⎛                             ⎡  ________   ________⎤⎞</span>
<span class="go">⎝[(x₀, sin(x + 1) + cos(y))], ⎣╲╱ x₀ + 4 ⋅╲╱ x₀ + 5 ⎦⎠</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">cse</span><span class="p">((</span><span class="n">x</span><span class="o">-</span><span class="n">y</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">z</span><span class="o">-</span><span class="n">y</span><span class="p">)</span> <span class="o">+</span> <span class="n">sqrt</span><span class="p">((</span><span class="n">x</span><span class="o">-</span><span class="n">y</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">z</span><span class="o">-</span><span class="n">y</span><span class="p">))),</span> <span class="n">use_unicode</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">⎛                                     ⎡  ____     ⎤⎞</span>
<span class="go">⎝[(x₀, -y), (x₁, (x + x₀)⋅(x₀ + z))], ⎣╲╱ x₁  + x₁⎦⎠</span>
</pre></div>
</div>
<p>Optimizations to be performed before and after common subexpressions
elimination can be passed in the``optimizations`` optional argument. A set of
predefined basic optimizations can be applied by passing
<code class="docutils literal"><span class="pre">optimizations='basic'</span></code>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">cse</span><span class="p">((</span><span class="n">x</span><span class="o">-</span><span class="n">y</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">z</span><span class="o">-</span><span class="n">y</span><span class="p">)</span> <span class="o">+</span> <span class="n">sqrt</span><span class="p">((</span><span class="n">x</span><span class="o">-</span><span class="n">y</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">z</span><span class="o">-</span><span class="n">y</span><span class="p">)),</span> <span class="n">optimizations</span><span class="o">=</span><span class="s1">&#39;basic&#39;</span><span class="p">),</span>
<span class="gp">... </span>    <span class="n">use_unicode</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">⎛                          ⎡  ____     ⎤⎞</span>
<span class="go">⎝[(x₀, -(x - y)⋅(y - z))], ⎣╲╱ x₀  + x₀⎦⎠</span>
</pre></div>
</div>
<p>However, these optimizations can be very slow for large expressions. Moreover,
if speed is a concern, one can pass the option <code class="docutils literal"><span class="pre">order='none'</span></code>. Order of
terms will then be dependent on hashing algorithm implementation, but speed
will be greatly improved.</p>
<p>More information:</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../index.html">
              <img class="logo" src="../_static/sympylogo.png" alt="Logo"/>
            </a></p>
  <h3><a href="../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Term rewriting</a><ul>
<li><a class="reference internal" href="#expanding">Expanding</a></li>
<li><a class="reference internal" href="#module-sympy.simplify.cse_main">Common Subexpression Detection and Collection</a></li>
</ul>
</li>
</ul>
<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
  <li><a href="index.html">SymPy Modules Reference</a><ul>
      <li>Previous: <a href="assumptions/handlers/sets.html" title="previous chapter">Sets</a></li>
      <li>Next: <a href="series/index.html" title="next chapter">Series Module</a></li>
  </ul></li>
  </ul></li>
</ul>
</div>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/modules/rewriting.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2015 SymPy Development Team.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.4.1</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.7</a>
      
      |
      <a href="../_sources/modules/rewriting.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>