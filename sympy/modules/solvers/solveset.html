<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Solveset &mdash; SymPy 0.7.3 documentation</title>
    
    <link rel="stylesheet" href="../../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="http://95.sympy-live-tests.appspot.com/static/live-core.css" type="text/css" />
    <link rel="stylesheet" href="http://95.sympy-live-tests.appspot.com/static/live-autocomplete.css" type="text/css" />
    <link rel="stylesheet" href="http://95.sympy-live-tests.appspot.com/static/live-sphinx.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '0.7.3',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="http://95.sympy-live-tests.appspot.com/static/utilities.js"></script>
    <script type="text/javascript" src="http://95.sympy-live-tests.appspot.com/static/external/classy.js"></script>
    <script type="text/javascript" src="http://95.sympy-live-tests.appspot.com/static/live-core.js"></script>
    <script type="text/javascript" src="http://95.sympy-live-tests.appspot.com/static/live-autocomplete.js"></script>
    <script type="text/javascript" src="http://95.sympy-live-tests.appspot.com/static/live-sphinx.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML-full"></script>
    <link rel="shortcut icon" href="../../_static/sympy-notailtext-favicon.ico"/>
    <link rel="top" title="SymPy 0.7.3 documentation" href="../../index.html" />
    <link rel="up" title="SymPy Modules Reference" href="../index.html" />
    <link rel="next" title="Tensor Module" href="../tensor/index.html" />
    <link rel="prev" title="Inequality Solvers" href="inequalities.html" />
   
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head>
  <body role="document">  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="module-sympy.solvers.solveset">
<span id="solveset"></span><h1>Solveset<a class="headerlink" href="#module-sympy.solvers.solveset" title="Permalink to this headline">¶</a></h1>
<p>This is the official documentation of the <code class="docutils literal"><span class="pre">solveset</span></code> module in solvers.
It contains the frequently asked questions about our new module to solve
equations.</p>
<div class="section" id="what-s-wrong-with-solve">
<h2>What&#8217;s wrong with solve():<a class="headerlink" href="#what-s-wrong-with-solve" title="Permalink to this headline">¶</a></h2>
<p>SymPy already has a pretty powerful <code class="docutils literal"><span class="pre">solve</span></code> function. But it has a lot of major
issues</p>
<ol class="arabic simple">
<li>It doesn&#8217;t have a consistent output for various types of solutions
It needs to return a lot of types of solutions consistently:<ul>
<li>Single solution : <span class="math">\(x = 1\)</span></li>
<li>Multiple solutions: <span class="math">\(x^2 = 1\)</span></li>
<li>No Solution: <span class="math">\(x^2 + 1 = 0 ; x \in \mathbb{R}\)</span></li>
<li>Interval of solution: <span class="math">\(\lfloor x \rfloor = 0\)</span></li>
<li>Infinitely many solutions: <span class="math">\(sin(x) = 0\)</span></li>
<li>Multivariate functions with point solutions: <span class="math">\(x^2 + y^2 = 0\)</span></li>
<li>Multivariate functions with non-point solution: <span class="math">\(x^2 + y^2 = 1\)</span></li>
<li>System of equations: <span class="math">\(x + y = 1\)</span> and <span class="math">\(x - y = 0\)</span></li>
<li>Relational: <span class="math">\(x &gt; 0\)</span></li>
<li>And the most important case: &#8220;We don&#8217;t Know&#8221;</li>
</ul>
</li>
<li>The input API is also a mess, there are a lot of parameters. Many of them
are not needed and they make it hard for the user and the developers to
work on solvers.</li>
<li>There are cases like finding the maxima and minima of function using
critical points where it is important to know if it has returned all the
solutions. <code class="docutils literal"><span class="pre">solve</span></code> does not guarantee this.</li>
</ol>
</div>
<div class="section" id="why-solveset">
<h2>Why Solveset?<a class="headerlink" href="#why-solveset" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">solveset</span></code> has a cleaner input and output interface: <code class="docutils literal"><span class="pre">solveset</span></code> returns
a set object and a set object takes care of all types of output. For
cases where it doesn&#8217;t &#8220;know&#8221; all the solutions a <code class="docutils literal"><span class="pre">ConditionSet</span></code> with a partial
solution is returned. For input it only takes the equation, the variables
to solve for and the optional argument <code class="docutils literal"><span class="pre">domain</span></code> over which the equation is to
be solved.</li>
<li><code class="docutils literal"><span class="pre">solveset</span></code> can return infinitely many solutions. For example solving for
<span class="math">\(\sin{(x)} = 0\)</span> returns <span class="math">\(\{2 n \pi | n \in \mathbb{Z}\} \cup \{2 n \pi + \pi | n \in \mathbb{Z}\}\)</span>,
whereas <code class="docutils literal"><span class="pre">solve</span></code> only returns <span class="math">\([0, \pi]\)</span>.</li>
<li>There is a clear code level and interface level separation between solvers
for equations in the complex domain and the real domain. For example
solving <span class="math">\(e^x = 1\)</span> when <span class="math">\(x\)</span> is to be solved in the complex domain, returns
the set of all solutions, that is <span class="math">\(\{2 n i \pi | n \in \mathbb{Z}\}\)</span>, whereas
if <span class="math">\(x\)</span> is to be solved in the real domain then only <span class="math">\(\{0\}\)</span> is returned.</li>
</ul>
</div>
<div class="section" id="why-do-we-use-sets-as-an-output-type">
<h2>Why do we use Sets as an output type?<a class="headerlink" href="#why-do-we-use-sets-as-an-output-type" title="Permalink to this headline">¶</a></h2>
<p>SymPy has a well developed sets module, which can represent most of the set
containers in Mathematics such as:</p>
<blockquote>
<div><ul>
<li><p class="first"><code class="docutils literal"><span class="pre">FiniteSet</span></code></p>
<p>Represents a finite set of discrete numbers.</p>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">Interval</span></code></p>
<p>Represents a real interval as a set.</p>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">ProductSet</span></code></p>
<p>Represents a Cartesian product of sets.</p>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">ImageSet</span></code></p>
<p>Represents the image of a set under a mathematical function</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">ImageSet</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">Lambda</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="k">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">squares</span> <span class="o">=</span> <span class="n">ImageSet</span><span class="p">(</span><span class="n">Lambda</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">),</span> <span class="n">S</span><span class="o">.</span><span class="n">Naturals</span><span class="p">)</span>  <span class="c1"># {x**2 for x in N}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="mi">4</span> <span class="ow">in</span> <span class="n">squares</span>
<span class="go">True</span>
</pre></div>
</div>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">ComplexRegion</span></code></p>
<p>Represents the set of all complex numbers in a region in the Argand plane.</p>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">ConditionSet</span></code></p>
<p>Represents the set of elements, which satisfies a given condition.</p>
</li>
</ul>
</div></blockquote>
<p>Also, the predefined set classes such as:</p>
<blockquote>
<div><ul>
<li><p class="first"><code class="docutils literal"><span class="pre">Naturals</span></code> <span class="math">\(\mathbb{N}\)</span></p>
<p>Represents the natural numbers (or counting numbers), which are all
positive integers starting from 1.</p>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">Naturals0</span></code> <span class="math">\(\mathbb{N_0}\)</span></p>
<p>Represents the whole numbers, which are all the non-negative integers,
inclusive of 0.</p>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">Integers</span></code> <span class="math">\(\mathbb{Z}\)</span></p>
<p>Represents all integers: positive, negative and zero.</p>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">Reals</span></code> <span class="math">\(\mathbb{R}\)</span></p>
<p>Represents the set of all real numbers.</p>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">Complexes</span></code> <span class="math">\(\mathbb{C}\)</span></p>
<p>Represents the set of all complex numbers.</p>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">EmptySet</span></code> <span class="math">\(\phi\)</span></p>
<p>Represents the empty set.</p>
</li>
</ul>
<p>The above six sets are available as Singletons, like <code class="docutils literal"><span class="pre">S.Integers</span></code>.</p>
</div></blockquote>
<p>It is capable of most of the set operations in mathematics:</p>
<blockquote>
<div><ul class="simple">
<li><code class="docutils literal"><span class="pre">Union</span></code></li>
<li><code class="docutils literal"><span class="pre">Intersection</span></code></li>
<li><code class="docutils literal"><span class="pre">Complement</span></code></li>
<li><code class="docutils literal"><span class="pre">SymmetricDifference</span></code></li>
</ul>
</div></blockquote>
<p>The main reason for using sets as output to solvers is that it can consistently
represent many types of solutions. For the single variable case it can represent:</p>
<blockquote>
<div><ul class="simple">
<li>No solution (by the empty set).</li>
<li>Finitely many solutions (by <code class="docutils literal"><span class="pre">FiniteSet</span></code>).</li>
<li>Infinitely many solutions, both countably and uncountably infinite solutions
(using the <code class="docutils literal"><span class="pre">ImageSet</span></code> module).</li>
<li><code class="docutils literal"><span class="pre">Interval</span></code></li>
<li>There can also be bizarre solutions to equations like the set of rational
numbers.</li>
</ul>
</div></blockquote>
<p>No other Python object (list, dictionary, generator, Python sets) provides the
flexibility of mathematical sets which our sets module tries to emulate. The
second reason to use sets is that they are close to the entities which
mathematicians deal with and it makes it easier to reason about them.  Set
objects conform to Pythonic conventions when possible, i.e., <code class="docutils literal"><span class="pre">x</span> <span class="pre">in</span> <span class="pre">A</span></code> and
<code class="docutils literal"><span class="pre">for</span> <span class="pre">i</span> <span class="pre">in</span> <span class="pre">A</span></code> both work when they can be computed. Another advantage of using
objects closer to mathematical entities is that the user won&#8217;t have to &#8220;learn&#8221;
our representation and she can have her expectations transferred from her
mathematical experience.</p>
<p>For the multivariate case we represent solutions as a set of points in a
n-dimensional space and a point is represented by a <code class="docutils literal"><span class="pre">FiniteSet</span></code> of ordered
tuples, which is a point in <span class="math">\(\mathbb{R}^n\)</span> or <span class="math">\(\mathbb{C}^n\)</span>.</p>
<p>Please note that, the general <code class="docutils literal"><span class="pre">FiniteSet</span></code> is unordered, but a <code class="docutils literal"><span class="pre">FiniteSet</span></code>
with a tuple as its only argument becomes ordered, since a tuple is ordered.
So the order in the tuple is mapped to a pre-defined order of variables
while returning solutions.</p>
<p>For example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">FiniteSet</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">FiniteSet</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>   <span class="c1"># Unordered</span>
<span class="go">{1, 2, 3}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">FiniteSet</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>  <span class="c1"># Ordered</span>
<span class="go">{(1, 2, 3)}</span>
</pre></div>
</div>
<p>Why not use dicts as output?</p>
<blockquote>
<div><p>Dictionary are easy to deal with programatically but mathematically they are
not very precise and use of them can quickly lead to inconsistency and a lot
of confusion. For example:</p>
<ul>
<li><p class="first">There are a lot of cases where we don&#8217;t know the complete solution and we
may like to output a partial solution, consider the equation <span class="math">\(fg = 0\)</span>. The
solution of this equation is the union of the solution of the following
two equations: <span class="math">\(f = 0\)</span>, <span class="math">\(g = 0\)</span>. Let&#8217;s say that we are able to solve
<span class="math">\(f = 0\)</span> but solving <span class="math">\(g = 0\)</span> isn&#8217;t supported yet. In this case we cannot
represent partial solution of the given equation <span class="math">\(fg = 0\)</span> using dicts.
This problem is solved with sets using a <code class="docutils literal"><span class="pre">ConditionSet</span></code> object:</p>
<p><span class="math">\(sol_f \cup \{x | x ∊ \mathbb{R} ∧ g = 0\}\)</span>, where <span class="math">\(sol_f\)</span> is the solution
of the equation <span class="math">\(f = 0\)</span>.</p>
</li>
<li><p class="first">Using a dict may lead to surprising results like:</p>
<ul>
<li><p class="first"><code class="docutils literal"><span class="pre">solve(Eq(x**2,</span> <span class="pre">1),</span> <span class="pre">x)</span> <span class="pre">!=</span> <span class="pre">solve(Eq(y**2,</span> <span class="pre">1),</span> <span class="pre">y)</span></code></p>
<p>Mathematically, this doesn&#8217;t make sense. Using <code class="docutils literal"><span class="pre">FiniteSet</span></code> here
solves the problem.</p>
</li>
</ul>
</li>
<li><p class="first">It also cannot represent solutions for equations like <span class="math">\(|x| &lt; 1\)</span>, which is
a disk of radius 1 in the Argand Plane. This problem is solved using
complex sets implemented as <code class="docutils literal"><span class="pre">ComplexRegion</span></code>.</p>
</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="input-api-of-solveset">
<h2>Input API of <code class="docutils literal"><span class="pre">solveset</span></code><a class="headerlink" href="#input-api-of-solveset" title="Permalink to this headline">¶</a></h2>
<p><code class="docutils literal"><span class="pre">solveset</span></code> has a cleaner input API, unlike <code class="docutils literal"><span class="pre">solve</span></code>. It takes a maximum
of three arguments:</p>
<p><code class="docutils literal"><span class="pre">solveset(equation,</span> <span class="pre">variable=None,</span> <span class="pre">domain=S.Complexes)</span></code></p>
<ul>
<li><p class="first">Equation(s)</p>
<p>The equation(s) to solve.</p>
</li>
<li><p class="first">Variable(s)</p>
<p>The variable(s) for which the equation is to be solved.</p>
</li>
<li><p class="first">Domain</p>
<p>The domain in which the equation is to be solved.</p>
</li>
</ul>
<blockquote>
<div><code class="docutils literal"><span class="pre">solveset</span></code> removes the <code class="docutils literal"><span class="pre">flags</span></code> argument of <code class="docutils literal"><span class="pre">solve</span></code>, which had made
the input API messy and output API inconsistent.</div></blockquote>
</div>
<div class="section" id="what-is-this-domain-argument-about">
<h2>What is this domain argument about?<a class="headerlink" href="#what-is-this-domain-argument-about" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>Solveset is designed to be independent of the assumptions on the
variable being solved for and instead, uses the <code class="docutils literal"><span class="pre">domain</span></code> argument to
decide the solver to dispatch the equation to, namely <code class="docutils literal"><span class="pre">solveset_real</span></code>
or <code class="docutils literal"><span class="pre">solveset_complex</span></code>. It&#8217;s unlike the old <code class="docutils literal"><span class="pre">solve</span></code> which considers the
assumption on the variable.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">solveset</span><span class="p">,</span> <span class="n">S</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="k">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">solveset</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="c1"># domain=S.Complexes is default</span>
<span class="go">{-I, I}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">solveset</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">domain</span><span class="o">=</span><span class="n">S</span><span class="o">.</span><span class="n">Reals</span><span class="p">)</span>
<span class="go">EmptySet()</span>
</pre></div>
</div>
</div></blockquote>
</div>
<div class="section" id="what-are-the-general-methods-employed-by-solveset-to-solve-an-equation">
<h2>What are the general methods employed by solveset to solve an equation?<a class="headerlink" href="#what-are-the-general-methods-employed-by-solveset-to-solve-an-equation" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>Solveset uses various methods to solve an equation, here is a brief overview
of the methodology:</p>
<ul class="simple">
<li>The <code class="docutils literal"><span class="pre">domain</span></code> argument is first considered to know the domain in which
the user is interested to get the solution.</li>
<li>If the given function is a relational (<code class="docutils literal"><span class="pre">&gt;=</span></code>, <code class="docutils literal"><span class="pre">&lt;=</span></code>, <code class="docutils literal"><span class="pre">&gt;</span></code>, <code class="docutils literal"><span class="pre">&lt;</span></code>), and
the domain is real, then <code class="docutils literal"><span class="pre">solve_univariate_inequality</span></code> and solutions are
returned. Solving for complex solutions of inequalities, like <span class="math">\(x^2 &lt; 0\)</span>
is not yet supported.</li>
<li>Based on the <code class="docutils literal"><span class="pre">domain</span></code>, the equation is dispatched to one of the two
functions <code class="docutils literal"><span class="pre">solveset_real</span></code> or <code class="docutils literal"><span class="pre">solveset_complex</span></code>, which solves the
given equation in the complex or real domain, respectively.</li>
<li>If the given expression is a product of two or more functions,
like say <span class="math">\(gh = 0\)</span>, then the solution to the given equation is the Union
of the solution of the equations <span class="math">\(g = 0\)</span> and <span class="math">\(h = 0\)</span>, if and only if both
<span class="math">\(g\)</span> and <span class="math">\(h\)</span> are finite for a finite input. So, the solution is built up
recursively.</li>
<li>If the function is trigonometric or hyperbolic, the function
<code class="docutils literal"><span class="pre">_solve_real_trig</span></code> is called, which solves it by converting it to complex
exponential form.</li>
<li>The function is now checked if there is any instance of a <code class="docutils literal"><span class="pre">Piecewise</span></code>
expression, if it is, then it&#8217;s converted to explict expression and
set pairs and then solved recursively.</li>
<li>The respective solver now tries to invert the equation using the routines
<code class="docutils literal"><span class="pre">invert_real</span></code> and <code class="docutils literal"><span class="pre">invert_complex</span></code>. These routines are based on the
concept of mathematical inverse (though not exactly). It reduces the
real/complex valued equation <span class="math">\(f(x) = y\)</span> to a set of equations:
<span class="math">\(\{g(x)  = h_1(y), g(x) = h_2(y), ..., g(x) = h_n(y) \}\)</span> where <span class="math">\(g(x)\)</span> is a
simpler function than <span class="math">\(f(x)\)</span>. There is some work needed to be done in
this to find invert of more complex expressions.</li>
<li>After the invert, the equations are checked for radical or Abs (Modulus),
then the method <code class="docutils literal"><span class="pre">_solve_radical</span></code> tries to simplify the radical, by
removing it using techniques like squarring, cubing etc, and <code class="docutils literal"><span class="pre">_solve_abs</span></code>
solves nested Modulus by considering the positive and negative variants,
iteratively.</li>
<li>If none of the above method is successful, then methods of polynomial is
used as follows:<ul>
<li>The method to solve the rational function, <code class="docutils literal"><span class="pre">_solve_as_rational</span></code>, is
called.  Based on the domain, the respective poly solver
<code class="docutils literal"><span class="pre">_solve_as_poly_real</span></code> or <code class="docutils literal"><span class="pre">_solve_as_poly_complex</span></code> is called to solve
<code class="docutils literal"><span class="pre">f</span></code> as a polynomial.</li>
<li>The underlying method <code class="docutils literal"><span class="pre">_solve_as_poly</span></code> solves the equation using
polynomial techniques if it&#8217;s already a polynomial equation or, with
a change of variables, can be made so.</li>
</ul>
</li>
<li>The final solution set returned by <code class="docutils literal"><span class="pre">solveset</span></code> is the intersection of the
set of solutions found above and the input domain.</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="how-do-we-manipulate-and-return-an-infinite-solution">
<h2>How do we manipulate and return an infinite solution?<a class="headerlink" href="#how-do-we-manipulate-and-return-an-infinite-solution" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><ul>
<li><p class="first">In the real domain, we use our <code class="docutils literal"><span class="pre">ImageSet</span></code> class in the sets module to
return infinite solutions. <code class="docutils literal"><span class="pre">ImageSet</span></code> is an image of a set under
a mathematical function. For example, to represent the solution
of the equation <span class="math">\(\sin{(x)} = 0\)</span>, we can use the <code class="docutils literal"><span class="pre">ImageSet</span></code> as:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">ImageSet</span><span class="p">,</span> <span class="n">Lambda</span><span class="p">,</span> <span class="n">pi</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">Dummy</span><span class="p">,</span> <span class="n">pprint</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">Dummy</span><span class="p">(</span><span class="s1">&#39;n&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">ImageSet</span><span class="p">(</span><span class="n">Lambda</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="o">*</span><span class="n">n</span><span class="p">),</span> <span class="n">S</span><span class="o">.</span><span class="n">Integers</span><span class="p">),</span> <span class="n">use_unicode</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">{2⋅n⋅π | n ∊ ℤ}</span>
</pre></div>
</div>
<p>Where <code class="docutils literal"><span class="pre">n</span></code> is a dummy variable. It is basically the image of the
set of integers under the function <span class="math">\(2\pi n\)</span>.</p>
</li>
<li><p class="first">In the complex domain, we use complex sets, which are implemented as the
<code class="docutils literal"><span class="pre">ComplexRegion</span></code> class in the sets module, to represent infinite
solution in the Argand plane. For example to represent the solution
of the equation <span class="math">\(|z| = 1\)</span>, which is a unit circle, we can use
the <code class="docutils literal"><span class="pre">ComplexRegion</span></code> as:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">ComplexRegion</span><span class="p">,</span> <span class="n">FiniteSet</span><span class="p">,</span> <span class="n">Interval</span><span class="p">,</span> <span class="n">pi</span><span class="p">,</span> <span class="n">pprint</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">ComplexRegion</span><span class="p">(</span><span class="n">FiniteSet</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">Interval</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="p">),</span> <span class="n">polar</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span> <span class="n">use_unicode</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">{r⋅(ⅈ⋅sin(θ) + cos(θ)) | r, θ ∊ {1} × [0, 2⋅π)}</span>
</pre></div>
</div>
<p>Where the <code class="docutils literal"><span class="pre">FiniteSet</span></code> in the <code class="docutils literal"><span class="pre">ProductSet</span></code> is the range of the value
of <span class="math">\(r\)</span>, which is the radius of the circle and the <code class="docutils literal"><span class="pre">Interval</span></code> is the range
of <span class="math">\(\theta\)</span>, the angle from the <span class="math">\(x\)</span> axis representing a unit circle in the
Argand plane.</p>
<p>Note: We also have non-polar form notation for representing solution
in rectangular form. For example, to represent first two quadrants in the
Argand plane, we can write the <code class="docutils literal"><span class="pre">ComplexRegion</span></code> as:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">ComplexRegion</span><span class="p">,</span> <span class="n">Interval</span><span class="p">,</span> <span class="n">pi</span><span class="p">,</span> <span class="n">oo</span><span class="p">,</span> <span class="n">pprint</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">ComplexRegion</span><span class="p">(</span><span class="n">Interval</span><span class="p">(</span><span class="o">-</span><span class="n">oo</span><span class="p">,</span> <span class="n">oo</span><span class="p">)</span><span class="o">*</span><span class="n">Interval</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">oo</span><span class="p">)),</span> <span class="n">use_unicode</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">{x + y⋅ⅈ | x, y ∊ (-∞, ∞) × [0, ∞)}</span>
</pre></div>
</div>
<p>where the Intervals are the range of <span class="math">\(x\)</span> and <span class="math">\(y\)</span> for the set of complex
numbers <span class="math">\(x + iy\)</span>.</p>
</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="how-does-solveset-ensure-that-it-is-not-returning-any-wrong-solution">
<h2>How does <code class="docutils literal"><span class="pre">solveset</span></code> ensure that it is not returning any wrong solution?<a class="headerlink" href="#how-does-solveset-ensure-that-it-is-not-returning-any-wrong-solution" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>Solvers in a Computer Algebra System are based on heuristic algorithms,
so it&#8217;s usually very hard to ensure 100% percent correctness, in every
possible case. However there are still a lot of cases where we can ensure
correctness. Solveset tries to verify correctness wherever it can. For
example:</p>
<p>Consider the equation <span class="math">\(|x| = n\)</span>. A naive method to solve this equation
would return <code class="docutils literal"><span class="pre">{-n,</span> <span class="pre">n}</span></code> as its solution, which is not correct since
<code class="docutils literal"><span class="pre">{-n,</span> <span class="pre">n}</span></code> can be its solution if and only if <code class="docutils literal"><span class="pre">n</span></code> is positive.
Solveset returns this information as well to ensure correctness.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">symbols</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">pprint</span><span class="p">,</span> <span class="n">solveset</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;x, n&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">solveset</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="n">n</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">domain</span><span class="o">=</span><span class="n">S</span><span class="o">.</span><span class="n">Reals</span><span class="p">),</span> <span class="n">use_unicode</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">[0, ∞) ∩ {n}</span>
</pre></div>
</div>
<p>Though, there still a lot of work needs to be done in this regard.</p>
</div></blockquote>
</div>
<div class="section" id="search-based-solver-and-step-by-step-solution">
<h2>Search based solver and step-by-step solution<a class="headerlink" href="#search-based-solver-and-step-by-step-solution" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>Note: This is under Development.</p>
<p>After the introduction of <code class="xref py py-class docutils literal"><span class="pre">ConditionSet</span></code>, the
solving of equations can be seen as set transformations. Here is an abstract
view of the things we can do to solve equations.</p>
<ul class="simple">
<li>Apply various set transformations on the given set.</li>
<li>Define a metric of the usability of solutions, or a notion of some
solutions being better than others.</li>
<li>Different transformations would be the nodes of a tree.</li>
<li>Suitable searching techniques could be applied to get the best solution.</li>
</ul>
<p><code class="docutils literal"><span class="pre">ConditionSet</span></code> gives us the ability to represent unevaluated equations and
inequalities in forms like <span class="math">\(\{x|f(x)=0; x \in S\}\)</span> and <span class="math">\(\{x|f(x)&gt;0; x \in S\}\)</span>
but a more powerful thing about <code class="docutils literal"><span class="pre">ConditionSet</span></code> is that it allows us to write
the intermediate steps as set to set transformation. Some of the transformations
are:</p>
<ul>
<li><p class="first">Composition: <span class="math">\(\{x|f(g(x))=0;x \in S\} \Rightarrow \{x|g(x)=y; x \in S, y \in \{z|f(z)=0; z \in S\}\}\)</span></p>
</li>
<li><dl class="first docutils">
<dt>Polynomial Solver: <span class="math">\(\{x | P(x) = 0;x \in S\} \Rightarrow  \{x_1,x_2, ... ,x_n\} \cap S\)</span>,</dt>
<dd><p class="first last">where <span class="math">\(x_i\)</span> are roots of <span class="math">\(P(x)\)</span>.</p>
</dd>
</dl>
</li>
<li><p class="first">Invert solver: <span class="math">\(\{x|f(x)=0;x \in S\} \Rightarrow  \{g(0)| \text{ all g such that } f(g(x)) = x\}\)</span></p>
</li>
<li><dl class="first docutils">
<dt>logcombine: <span class="math">\(\{x| \log(f(x)) + \log(g(x));x \in S\}\)</span></dt>
<dd><p class="first last"><span class="math">\(\Rightarrow  \{x| \log(f(x).g(x)); x \in S\} \text{ if } f(x) &gt; 0 \text{ and } g(x) &gt; 0\)</span>
<span class="math">\(\Rightarrow  \{x| \log(f(x)) + \log(g(x));x \in S\} \text{ otherwise}\)</span></p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>product solve: <span class="math">\(\{x|f(x)g(x)=0; x \in S\}\)</span></dt>
<dd><p class="first last"><span class="math">\(\Rightarrow  \{x|f(x)=0; x \in S\} U \{x|g(x)=0; x \in S\}\)</span>
<span class="math">\(\text{ given } f(x) \text{ and } g(x) \text{ are bounded.}\)</span>
<span class="math">\(\Rightarrow  \{x|f(x)g(x)=0; x \in S\}, \text{ otherwise}\)</span></p>
</dd>
</dl>
</li>
</ul>
<p>Since the output type is same as the input type any composition of these
transformations is also a valid transformation. And our aim is to find
the right sequence of compositions (given the atoms) which transforms
the given condition set to a set which is not a condition set i.e.,
FiniteSet, Interval, Set of Integers and their Union, Intersection,
Complement or ImageSet. We can assign a cost function to each set,
such that, the more desirable that form of set is to us, the less the value
of the cost function. This way our problem is now reduced to finding the path
from the initial ConditionSet to the lowest valued set on a graph where
the atomic transformations forms the edges.</p>
</div></blockquote>
</div>
<div class="section" id="how-do-we-deal-with-cases-where-only-some-of-the-solutions-are-known">
<h2>How do we deal with cases where only some of the solutions are known?<a class="headerlink" href="#how-do-we-deal-with-cases-where-only-some-of-the-solutions-are-known" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>Creating a universal equation solver, which can solve each and every equation
we encounter in mathematics is an ideal case for solvers in a Computer
Algebra System. When cases which are not solved or can only be solved
incompletely, a <code class="docutils literal"><span class="pre">ConditionSet</span></code> is used and acts as an unevaluated solveset
object.</p>
<p>Note that, mathematically, finding a complete set of solutions for an
equation is undecidable. See <a class="reference external" href="https://en.wikipedia.org/wiki/Richardson%27s_theorem">Richardson&#8217;s theorem</a>.</p>
<p><code class="docutils literal"><span class="pre">ConditionSet</span></code> is basically a Set of elements which satisfy a given
condition. For example, to represent the solutions of the equation in
the real domain:</p>
<div class="math">
\[(x^2 - 4)(\sin(x) + x)\]</div>
<p>We can represent it as:</p>
<p><span class="math">\(\{-2, 2\} ∪ \{x | x \in \mathbb{R} ∧ x + \sin(x) = 0\}\)</span></p>
</div></blockquote>
</div>
<div class="section" id="what-will-you-do-with-the-old-solve">
<h2>What will you do with the old solve?<a class="headerlink" href="#what-will-you-do-with-the-old-solve" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>There are still a few things <code class="docutils literal"><span class="pre">solveset</span></code> can&#8217;t do, which the old <code class="docutils literal"><span class="pre">solve</span></code>
can, such as solving non linear multivariate &amp; LambertW type equations.
Hence, it&#8217;s not yet a perfect replacement for old <code class="docutils literal"><span class="pre">solve</span></code>. The ultimate
goal is to:</p>
<ul class="simple">
<li>Replace <code class="docutils literal"><span class="pre">solve</span></code> with <code class="docutils literal"><span class="pre">solveset</span></code> once solveset is at least as powerful as
<code class="docutils literal"><span class="pre">solve</span></code>, i.e., <code class="docutils literal"><span class="pre">solveset</span></code> does everything that <code class="docutils literal"><span class="pre">solve</span></code> can do
currently, and</li>
<li>eventually rename <code class="docutils literal"><span class="pre">solveset</span></code> to <code class="docutils literal"><span class="pre">solve</span></code>.</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="how-are-symbolic-parameters-handled-in-solveset">
<h2>How are symbolic parameters handled in solveset?<a class="headerlink" href="#how-are-symbolic-parameters-handled-in-solveset" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>Solveset is in its initial phase of development, so the symbolic parameters
aren&#8217;t handled well for all the cases, but some work has been done in this
regard to depict our ideology towards symbolic parameters. As an example,
consider the solving of <span class="math">\(|x| = n\)</span> for real <span class="math">\(x\)</span>, where <span class="math">\(n\)</span> is a symbolic
parameter. Solveset returns the value of <span class="math">\(x\)</span> considering the domain of the
symbolic parameter <span class="math">\(n\)</span> as well:</p>
<div class="math">
\[([0, \infty) \cap \{n\}) \cup ((-\infty, 0] \cap \{-n\}).\]</div>
<p>This simply means <span class="math">\(n\)</span> is the solution only when it belongs to the
<code class="docutils literal"><span class="pre">Interval</span></code> <span class="math">\([0, \infty)\)</span> and <span class="math">\(-n\)</span> is the solution only when <span class="math">\(-n\)</span> belongs to
the <code class="docutils literal"><span class="pre">Interval</span></code> <span class="math">\((- \infty, 0]\)</span>.</p>
<p>There are other cases to address too, like solving <span class="math">\(2^x + (a - 2)\)</span> for <span class="math">\(x\)</span>
where <span class="math">\(a\)</span> is a symbolic parameter.  As of now, It returns the solution as an
intersection with <span class="math">\(\mathbb{R}\)</span>, which is trivial, as it doesn&#8217;t reveal the
domain of <span class="math">\(a\)</span> in the solution.</p>
<p>Recently, we have also implemented a function to find the domain of the
expression in a FiniteSet (Intersection with the interval) in which it is
not-empty. It is a useful addition for dealing with symbolic parameters.
For example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">Symbol</span><span class="p">,</span> <span class="n">FiniteSet</span><span class="p">,</span> <span class="n">Interval</span><span class="p">,</span> <span class="n">not_empty_in</span><span class="p">,</span> <span class="n">sqrt</span><span class="p">,</span> <span class="n">oo</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="k">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">not_empty_in</span><span class="p">(</span><span class="n">FiniteSet</span><span class="p">(</span><span class="n">x</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">intersect</span><span class="p">(</span><span class="n">Interval</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)),</span> <span class="n">x</span><span class="p">)</span>
<span class="go">[0, 2]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">not_empty_in</span><span class="p">(</span><span class="n">FiniteSet</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">intersect</span><span class="p">(</span><span class="n">Interval</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)),</span> <span class="n">x</span><span class="p">)</span>
<span class="go">[-sqrt(2), -1] U [1, 2]</span>
</pre></div>
</div>
</div></blockquote>
</div>
<div class="section" id="references">
<h2>References<a class="headerlink" href="#references" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><table class="docutils footnote" frame="void" id="id1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td><a class="reference external" href="https://github.com/sympy/sympy/wiki/GSoC-2015-Ideas#solvers">https://github.com/sympy/sympy/wiki/GSoC-2015-Ideas#solvers</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[2]</td><td><a class="reference external" href="https://github.com/sympy/sympy/wiki/GSoC-2014-Application-Harsh-Gupta:-Solvers">https://github.com/sympy/sympy/wiki/GSoC-2014-Application-Harsh-Gupta:-Solvers</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id3" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[3]</td><td><a class="reference external" href="https://github.com/sympy/sympy/wiki/GSoC-2015-Application-AMiT-Kumar--Solvers-:-Extending-Solveset">https://github.com/sympy/sympy/wiki/GSoC-2015-Application-AMiT-Kumar&#8211;Solvers-:-Extending-Solveset</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id4" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[5]</td><td><a class="reference external" href="http://iamit.in/blog/">http://iamit.in/blog/</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id5" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[6]</td><td><a class="reference external" href="https://github.com/sympy/sympy/pull/2948">https://github.com/sympy/sympy/pull/2948</a> : Action Plan for improving solvers.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id6" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[7]</td><td><a class="reference external" href="https://github.com/sympy/sympy/issues/6659">https://github.com/sympy/sympy/issues/6659</a> : <code class="docutils literal"><span class="pre">solve()</span></code> is a giant mess</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id7" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[8]</td><td><a class="reference external" href="https://github.com/sympy/sympy/pull/7523">https://github.com/sympy/sympy/pull/7523</a> : <code class="docutils literal"><span class="pre">solveset</span></code> PR</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id8" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[9]</td><td><a class="reference external" href="https://groups.google.com/forum/#!topic/sympy/-SIbX0AFL3Q">https://groups.google.com/forum/#!topic/sympy/-SIbX0AFL3Q</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id9" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[10]</td><td><a class="reference external" href="https://github.com/sympy/sympy/pull/9696">https://github.com/sympy/sympy/pull/9696</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id10" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[11]</td><td><a class="reference external" href="https://en.wikipedia.org/wiki/Richardson%27s_theorem">https://en.wikipedia.org/wiki/Richardson%27s_theorem</a></td></tr>
</tbody>
</table>
</div></blockquote>
</div>
<div class="section" id="solveset-module-reference">
<h2>Solveset Module Reference<a class="headerlink" href="#solveset-module-reference" title="Permalink to this headline">¶</a></h2>
<p>Use <code class="xref py py-func docutils literal"><span class="pre">solveset()</span></code> to solve equations or expressions (assumed to be equal to 0) for a single variable.
Solving an equation like <span class="math">\(x^2 == 1\)</span> can be done as follows:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">solveset</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">Symbol</span><span class="p">,</span> <span class="n">Eq</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">solveset</span><span class="p">(</span><span class="n">Eq</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">x</span><span class="p">)</span>
<span class="go">{-1, 1}</span>
</pre></div>
</div>
<p>Or one may manually rewrite the equation as an expression equal to 0:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">solveset</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="go">{-1, 1}</span>
</pre></div>
</div>
<p>The first argument for <code class="xref py py-func docutils literal"><span class="pre">solveset()</span></code> is an expression (equal to zero) or an equation and the second argument
is the symbol that we want to solve the equation for.</p>
</div>
<div class="section" id="linear-eq-to-matrix">
<h2>linear_eq_to_matrix<a class="headerlink" href="#linear-eq-to-matrix" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="linsolve">
<h2>linsolve<a class="headerlink" href="#linsolve" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="diophantine-equations-des">
<h2>Diophantine Equations (DEs)<a class="headerlink" href="#diophantine-equations-des" title="Permalink to this headline">¶</a></h2>
<p>See <a class="reference internal" href="diophantine.html#diophantine-docs"><span class="std std-ref">Diophantine</span></a></p>
</div>
<div class="section" id="inequalities">
<h2>Inequalities<a class="headerlink" href="#inequalities" title="Permalink to this headline">¶</a></h2>
<p>See <a class="reference internal" href="inequalities.html#inequality-docs"><span class="std std-ref">Inequality Solvers</span></a></p>
</div>
<div class="section" id="ordinary-differential-equations-odes">
<h2>Ordinary Differential equations (ODEs)<a class="headerlink" href="#ordinary-differential-equations-odes" title="Permalink to this headline">¶</a></h2>
<p>See <a class="reference internal" href="ode.html#ode-docs"><span class="std std-ref">ODE</span></a>.</p>
</div>
<div class="section" id="partial-differential-equations-pdes">
<h2>Partial Differential Equations (PDEs)<a class="headerlink" href="#partial-differential-equations-pdes" title="Permalink to this headline">¶</a></h2>
<p>See <a class="reference internal" href="pde.html#pde-docs"><span class="std std-ref">PDE</span></a>.</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../index.html">
              <img class="logo" src="../../_static/sympylogo.png" alt="Logo"/>
            </a></p>
  <h3><a href="../../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Solveset</a><ul>
<li><a class="reference internal" href="#what-s-wrong-with-solve">What&#8217;s wrong with solve():</a></li>
<li><a class="reference internal" href="#why-solveset">Why Solveset?</a></li>
<li><a class="reference internal" href="#why-do-we-use-sets-as-an-output-type">Why do we use Sets as an output type?</a></li>
<li><a class="reference internal" href="#input-api-of-solveset">Input API of <code class="docutils literal"><span class="pre">solveset</span></code></a></li>
<li><a class="reference internal" href="#what-is-this-domain-argument-about">What is this domain argument about?</a></li>
<li><a class="reference internal" href="#what-are-the-general-methods-employed-by-solveset-to-solve-an-equation">What are the general methods employed by solveset to solve an equation?</a></li>
<li><a class="reference internal" href="#how-do-we-manipulate-and-return-an-infinite-solution">How do we manipulate and return an infinite solution?</a></li>
<li><a class="reference internal" href="#how-does-solveset-ensure-that-it-is-not-returning-any-wrong-solution">How does <code class="docutils literal"><span class="pre">solveset</span></code> ensure that it is not returning any wrong solution?</a></li>
<li><a class="reference internal" href="#search-based-solver-and-step-by-step-solution">Search based solver and step-by-step solution</a></li>
<li><a class="reference internal" href="#how-do-we-deal-with-cases-where-only-some-of-the-solutions-are-known">How do we deal with cases where only some of the solutions are known?</a></li>
<li><a class="reference internal" href="#what-will-you-do-with-the-old-solve">What will you do with the old solve?</a></li>
<li><a class="reference internal" href="#how-are-symbolic-parameters-handled-in-solveset">How are symbolic parameters handled in solveset?</a></li>
<li><a class="reference internal" href="#references">References</a></li>
<li><a class="reference internal" href="#solveset-module-reference">Solveset Module Reference</a></li>
<li><a class="reference internal" href="#linear-eq-to-matrix">linear_eq_to_matrix</a></li>
<li><a class="reference internal" href="#linsolve">linsolve</a></li>
<li><a class="reference internal" href="#diophantine-equations-des">Diophantine Equations (DEs)</a></li>
<li><a class="reference internal" href="#inequalities">Inequalities</a></li>
<li><a class="reference internal" href="#ordinary-differential-equations-odes">Ordinary Differential equations (ODEs)</a></li>
<li><a class="reference internal" href="#partial-differential-equations-pdes">Partial Differential Equations (PDEs)</a></li>
</ul>
</li>
</ul>
<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../index.html">Documentation overview</a><ul>
  <li><a href="../index.html">SymPy Modules Reference</a><ul>
      <li>Previous: <a href="inequalities.html" title="previous chapter">Inequality Solvers</a></li>
      <li>Next: <a href="../tensor/index.html" title="next chapter">Tensor Module</a></li>
  </ul></li>
  </ul></li>
</ul>
</div>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../../_sources/modules/solvers/solveset.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2015 SymPy Development Team.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.4.1</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.7</a>
      
      |
      <a href="../../_sources/modules/solvers/solveset.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>