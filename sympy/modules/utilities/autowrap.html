<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Autowrap Module &mdash; SymPy 1.0 documentation</title>
    
    <link rel="stylesheet" href="../../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="http://95.sympy-live-tests.appspot.com/static/live-core.css" type="text/css" />
    <link rel="stylesheet" href="http://95.sympy-live-tests.appspot.com/static/live-autocomplete.css" type="text/css" />
    <link rel="stylesheet" href="http://95.sympy-live-tests.appspot.com/static/live-sphinx.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="http://95.sympy-live-tests.appspot.com/static/utilities.js"></script>
    <script type="text/javascript" src="http://95.sympy-live-tests.appspot.com/static/external/classy.js"></script>
    <script type="text/javascript" src="http://95.sympy-live-tests.appspot.com/static/live-core.js"></script>
    <script type="text/javascript" src="http://95.sympy-live-tests.appspot.com/static/live-autocomplete.js"></script>
    <script type="text/javascript" src="http://95.sympy-live-tests.appspot.com/static/live-sphinx.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML-full"></script>
    <link rel="shortcut icon" href="../../_static/sympy-notailtext-favicon.ico"/>
    <link rel="top" title="SymPy 1.0 documentation" href="../../index.html" />
    <link rel="up" title="Utilities" href="index.html" />
    <link rel="next" title="Codegen" href="codegen.html" />
    <link rel="prev" title="Utilities" href="index.html" />
   
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head>
  <body role="document">  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="autowrap-module">
<h1>Autowrap Module<a class="headerlink" href="#autowrap-module" title="Permalink to this headline">¶</a></h1>
<p>The autowrap module works very well in tandem with the Indexed classes of the
<a class="reference internal" href="../tensor/index.html#tensor-module"><span class="std std-ref">Tensor Module</span></a>.  Here is a simple example that shows how to setup a binary
routine that calculates a matrix-vector product.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.utilities.autowrap</span> <span class="k">import</span> <span class="n">autowrap</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">symbols</span><span class="p">,</span> <span class="n">IndexedBase</span><span class="p">,</span> <span class="n">Idx</span><span class="p">,</span> <span class="n">Eq</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">IndexedBase</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;m n&#39;</span><span class="p">,</span> <span class="n">integer</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i</span> <span class="o">=</span> <span class="n">Idx</span><span class="p">(</span><span class="s1">&#39;i&#39;</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">j</span> <span class="o">=</span> <span class="n">Idx</span><span class="p">(</span><span class="s1">&#39;j&#39;</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">instruction</span> <span class="o">=</span> <span class="n">Eq</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span> <span class="n">instruction</span>
<span class="go">Eq(y[i], x[j]*A[i, j])</span>
</pre></div>
</div>
<p>Because the code printers treat Indexed objects with repeated indices as a
summation, the above equality instance will be translated to low-level code for
a matrix vector product.  This is how you tell SymPy to generate the code,
compile it and wrap it as a python function:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">matvec</span> <span class="o">=</span> <span class="n">autowrap</span><span class="p">(</span><span class="n">instruction</span><span class="p">)</span>                 
</pre></div>
</div>
<p>That&#8217;s it.  Now let&#8217;s test it with some numpy arrays.  The default wrapper
backend is f2py.  The wrapper function it provides is set up to accept python
lists, which it will silently convert to numpy arrays.  So we can test the
matrix vector product like this:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
<span class="gp">... </span>     <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">matvec</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>                              
<span class="go">[ 3.  2.]</span>
</pre></div>
</div>
<div class="section" id="implementation-details">
<h2>Implementation details<a class="headerlink" href="#implementation-details" title="Permalink to this headline">¶</a></h2>
<p>The autowrap module is implemented with a backend consisting of CodeWrapper
objects.  The base class <code class="docutils literal"><span class="pre">CodeWrapper</span></code> takes care of details about module
name, filenames and options.  It also contains the driver routine, which runs
through all steps in the correct order, and also takes care of setting up and
removing the temporary working directory.</p>
<p>The actual compilation and wrapping is done by external resources, such as the
system installed f2py command. The Cython backend runs a distutils setup script
in a subprocess. Subclasses of CodeWrapper takes care of these
backend-dependent details.</p>
</div>
<div class="section" id="module-sympy.utilities.autowrap">
<span id="api-reference"></span><h2>API Reference<a class="headerlink" href="#module-sympy.utilities.autowrap" title="Permalink to this headline">¶</a></h2>
<p>Module for compiling codegen output, and wrap the binary for use in
python.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>To use the autowrap module it must first be imported</p>
<div class="last highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.utilities.autowrap</span> <span class="k">import</span> <span class="n">autowrap</span>
</pre></div>
</div>
</div>
<p>This module provides a common interface for different external backends, such
as f2py, fwrap, Cython, SWIG(?) etc. (Currently only f2py and Cython are
implemented) The goal is to provide access to compiled binaries of acceptable
performance with a one-button user interface, i.e.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="k">import</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">expr</span> <span class="o">=</span> <span class="p">((</span><span class="n">x</span> <span class="o">-</span> <span class="n">y</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="mi">25</span><span class="p">))</span><span class="o">.</span><span class="n">expand</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">binary_callable</span> <span class="o">=</span> <span class="n">autowrap</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">binary_callable</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">-1.0</span>
</pre></div>
</div>
<p>The callable returned from autowrap() is a binary python function, not a
SymPy object.  If it is desired to use the compiled function in symbolic
expressions, it is better to use binary_function() which returns a SymPy
Function object.  The binary callable is attached as the _imp_ attribute and
invoked when a numerical evaluation is requested with evalf(), or with
lambdify().</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.utilities.autowrap</span> <span class="k">import</span> <span class="n">binary_function</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">binary_function</span><span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">,</span> <span class="n">expr</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="mi">2</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="o">+</span> <span class="n">y</span>
<span class="go">y + 2*f(x, y)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">evalf</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">subs</span><span class="o">=</span><span class="p">{</span><span class="n">x</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span><span class="mi">2</span><span class="p">})</span>
<span class="go">0.e-110</span>
</pre></div>
</div>
<p>The idea is that a SymPy user will primarily be interested in working with
mathematical expressions, and should not have to learn details about wrapping
tools in order to evaluate expressions numerically, even if they are
computationally expensive.</p>
<p>When is this useful?</p>
<blockquote>
<div><ol class="arabic simple">
<li>For computations on large arrays, Python iterations may be too slow,
and depending on the mathematical expression, it may be difficult to
exploit the advanced index operations provided by NumPy.</li>
<li>For <em>really</em> long expressions that will be called repeatedly, the
compiled binary should be significantly faster than SymPy&#8217;s .evalf()</li>
<li>If you are generating code with the codegen utility in order to use
it in another project, the automatic python wrappers let you test the
binaries immediately from within SymPy.</li>
<li>To create customized ufuncs for use with numpy arrays.
See <em>ufuncify</em>.</li>
</ol>
</div></blockquote>
<p>When is this module NOT the best approach?</p>
<blockquote>
<div><ol class="arabic simple">
<li>If you are really concerned about speed or memory optimizations,
you will probably get better results by working directly with the
wrapper tools and the low level code.  However, the files generated
by this utility may provide a useful starting point and reference
code. Temporary files will be left intact if you supply the keyword
tempdir=&#8221;path/to/files/&#8221;.</li>
<li>If the array computation can be handled easily by numpy, and you
don&#8217;t need the binaries for another project.</li>
</ol>
</div></blockquote>
<dl class="class">
<dt id="sympy.utilities.autowrap.CodeWrapper">
<em class="property">class </em><code class="descclassname">sympy.utilities.autowrap.</code><code class="descname">CodeWrapper</code><span class="sig-paren">(</span><em>generator</em>, <em>filepath=None</em>, <em>flags=[]</em>, <em>verbose=False</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/sympy/utilities/autowrap.html#CodeWrapper"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.utilities.autowrap.CodeWrapper" title="Permalink to this definition">¶</a></dt>
<dd><p>Base Class for code wrappers</p>
</dd></dl>

<dl class="class">
<dt id="sympy.utilities.autowrap.CythonCodeWrapper">
<em class="property">class </em><code class="descclassname">sympy.utilities.autowrap.</code><code class="descname">CythonCodeWrapper</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/sympy/utilities/autowrap.html#CythonCodeWrapper"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.utilities.autowrap.CythonCodeWrapper" title="Permalink to this definition">¶</a></dt>
<dd><p>Wrapper that uses Cython</p>
<dl class="method">
<dt id="sympy.utilities.autowrap.CythonCodeWrapper.dump_pyx">
<code class="descname">dump_pyx</code><span class="sig-paren">(</span><em>routines</em>, <em>f</em>, <em>prefix</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/sympy/utilities/autowrap.html#CythonCodeWrapper.dump_pyx"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.utilities.autowrap.CythonCodeWrapper.dump_pyx" title="Permalink to this definition">¶</a></dt>
<dd><p>Write a Cython file with python wrappers</p>
<p>This file contains all the definitions of the routines in c code and
refers to the header file.</p>
<p class="rubric">Arguments</p>
<dl class="docutils">
<dt>routines</dt>
<dd>List of Routine instances</dd>
<dt>f</dt>
<dd>File-like object to write the file to</dd>
<dt>prefix</dt>
<dd>The filename prefix, used to refer to the proper header file.
Only the basename of the prefix is used.</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="sympy.utilities.autowrap.DummyWrapper">
<em class="property">class </em><code class="descclassname">sympy.utilities.autowrap.</code><code class="descname">DummyWrapper</code><span class="sig-paren">(</span><em>generator</em>, <em>filepath=None</em>, <em>flags=[]</em>, <em>verbose=False</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/sympy/utilities/autowrap.html#DummyWrapper"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.utilities.autowrap.DummyWrapper" title="Permalink to this definition">¶</a></dt>
<dd><p>Class used for testing independent of backends</p>
</dd></dl>

<dl class="class">
<dt id="sympy.utilities.autowrap.F2PyCodeWrapper">
<em class="property">class </em><code class="descclassname">sympy.utilities.autowrap.</code><code class="descname">F2PyCodeWrapper</code><span class="sig-paren">(</span><em>generator</em>, <em>filepath=None</em>, <em>flags=[]</em>, <em>verbose=False</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/sympy/utilities/autowrap.html#F2PyCodeWrapper"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.utilities.autowrap.F2PyCodeWrapper" title="Permalink to this definition">¶</a></dt>
<dd><p>Wrapper that uses f2py</p>
</dd></dl>

<dl class="class">
<dt id="sympy.utilities.autowrap.UfuncifyCodeWrapper">
<em class="property">class </em><code class="descclassname">sympy.utilities.autowrap.</code><code class="descname">UfuncifyCodeWrapper</code><span class="sig-paren">(</span><em>generator</em>, <em>filepath=None</em>, <em>flags=[]</em>, <em>verbose=False</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/sympy/utilities/autowrap.html#UfuncifyCodeWrapper"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.utilities.autowrap.UfuncifyCodeWrapper" title="Permalink to this definition">¶</a></dt>
<dd><p>Wrapper for Ufuncify</p>
<dl class="method">
<dt id="sympy.utilities.autowrap.UfuncifyCodeWrapper.dump_c">
<code class="descname">dump_c</code><span class="sig-paren">(</span><em>routines</em>, <em>f</em>, <em>prefix</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/sympy/utilities/autowrap.html#UfuncifyCodeWrapper.dump_c"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.utilities.autowrap.UfuncifyCodeWrapper.dump_c" title="Permalink to this definition">¶</a></dt>
<dd><p>Write a C file with python wrappers</p>
<p>This file contains all the definitions of the routines in c code.</p>
<p class="rubric">Arguments</p>
<dl class="docutils">
<dt>routines</dt>
<dd>List of Routine instances</dd>
<dt>f</dt>
<dd>File-like object to write the file to</dd>
<dt>prefix</dt>
<dd>The filename prefix, used to name the imported module.</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="sympy.utilities.autowrap.autowrap">
<code class="descclassname">sympy.utilities.autowrap.</code><code class="descname">autowrap</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/sympy/utilities/autowrap.html#autowrap"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.utilities.autowrap.autowrap" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates python callable binaries based on the math expression.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>expr</strong></p>
<blockquote>
<div><p>The SymPy expression that should be wrapped as a binary routine.</p>
</div></blockquote>
<p><strong>language</strong> : string, optional</p>
<blockquote>
<div><p>If supplied, (options: &#8216;C&#8217; or &#8216;F95&#8217;), specifies the language of the
generated code. If <code class="docutils literal"><span class="pre">None</span></code> [default], the language is inferred based
upon the specified backend.</p>
</div></blockquote>
<p><strong>backend</strong> : string, optional</p>
<blockquote>
<div><p>Backend used to wrap the generated code. Either &#8216;f2py&#8217; [default],
or &#8216;cython&#8217;.</p>
</div></blockquote>
<p><strong>tempdir</strong> : string, optional</p>
<blockquote>
<div><p>Path to directory for temporary files. If this argument is supplied,
the generated code and the wrapper input files are left intact in the
specified path.</p>
</div></blockquote>
<p><strong>args</strong> : iterable, optional</p>
<blockquote>
<div><p>An ordered iterable of symbols. Specifies the argument sequence for the
function.</p>
</div></blockquote>
<p><strong>flags</strong> : iterable, optional</p>
<blockquote>
<div><p>Additional option flags that will be passed to the backend.</p>
</div></blockquote>
<p><strong>verbose</strong> : bool, optional</p>
<blockquote>
<div><p>If True, autowrap will not mute the command line backends. This can be
helpful for debugging.</p>
</div></blockquote>
<p><strong>helpers</strong> : iterable, optional</p>
<blockquote>
<div><p>Used to define auxillary expressions needed for the main expr. If the
main expression needs to call a specialized function it should be put
in the <code class="docutils literal"><span class="pre">helpers</span></code> iterable. Autowrap will then make sure that the
compiled main expression can link to the helper routine. Items should
be tuples with (&lt;funtion_name&gt;, &lt;sympy_expression&gt;, &lt;arguments&gt;). It
is mandatory to supply an argument sequence to helper routines.</p>
</div></blockquote>
<p><strong>&gt;&gt;&gt; from sympy.abc import x, y, z</strong></p>
<p><strong>&gt;&gt;&gt; from sympy.utilities.autowrap import autowrap</strong></p>
<p><strong>&gt;&gt;&gt; expr = ((x - y + z)**(13)).expand()</strong></p>
<p><strong>&gt;&gt;&gt; binary_func = autowrap(expr)</strong></p>
<p><strong>&gt;&gt;&gt; binary_func(1, 4, 2)</strong></p>
<p class="last"><strong>-1.0</strong></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="sympy.utilities.autowrap.binary_function">
<code class="descclassname">sympy.utilities.autowrap.</code><code class="descname">binary_function</code><span class="sig-paren">(</span><em>symfunc</em>, <em>expr</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/sympy/utilities/autowrap.html#binary_function"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.utilities.autowrap.binary_function" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a sympy function with expr as binary implementation</p>
<p>This is a convenience function that automates the steps needed to
autowrap the SymPy expression and attaching it to a Function object
with implemented_function().</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="k">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.utilities.autowrap</span> <span class="k">import</span> <span class="n">binary_function</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">expr</span> <span class="o">=</span> <span class="p">((</span><span class="n">x</span> <span class="o">-</span> <span class="n">y</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="mi">25</span><span class="p">))</span><span class="o">.</span><span class="n">expand</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">binary_function</span><span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">,</span> <span class="n">expr</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="go">&lt;class &#39;sympy.core.function.UndefinedFunction&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="mi">2</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="go">2*f(x, y)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">evalf</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">subs</span><span class="o">=</span><span class="p">{</span><span class="n">x</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="mi">2</span><span class="p">})</span>
<span class="go">-1.0</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="sympy.utilities.autowrap.ufuncify">
<code class="descclassname">sympy.utilities.autowrap.</code><code class="descname">ufuncify</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/sympy/utilities/autowrap.html#ufuncify"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.utilities.autowrap.ufuncify" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates a binary function that supports broadcasting on numpy arrays.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>args</strong> : iterable</p>
<blockquote>
<div><p>Either a Symbol or an iterable of symbols. Specifies the argument
sequence for the function.</p>
</div></blockquote>
<p><strong>expr</strong></p>
<blockquote>
<div><p>A SymPy expression that defines the element wise operation.</p>
</div></blockquote>
<p><strong>language</strong> : string, optional</p>
<blockquote>
<div><p>If supplied, (options: &#8216;C&#8217; or &#8216;F95&#8217;), specifies the language of the
generated code. If <code class="docutils literal"><span class="pre">None</span></code> [default], the language is inferred based
upon the specified backend.</p>
</div></blockquote>
<p><strong>backend</strong> : string, optional</p>
<blockquote>
<div><p>Backend used to wrap the generated code. Either &#8216;numpy&#8217; [default],
&#8216;cython&#8217;, or &#8216;f2py&#8217;.</p>
</div></blockquote>
<p><strong>tempdir</strong> : string, optional</p>
<blockquote>
<div><p>Path to directory for temporary files. If this argument is supplied,
the generated code and the wrapper input files are left intact in the
specified path.</p>
</div></blockquote>
<p><strong>flags</strong> : iterable, optional</p>
<blockquote>
<div><p>Additional option flags that will be passed to the backend</p>
</div></blockquote>
<p><strong>verbose</strong> : bool, optional</p>
<blockquote>
<div><p>If True, autowrap will not mute the command line backends. This can be
helpful for debugging.</p>
</div></blockquote>
<p><strong>helpers</strong> : iterable, optional</p>
<blockquote class="last">
<div><p>Used to define auxillary expressions needed for the main expr. If the
main expression needs to call a specialized function it should be put
in the <code class="docutils literal"><span class="pre">helpers</span></code> iterable. Autowrap will then make sure that the
compiled main expression can link to the helper routine. Items should
be tuples with (&lt;funtion_name&gt;, &lt;sympy_expression&gt;, &lt;arguments&gt;). It
is mandatory to supply an argument sequence to helper routines.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>[1] <a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/ufuncs.html">http://docs.scipy.org/doc/numpy/reference/ufuncs.html</a></p>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.utilities.autowrap</span> <span class="k">import</span> <span class="n">ufuncify</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="k">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">ufuncify</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">),</span> <span class="n">y</span> <span class="o">+</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="go">numpy.ufunc</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">array([ 3.,  6.,  11.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">5</span><span class="p">),</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">array([ 3.,  4.,  7.,  12.,  19.])</span>
</pre></div>
</div>
<p>For the F2Py and Cython backends, inputs are required to be equal length
1-dimensional arrays. The F2Py backend will perform type conversion, but
the Cython backend will error if the inputs are not of the expected type.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>&gt;&gt;&gt; f_fortran = ufuncify((x, y), y + x**2, backend=&#39;F2Py&#39;)
&gt;&gt;&gt; f_fortran(1, 2)
3
&gt;&gt;&gt; f_fortran(numpy.array([1, 2, 3]), numpy.array([1.0, 2.0, 3.0]))
array([2.,  6.,  12.])
&gt;&gt;&gt; f_cython = ufuncify((x, y), y + x**2, backend=&#39;Cython&#39;)
&gt;&gt;&gt; f_cython(1, 2)
Traceback (most recent call last):
File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
TypeError: Argument &#39;_x&#39; has incorrect type (expected numpy.ndarray, got int)
&gt;&gt;&gt; f_cython(numpy.array([1.0]), numpy.array([2.0]))
array([ 3.])
</pre></div>
</div>
<p class="rubric">Note</p>
<p>The default backend (&#8216;numpy&#8217;) will create actual instances of
<code class="docutils literal"><span class="pre">numpy.ufunc</span></code>. These support ndimensional broadcasting, and implicit type
conversion. Use of the other backends will result in a &#8220;ufunc-like&#8221;
function, which requires equal length 1-dimensional arrays for all
arguments, and will not perform any type conversions.</p>
</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../index.html">
              <img class="logo" src="../../_static/sympylogo.png" alt="Logo"/>
            </a></p>
  <h3><a href="../../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Autowrap Module</a><ul>
<li><a class="reference internal" href="#implementation-details">Implementation details</a></li>
<li><a class="reference internal" href="#module-sympy.utilities.autowrap">API Reference</a></li>
</ul>
</li>
</ul>
<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../index.html">Documentation overview</a><ul>
  <li><a href="../index.html">SymPy Modules Reference</a><ul>
  <li><a href="index.html">Utilities</a><ul>
      <li>Previous: <a href="index.html" title="previous chapter">Utilities</a></li>
      <li>Next: <a href="codegen.html" title="next chapter">Codegen</a></li>
  </ul></li>
  </ul></li>
  </ul></li>
</ul>
</div>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../../_sources/modules/utilities/autowrap.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2015 SymPy Development Team.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.4.1</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.7</a>
      
      |
      <a href="../../_sources/modules/utilities/autowrap.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>