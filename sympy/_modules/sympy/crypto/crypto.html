<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>sympy.crypto.crypto &mdash; SymPy 1.0.1.dev documentation</title>
    
    <link rel="stylesheet" href="../../../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="http://96.sympy-live-tests.appspot.com/static/live-core.css" type="text/css" />
    <link rel="stylesheet" href="http://96.sympy-live-tests.appspot.com/static/live-autocomplete.css" type="text/css" />
    <link rel="stylesheet" href="http://96.sympy-live-tests.appspot.com/static/live-sphinx.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '1.0.1.dev',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="http://96.sympy-live-tests.appspot.com/static/utilities.js"></script>
    <script type="text/javascript" src="http://96.sympy-live-tests.appspot.com/static/external/classy.js"></script>
    <script type="text/javascript" src="http://96.sympy-live-tests.appspot.com/static/live-core.js"></script>
    <script type="text/javascript" src="http://96.sympy-live-tests.appspot.com/static/live-autocomplete.js"></script>
    <script type="text/javascript" src="http://96.sympy-live-tests.appspot.com/static/live-sphinx.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML-full"></script>
    <link rel="shortcut icon" href="../../../_static/sympy-notailtext-favicon.ico"/>
    <link rel="top" title="SymPy 1.0.1.dev documentation" href="../../../index.html" />
    <link rel="up" title="Module code" href="../../index.html" />
   
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head>
  <body role="document">  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for sympy.crypto.crypto</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">This file contains some classical ciphers and routines</span>
<span class="sd">implementing a linear-feedback shift register (LFSR)</span>
<span class="sd">and the Diffie-Hellman key exchange.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">print_function</span>

<span class="kn">from</span> <span class="nn">string</span> <span class="kn">import</span> <span class="n">whitespace</span><span class="p">,</span> <span class="n">ascii_uppercase</span> <span class="k">as</span> <span class="n">uppercase</span><span class="p">,</span> <span class="n">printable</span>

<span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">nextprime</span>
<span class="kn">from</span> <span class="nn">sympy.core</span> <span class="kn">import</span> <span class="n">Rational</span><span class="p">,</span> <span class="n">Symbol</span>
<span class="kn">from</span> <span class="nn">sympy.core.numbers</span> <span class="kn">import</span> <span class="n">igcdex</span><span class="p">,</span> <span class="n">mod_inverse</span>
<span class="kn">from</span> <span class="nn">sympy.core.compatibility</span> <span class="kn">import</span> <span class="nb">range</span>
<span class="kn">from</span> <span class="nn">sympy.matrices</span> <span class="kn">import</span> <span class="n">Matrix</span>
<span class="kn">from</span> <span class="nn">sympy.ntheory</span> <span class="kn">import</span> <span class="n">isprime</span><span class="p">,</span> <span class="n">totient</span><span class="p">,</span> <span class="n">primitive_root</span>
<span class="kn">from</span> <span class="nn">sympy.polys.domains</span> <span class="kn">import</span> <span class="n">FF</span>
<span class="kn">from</span> <span class="nn">sympy.polys.polytools</span> <span class="kn">import</span> <span class="n">gcd</span><span class="p">,</span> <span class="n">Poly</span>
<span class="kn">from</span> <span class="nn">sympy.utilities.misc</span> <span class="kn">import</span> <span class="n">filldedent</span><span class="p">,</span> <span class="n">translate</span>
<span class="kn">from</span> <span class="nn">sympy.utilities.iterables</span> <span class="kn">import</span> <span class="n">uniq</span>
<span class="kn">from</span> <span class="nn">sympy.utilities.randtest</span> <span class="kn">import</span> <span class="n">_randrange</span>

<div class="viewcode-block" id="AZ"><a class="viewcode-back" href="../../../modules/crypto.html#sympy.crypto.crypto.AZ">[docs]</a><span class="k">def</span> <span class="nf">AZ</span><span class="p">(</span><span class="n">s</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return the letters of ``s`` in uppercase. In case more than</span>
<span class="sd">    one string is passed, each of them will be processed and a list</span>
<span class="sd">    of upper case strings will be returned.</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy.crypto.crypto import AZ</span>
<span class="sd">    &gt;&gt;&gt; AZ(&#39;Hello, world!&#39;)</span>
<span class="sd">    &#39;HELLOWORLD&#39;</span>
<span class="sd">    &gt;&gt;&gt; AZ(&#39;Hello, world!&#39;.split())</span>
<span class="sd">    [&#39;HELLO&#39;, &#39;WORLD&#39;]</span>

<span class="sd">    See Also</span>
<span class="sd">    ========</span>
<span class="sd">    check_and_join</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">s</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">uppercase</span>
    <span class="n">t</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">str</span>
    <span class="k">if</span> <span class="n">t</span><span class="p">:</span>
        <span class="n">s</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span><span class="p">]</span>
    <span class="n">rv</span> <span class="o">=</span> <span class="p">[</span><span class="n">check_and_join</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">(),</span> <span class="n">uppercase</span><span class="p">,</span> <span class="nb">filter</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">s</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">t</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">rv</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">rv</span></div>

<span class="n">bifid5</span> <span class="o">=</span> <span class="n">AZ</span><span class="p">()</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;J&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span>
<span class="n">bifid6</span> <span class="o">=</span> <span class="n">AZ</span><span class="p">()</span> <span class="o">+</span> <span class="s1">&#39;0123456789&#39;</span>
<span class="n">bifid10</span> <span class="o">=</span> <span class="n">printable</span>


<div class="viewcode-block" id="padded_key"><a class="viewcode-back" href="../../../modules/crypto.html#sympy.crypto.crypto.padded_key">[docs]</a><span class="k">def</span> <span class="nf">padded_key</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">symbols</span><span class="p">,</span> <span class="nb">filter</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return a string of the distinct characters of ``symbols`` with</span>
<span class="sd">    those of ``key`` appearing first, omitting characters in ``key``</span>
<span class="sd">    that are not in ``symbols``. A ValueError is raised if a) there are</span>
<span class="sd">    duplicate characters in ``symbols`` or b) there are characters</span>
<span class="sd">    in ``key`` that are  not in ``symbols``.</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy.crypto.crypto import padded_key</span>
<span class="sd">    &gt;&gt;&gt; padded_key(&#39;PUPPY&#39;, &#39;OPQRSTUVWXY&#39;)</span>
<span class="sd">    &#39;PUYOQRSTVWX&#39;</span>
<span class="sd">    &gt;&gt;&gt; padded_key(&#39;RSA&#39;, &#39;ARTIST&#39;)</span>
<span class="sd">    Traceback (most recent call last):</span>
<span class="sd">    ...</span>
<span class="sd">    ValueError: duplicate characters in symbols: T</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">syms</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">uniq</span><span class="p">(</span><span class="n">symbols</span><span class="p">))</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">syms</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">symbols</span><span class="p">):</span>
        <span class="n">extra</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span>
            <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">symbols</span> <span class="k">if</span> <span class="n">symbols</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">])))</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;duplicate characters in symbols: </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">extra</span><span class="p">)</span>
    <span class="n">extra</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="n">syms</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">extra</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s1">&#39;characters in key but not symbols: </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
            <span class="nb">sorted</span><span class="p">(</span><span class="n">extra</span><span class="p">)))</span>
    <span class="n">key0</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">uniq</span><span class="p">(</span><span class="n">key</span><span class="p">)))</span>
    <span class="k">return</span> <span class="n">key0</span> <span class="o">+</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">syms</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">key0</span><span class="p">])</span></div>


<div class="viewcode-block" id="check_and_join"><a class="viewcode-back" href="../../../modules/crypto.html#sympy.crypto.crypto.check_and_join">[docs]</a><span class="k">def</span> <span class="nf">check_and_join</span><span class="p">(</span><span class="n">phrase</span><span class="p">,</span> <span class="n">symbols</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="nb">filter</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Joins characters of `phrase` and if ``symbols`` is given, raises</span>
<span class="sd">    an error if any character in ``phrase`` is not in ``symbols``.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ==========</span>

<span class="sd">    phrase:     string or list of strings to be returned as a string</span>
<span class="sd">    symbols:    iterable of characters allowed in ``phrase``;</span>
<span class="sd">                if ``symbols`` is None, no checking is performed</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy.crypto.crypto import check_and_join</span>
<span class="sd">    &gt;&gt;&gt; check_and_join(&#39;a phrase&#39;)</span>
<span class="sd">    &#39;a phrase&#39;</span>
<span class="sd">    &gt;&gt;&gt; check_and_join(&#39;a phrase&#39;.upper().split())</span>
<span class="sd">    &#39;APHRASE&#39;</span>
<span class="sd">    &gt;&gt;&gt; check_and_join(&#39;a phrase!&#39;.upper().split(), &#39;ARE&#39;, filter=True)</span>
<span class="sd">    &#39;ARAE&#39;</span>
<span class="sd">    &gt;&gt;&gt; check_and_join(&#39;a phrase!&#39;.upper().split(), &#39;ARE&#39;)</span>
<span class="sd">    Traceback (most recent call last):</span>
<span class="sd">    ...</span>
<span class="sd">    ValueError: characters in phrase but not symbols: &quot;!HPS&quot;</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">rv</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">phrase</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">symbols</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">symbols</span> <span class="o">=</span> <span class="n">check_and_join</span><span class="p">(</span><span class="n">symbols</span><span class="p">)</span>
        <span class="n">missing</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">rv</span><span class="p">)</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="n">symbols</span><span class="p">))))</span>
        <span class="k">if</span> <span class="n">missing</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">filter</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s1">&#39;characters in phrase but not symbols: &quot;</span><span class="si">%s</span><span class="s1">&quot;&#39;</span> <span class="o">%</span> <span class="n">missing</span><span class="p">)</span>
            <span class="n">rv</span> <span class="o">=</span> <span class="n">translate</span><span class="p">(</span><span class="n">rv</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="n">missing</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">rv</span></div>


<span class="k">def</span> <span class="nf">_prep</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">alp</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">alp</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">default</span><span class="p">:</span>
            <span class="n">alp</span> <span class="o">=</span> <span class="n">AZ</span><span class="p">()</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="n">AZ</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
            <span class="n">key</span> <span class="o">=</span> <span class="n">AZ</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">alp</span> <span class="o">=</span> <span class="n">default</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">alp</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">alp</span><span class="p">)</span>
    <span class="n">key</span> <span class="o">=</span> <span class="n">check_and_join</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">alp</span><span class="p">,</span> <span class="nb">filter</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="n">msg</span> <span class="o">=</span> <span class="n">check_and_join</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">alp</span><span class="p">,</span> <span class="nb">filter</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">msg</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">alp</span>


<div class="viewcode-block" id="cycle_list"><a class="viewcode-back" href="../../../modules/crypto.html#sympy.crypto.crypto.cycle_list">[docs]</a><span class="k">def</span> <span class="nf">cycle_list</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the elements of the list ``range(n)`` shifted to the</span>
<span class="sd">    left by ``k`` (so the list starts with ``k`` (mod ``n``)).</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy.crypto.crypto import cycle_list</span>
<span class="sd">    &gt;&gt;&gt; cycle_list(3, 10)</span>
<span class="sd">    [3, 4, 5, 6, 7, 8, 9, 0, 1, 2]</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">k</span> <span class="o">=</span> <span class="n">k</span> <span class="o">%</span> <span class="n">n</span>
    <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">k</span><span class="p">))</span></div>


<span class="c1">######## shift cipher examples ############</span>


<div class="viewcode-block" id="encipher_shift"><a class="viewcode-back" href="../../../modules/crypto.html#sympy.crypto.crypto.encipher_shift">[docs]</a><span class="k">def</span> <span class="nf">encipher_shift</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">symbols</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Performs shift cipher encryption on plaintext msg, and returns the</span>
<span class="sd">    ciphertext.</span>

<span class="sd">    Notes</span>
<span class="sd">    =====</span>

<span class="sd">    The shift cipher is also called the Caesar cipher, after</span>
<span class="sd">    Julius Caesar, who, according to Suetonius, used it with a</span>
<span class="sd">    shift of three to protect messages of military significance.</span>
<span class="sd">    Caesar&#39;s nephew Augustus reportedly used a similar cipher, but</span>
<span class="sd">    with a right shift of 1.</span>


<span class="sd">    ALGORITHM:</span>

<span class="sd">        INPUT:</span>

<span class="sd">            ``key``: an integer (the secret key)</span>

<span class="sd">            ``msg``: plaintext of upper-case letters</span>

<span class="sd">        OUTPUT:</span>

<span class="sd">            ``ct``: ciphertext of upper-case letters</span>

<span class="sd">        STEPS:</span>
<span class="sd">            0. Number the letters of the alphabet from 0, ..., N</span>
<span class="sd">            1. Compute from the string ``msg`` a list ``L1`` of</span>
<span class="sd">               corresponding integers.</span>
<span class="sd">            2. Compute from the list ``L1`` a new list ``L2``, given by</span>
<span class="sd">               adding ``(k mod 26)`` to each element in ``L1``.</span>
<span class="sd">            3. Compute from the list ``L2`` a string ``ct`` of</span>
<span class="sd">               corresponding letters.</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy.crypto.crypto import encipher_shift, decipher_shift</span>
<span class="sd">    &gt;&gt;&gt; msg = &quot;GONAVYBEATARMY&quot;</span>
<span class="sd">    &gt;&gt;&gt; ct = encipher_shift(msg, 1); ct</span>
<span class="sd">    &#39;HPOBWZCFBUBSNZ&#39;</span>

<span class="sd">    To decipher the shifted text, change the sign of the key:</span>

<span class="sd">    &gt;&gt;&gt; encipher_shift(ct, -1)</span>
<span class="sd">    &#39;GONAVYBEATARMY&#39;</span>

<span class="sd">    There is also a convenience function that does this with the</span>
<span class="sd">    original key:</span>

<span class="sd">    &gt;&gt;&gt; decipher_shift(ct, 1)</span>
<span class="sd">    &#39;GONAVYBEATARMY&#39;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">msg</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">A</span> <span class="o">=</span> <span class="n">_prep</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">symbols</span><span class="p">)</span>
    <span class="n">shift</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">A</span><span class="p">)</span> <span class="o">-</span> <span class="n">key</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
    <span class="n">key</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">shift</span><span class="p">:]</span> <span class="o">+</span> <span class="n">A</span><span class="p">[:</span><span class="n">shift</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">translate</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">A</span><span class="p">)</span></div>


<div class="viewcode-block" id="decipher_shift"><a class="viewcode-back" href="../../../modules/crypto.html#sympy.crypto.crypto.decipher_shift">[docs]</a><span class="k">def</span> <span class="nf">decipher_shift</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">symbols</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the text by shifting the characters of ``msg`` to the</span>
<span class="sd">    left by the amount given by ``key``.</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy.crypto.crypto import encipher_shift, decipher_shift</span>
<span class="sd">    &gt;&gt;&gt; msg = &quot;GONAVYBEATARMY&quot;</span>
<span class="sd">    &gt;&gt;&gt; ct = encipher_shift(msg, 1); ct</span>
<span class="sd">    &#39;HPOBWZCFBUBSNZ&#39;</span>

<span class="sd">    To decipher the shifted text, change the sign of the key:</span>

<span class="sd">    &gt;&gt;&gt; encipher_shift(ct, -1)</span>
<span class="sd">    &#39;GONAVYBEATARMY&#39;</span>

<span class="sd">    Or use this function with the original key:</span>

<span class="sd">    &gt;&gt;&gt; decipher_shift(ct, 1)</span>
<span class="sd">    &#39;GONAVYBEATARMY&#39;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">encipher_shift</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="o">-</span><span class="n">key</span><span class="p">,</span> <span class="n">symbols</span><span class="p">)</span></div>


<span class="c1">######## affine cipher examples ############</span>


<div class="viewcode-block" id="encipher_affine"><a class="viewcode-back" href="../../../modules/crypto.html#sympy.crypto.crypto.encipher_affine">[docs]</a><span class="k">def</span> <span class="nf">encipher_affine</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">symbols</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">_inverse</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    Performs the affine cipher encryption on plaintext ``msg``, and</span>
<span class="sd">    returns the ciphertext.</span>

<span class="sd">    Encryption is based on the map `x \rightarrow ax+b` (mod `N`)</span>
<span class="sd">    where ``N`` is the number of characters in the alphabet.</span>
<span class="sd">    Decryption is based on the map `x \rightarrow cx+d` (mod `N`),</span>
<span class="sd">    where `c = a^{-1}` (mod `N`) and `d = -a^{-1}b` (mod `N`).</span>
<span class="sd">    In particular, for the map to be invertible, we need</span>
<span class="sd">    `\mathrm{gcd}(a, N) = 1` and an error will be raised if this is</span>
<span class="sd">    not true.</span>

<span class="sd">    Notes</span>
<span class="sd">    =====</span>

<span class="sd">    This is a straightforward generalization of the shift cipher with</span>
<span class="sd">    the added complexity of requiring 2 characters to be deciphered in</span>
<span class="sd">    order to recover the key.</span>

<span class="sd">    ALGORITHM:</span>

<span class="sd">        INPUT:</span>

<span class="sd">            ``msg``: string of characters that appear in ``symbols``</span>

<span class="sd">            ``a, b``: a pair integers, with ``gcd(a, N) = 1``</span>
<span class="sd">            (the secret key)</span>

<span class="sd">            ``symbols``: string of characters (default = uppercase</span>
<span class="sd">            letters). When no symbols are given, ``msg`` is converted</span>
<span class="sd">            to upper case letters and all other charactes are ignored.</span>

<span class="sd">        OUTPUT:</span>

<span class="sd">            ``ct``: string of characters (the ciphertext message)</span>

<span class="sd">        STEPS:</span>
<span class="sd">            0. Number the letters of the alphabet from 0, ..., N</span>
<span class="sd">            1. Compute from the string ``msg`` a list ``L1`` of</span>
<span class="sd">               corresponding integers.</span>
<span class="sd">            2. Compute from the list ``L1`` a new list ``L2``, given by</span>
<span class="sd">               replacing ``x`` by ``a*x + b (mod N)``, for each element</span>
<span class="sd">               ``x`` in ``L1``.</span>
<span class="sd">            3. Compute from the list ``L2`` a string ``ct`` of</span>
<span class="sd">               corresponding letters.</span>

<span class="sd">    See Also</span>
<span class="sd">    ========</span>
<span class="sd">    decipher_affine</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">msg</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">A</span> <span class="o">=</span> <span class="n">_prep</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">symbols</span><span class="p">)</span>
    <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
    <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">key</span>
    <span class="k">assert</span> <span class="n">gcd</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">N</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="n">_inverse</span><span class="p">:</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">mod_inverse</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">N</span><span class="p">)</span>
        <span class="n">d</span> <span class="o">=</span> <span class="o">-</span><span class="n">b</span><span class="o">*</span><span class="n">c</span>
        <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span>
    <span class="n">B</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">A</span><span class="p">[(</span><span class="n">a</span><span class="o">*</span><span class="n">i</span> <span class="o">+</span> <span class="n">b</span><span class="p">)</span> <span class="o">%</span> <span class="n">N</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">)])</span>
    <span class="k">return</span> <span class="n">translate</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span></div>


<div class="viewcode-block" id="decipher_affine"><a class="viewcode-back" href="../../../modules/crypto.html#sympy.crypto.crypto.decipher_affine">[docs]</a><span class="k">def</span> <span class="nf">decipher_affine</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">symbols</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    Return the deciphered text that was made from the mapping,</span>
<span class="sd">    `x \rightarrow ax+b` (mod `N`), where ``N`` is the</span>
<span class="sd">    number of characters in the alphabet. Deciphering is done by</span>
<span class="sd">    reciphering with a new key: `x \rightarrow cx+d` (mod `N`),</span>
<span class="sd">    where `c = a^{-1}` (mod `N`) and `d = -a^{-1}b` (mod `N`).</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy.crypto.crypto import encipher_affine, decipher_affine</span>
<span class="sd">    &gt;&gt;&gt; msg = &quot;GO NAVY BEAT ARMY&quot;</span>
<span class="sd">    &gt;&gt;&gt; key = (3, 1)</span>
<span class="sd">    &gt;&gt;&gt; encipher_affine(msg, key)</span>
<span class="sd">    &#39;TROBMVENBGBALV&#39;</span>
<span class="sd">    &gt;&gt;&gt; decipher_affine(_, key)</span>
<span class="sd">    &#39;GONAVYBEATARMY&#39;</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">encipher_affine</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">symbols</span><span class="p">,</span> <span class="n">_inverse</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span></div>


<span class="c1">#################### substitution cipher ###########################</span>


<div class="viewcode-block" id="encipher_substitution"><a class="viewcode-back" href="../../../modules/crypto.html#sympy.crypto.crypto.encipher_substitution">[docs]</a><span class="k">def</span> <span class="nf">encipher_substitution</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">old</span><span class="p">,</span> <span class="n">new</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the ciphertext obtained by replacing each character that</span>
<span class="sd">    appears in ``old`` with the corresponding character in ``new``.</span>
<span class="sd">    If ``old`` is a mapping, then new is ignored and the replacements</span>
<span class="sd">    defined by ``old`` are used.</span>

<span class="sd">    Notes</span>
<span class="sd">    =====</span>

<span class="sd">    This is a more general than the affine cipher in that the key can</span>
<span class="sd">    only be recovered by determining the mapping for each symbol.</span>
<span class="sd">    Though in practice, once a few symbols are recognized the mappings</span>
<span class="sd">    for other characters can be quickly guessed.</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy.crypto.crypto import encipher_substitution, AZ</span>
<span class="sd">    &gt;&gt;&gt; old = &#39;OEYAG&#39;</span>
<span class="sd">    &gt;&gt;&gt; new = &#39;034^6&#39;</span>
<span class="sd">    &gt;&gt;&gt; msg = AZ(&quot;go navy! beat army!&quot;)</span>
<span class="sd">    &gt;&gt;&gt; ct = encipher_substitution(msg, old, new); ct</span>
<span class="sd">    &#39;60N^V4B3^T^RM4&#39;</span>

<span class="sd">    To decrypt a substitution, reverse the last two arguments:</span>

<span class="sd">    &gt;&gt;&gt; encipher_substitution(ct, new, old)</span>
<span class="sd">    &#39;GONAVYBEATARMY&#39;</span>

<span class="sd">    In the special case where ``old`` and ``new`` are a permuation of</span>
<span class="sd">    order 2 (representing a transposition of characters) their order</span>
<span class="sd">    is immaterial:</span>

<span class="sd">    &gt;&gt;&gt; old = &#39;NAVY&#39;</span>
<span class="sd">    &gt;&gt;&gt; new = &#39;ANYV&#39;</span>
<span class="sd">    &gt;&gt;&gt; encipher = lambda x: encipher_substitution(x, old, new)</span>
<span class="sd">    &gt;&gt;&gt; encipher(&#39;NAVY&#39;)</span>
<span class="sd">    &#39;ANYV&#39;</span>
<span class="sd">    &gt;&gt;&gt; encipher(_)</span>
<span class="sd">    &#39;NAVY&#39;</span>

<span class="sd">    The substitution cipher, in general, is a method</span>
<span class="sd">    whereby &quot;units&quot; (not necessarily single characters) of plaintext</span>
<span class="sd">    are replaced with ciphertext according to a regular system.</span>

<span class="sd">    &gt;&gt;&gt; ords = dict(zip(&#39;abc&#39;, [&#39;\\%i&#39; % ord(i) for i in &#39;abc&#39;]))</span>
<span class="sd">    &gt;&gt;&gt; print(encipher_substitution(&#39;abc&#39;, ords))</span>
<span class="sd">    \97\98\99</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">translate</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">old</span><span class="p">,</span> <span class="n">new</span><span class="p">)</span></div>


<span class="c1">######################################################################</span>
<span class="c1">#################### Vigenère cipher examples ########################</span>
<span class="c1">######################################################################</span>

<div class="viewcode-block" id="encipher_vigenere"><a class="viewcode-back" href="../../../modules/crypto.html#sympy.crypto.crypto.encipher_vigenere">[docs]</a><span class="k">def</span> <span class="nf">encipher_vigenere</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">symbols</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Performs the Vigenère cipher encryption on plaintext ``msg``, and</span>
<span class="sd">    returns the ciphertext.</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy.crypto.crypto import encipher_vigenere, AZ</span>
<span class="sd">    &gt;&gt;&gt; key = &quot;encrypt&quot;</span>
<span class="sd">    &gt;&gt;&gt; msg = &quot;meet me on monday&quot;</span>
<span class="sd">    &gt;&gt;&gt; encipher_vigenere(msg, key)</span>
<span class="sd">    &#39;QRGKKTHRZQEBPR&#39;</span>

<span class="sd">    Section 1 of the Kryptos sculpture at the CIA headquarters</span>
<span class="sd">    uses this cipher and also changes the order of the the</span>
<span class="sd">    alphabet [2]_. Here is the first line of that section of</span>
<span class="sd">    the sculpture:</span>

<span class="sd">    &gt;&gt;&gt; from sympy.crypto.crypto import decipher_vigenere, padded_key</span>
<span class="sd">    &gt;&gt;&gt; alp = padded_key(&#39;KRYPTOS&#39;, AZ())</span>
<span class="sd">    &gt;&gt;&gt; key = &#39;PALIMPSEST&#39;</span>
<span class="sd">    &gt;&gt;&gt; msg = &#39;EMUFPHZLRFAXYUSDJKZLDKRNSHGNFIVJ&#39;</span>
<span class="sd">    &gt;&gt;&gt; decipher_vigenere(msg, key, alp)</span>
<span class="sd">    &#39;BETWEENSUBTLESHADINGANDTHEABSENC&#39;</span>

<span class="sd">    Notes</span>
<span class="sd">    =====</span>

<span class="sd">    The Vigenère cipher is named after Blaise de Vigenère, a sixteenth</span>
<span class="sd">    century diplomat and cryptographer, by a historical accident.</span>
<span class="sd">    Vigenère actually invented a different and more complicated cipher.</span>
<span class="sd">    The so-called *Vigenère cipher* was actually invented</span>
<span class="sd">    by Giovan Batista Belaso in 1553.</span>

<span class="sd">    This cipher was used in the 1800&#39;s, for example, during the American</span>
<span class="sd">    Civil War. The Confederacy used a brass cipher disk to implement the</span>
<span class="sd">    Vigenère cipher (now on display in the NSA Museum in Fort</span>
<span class="sd">    Meade) [1]_.</span>

<span class="sd">    The Vigenère cipher is a generalization of the shift cipher.</span>
<span class="sd">    Whereas the shift cipher shifts each letter by the same amount</span>
<span class="sd">    (that amount being the key of the shift cipher) the Vigenère</span>
<span class="sd">    cipher shifts a letter by an amount determined by the key (which is</span>
<span class="sd">    a word or phrase known only to the sender and receiver).</span>

<span class="sd">    For example, if the key was a single letter, such as &quot;C&quot;, then the</span>
<span class="sd">    so-called Vigenere cipher is actually a shift cipher with a</span>
<span class="sd">    shift of `2` (since &quot;C&quot; is the 2nd letter of the alphabet, if</span>
<span class="sd">    you start counting at `0`). If the key was a word with two</span>
<span class="sd">    letters, such as &quot;CA&quot;, then the so-called Vigenère cipher will</span>
<span class="sd">    shift letters in even positions by `2` and letters in odd positions</span>
<span class="sd">    are left alone (shifted by `0`, since &quot;A&quot; is the 0th letter, if</span>
<span class="sd">    you start counting at `0`).</span>


<span class="sd">    ALGORITHM:</span>

<span class="sd">        INPUT:</span>

<span class="sd">            ``msg``: string of characters that appear in ``symbols``</span>
<span class="sd">            (the plaintext)</span>

<span class="sd">            ``key``: a string of characters that appear in ``symbols``</span>
<span class="sd">            (the secret key)</span>

<span class="sd">            ``symbols``: a string of letters defining the alphabet</span>


<span class="sd">        OUTPUT:</span>

<span class="sd">            ``ct``: string of characters (the ciphertext message)</span>

<span class="sd">        STEPS:</span>
<span class="sd">            0. Number the letters of the alphabet from 0, ..., N</span>
<span class="sd">            1. Compute from the string ``key`` a list ``L1`` of</span>
<span class="sd">               corresponding integers. Let ``n1 = len(L1)``.</span>
<span class="sd">            2. Compute from the string ``msg`` a list ``L2`` of</span>
<span class="sd">               corresponding integers. Let ``n2 = len(L2)``.</span>
<span class="sd">            3. Break ``L2`` up sequencially into sublists of size</span>
<span class="sd">               ``n1``; the last sublist may be smaller than ``n1``</span>
<span class="sd">            4. For each of these sublists ``L`` of ``L2``, compute a</span>
<span class="sd">               new list ``C`` given by ``C[i] = L[i] + L1[i] (mod N)``</span>
<span class="sd">               to the ``i``-th element in the sublist, for each ``i``.</span>
<span class="sd">            5. Assemble these lists ``C`` by concatenation into a new</span>
<span class="sd">               list of length ``n2``.</span>
<span class="sd">            6. Compute from the new list a string ``ct`` of</span>
<span class="sd">               corresponding letters.</span>

<span class="sd">    Once it is known that the key is, say, `n` characters long,</span>
<span class="sd">    frequency analysis can be applied to every `n`-th letter of</span>
<span class="sd">    the ciphertext to determine the plaintext. This method is</span>
<span class="sd">    called *Kasiski examination* (although it was first discovered</span>
<span class="sd">    by Babbage). If they key is as long as the message and is</span>
<span class="sd">    comprised of randomly selected characters -- a one-time pad -- the</span>
<span class="sd">    message is theoretically unbreakable.</span>

<span class="sd">    The cipher Vigenère actually discovered is an &quot;auto-key&quot; cipher</span>
<span class="sd">    described as follows.</span>

<span class="sd">    ALGORITHM:</span>

<span class="sd">        INPUT:</span>

<span class="sd">          ``key``: a string of letters (the secret key)</span>

<span class="sd">          ``msg``: string of letters (the plaintext message)</span>

<span class="sd">        OUTPUT:</span>

<span class="sd">          ``ct``: string of upper-case letters (the ciphertext message)</span>

<span class="sd">        STEPS:</span>
<span class="sd">            0. Number the letters of the alphabet from 0, ..., N</span>
<span class="sd">            1. Compute from the string ``msg`` a list ``L2`` of</span>
<span class="sd">               corresponding integers. Let ``n2 = len(L2)``.</span>
<span class="sd">            2. Let ``n1`` be the length of the key. Append to the</span>
<span class="sd">               string ``key`` the first ``n2 - n1`` characters of</span>
<span class="sd">               the plaintext message. Compute from this string (also of</span>
<span class="sd">               length ``n2``) a list ``L1`` of integers corresponding</span>
<span class="sd">               to the letter numbers in the first step.</span>
<span class="sd">            3. Compute a new list ``C`` given by</span>
<span class="sd">               ``C[i] = L1[i] + L2[i] (mod N)``.</span>
<span class="sd">            4. Compute from the new list a string ``ct`` of letters</span>
<span class="sd">               corresponding to the new integers.</span>

<span class="sd">    To decipher the auto-key ciphertext, the key is used to decipher</span>
<span class="sd">    the first ``n1`` characters and then those characters become the</span>
<span class="sd">    key to  decipher the next ``n1`` characters, etc...:</span>

<span class="sd">    &gt;&gt;&gt; m = AZ(&#39;go navy, beat army! yes you can&#39;); m</span>
<span class="sd">    &#39;GONAVYBEATARMYYESYOUCAN&#39;</span>
<span class="sd">    &gt;&gt;&gt; key = AZ(&#39;gold bug&#39;); n1 = len(key); n2 = len(m)</span>
<span class="sd">    &gt;&gt;&gt; auto_key = key + m[:n2 - n1]; auto_key</span>
<span class="sd">    &#39;GOLDBUGGONAVYBEATARMYYE&#39;</span>
<span class="sd">    &gt;&gt;&gt; ct = encipher_vigenere(m, auto_key); ct</span>
<span class="sd">    &#39;MCYDWSHKOGAMKZCELYFGAYR&#39;</span>
<span class="sd">    &gt;&gt;&gt; n1 = len(key)</span>
<span class="sd">    &gt;&gt;&gt; pt = []</span>
<span class="sd">    &gt;&gt;&gt; while ct:</span>
<span class="sd">    ...     part, ct = ct[:n1], ct[n1:]</span>
<span class="sd">    ...     pt.append(decipher_vigenere(part, key))</span>
<span class="sd">    ...     key = pt[-1]</span>
<span class="sd">    ...</span>
<span class="sd">    &gt;&gt;&gt; &#39;&#39;.join(pt) == m</span>
<span class="sd">    True</span>

<span class="sd">    References</span>
<span class="sd">    ==========</span>

<span class="sd">    .. [1] http://en.wikipedia.org/wiki/Vigenere_cipher</span>
<span class="sd">    .. [2] http://web.archive.org/web/20071116100808/</span>
<span class="sd">       http://filebox.vt.edu/users/batman/kryptos.html</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">msg</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">A</span> <span class="o">=</span> <span class="n">_prep</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">symbols</span><span class="p">)</span>
    <span class="nb">map</span> <span class="o">=</span> <span class="p">{</span><span class="n">c</span><span class="p">:</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">A</span><span class="p">)}</span>
    <span class="n">key</span> <span class="o">=</span> <span class="p">[</span><span class="nb">map</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">key</span><span class="p">]</span>
    <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">map</span><span class="p">)</span>
    <span class="n">k</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
    <span class="n">rv</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">msg</span><span class="p">):</span>
        <span class="n">rv</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">A</span><span class="p">[(</span><span class="nb">map</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">+</span> <span class="n">key</span><span class="p">[</span><span class="n">i</span> <span class="o">%</span> <span class="n">k</span><span class="p">])</span> <span class="o">%</span> <span class="n">N</span><span class="p">])</span>
    <span class="n">rv</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">rv</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">rv</span></div>


<div class="viewcode-block" id="decipher_vigenere"><a class="viewcode-back" href="../../../modules/crypto.html#sympy.crypto.crypto.decipher_vigenere">[docs]</a><span class="k">def</span> <span class="nf">decipher_vigenere</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">symbols</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Decode using the Vigenère cipher.</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy.crypto.crypto import decipher_vigenere</span>
<span class="sd">    &gt;&gt;&gt; key = &quot;encrypt&quot;</span>
<span class="sd">    &gt;&gt;&gt; ct = &quot;QRGK kt HRZQE BPR&quot;</span>
<span class="sd">    &gt;&gt;&gt; decipher_vigenere(ct, key)</span>
<span class="sd">    &#39;MEETMEONMONDAY&#39;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">msg</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">A</span> <span class="o">=</span> <span class="n">_prep</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">symbols</span><span class="p">)</span>
    <span class="nb">map</span> <span class="o">=</span> <span class="p">{</span><span class="n">c</span><span class="p">:</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">A</span><span class="p">)}</span>
    <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>   <span class="c1"># normally, 26</span>
    <span class="n">K</span> <span class="o">=</span> <span class="p">[</span><span class="nb">map</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">key</span><span class="p">]</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">K</span><span class="p">)</span>
    <span class="n">C</span> <span class="o">=</span> <span class="p">[</span><span class="nb">map</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">msg</span><span class="p">]</span>
    <span class="n">rv</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">A</span><span class="p">[(</span><span class="o">-</span><span class="n">K</span><span class="p">[</span><span class="n">i</span> <span class="o">%</span> <span class="n">n</span><span class="p">]</span> <span class="o">+</span> <span class="n">c</span><span class="p">)</span> <span class="o">%</span> <span class="n">N</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">C</span><span class="p">)])</span>
    <span class="k">return</span> <span class="n">rv</span></div>


<span class="c1">#################### Hill cipher  ########################</span>


<div class="viewcode-block" id="encipher_hill"><a class="viewcode-back" href="../../../modules/crypto.html#sympy.crypto.crypto.encipher_hill">[docs]</a><span class="k">def</span> <span class="nf">encipher_hill</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">symbols</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">pad</span><span class="o">=</span><span class="s2">&quot;Q&quot;</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    Return the Hill cipher encryption of ``msg``.</span>

<span class="sd">    Notes</span>
<span class="sd">    =====</span>

<span class="sd">    The Hill cipher [1]_, invented by Lester S. Hill in the 1920&#39;s [2]_,</span>
<span class="sd">    was the first polygraphic cipher in which it was practical</span>
<span class="sd">    (though barely) to operate on more than three symbols at once.</span>
<span class="sd">    The following discussion assumes an elementary knowledge of</span>
<span class="sd">    matrices.</span>

<span class="sd">    First, each letter is first encoded as a number starting with 0.</span>
<span class="sd">    Suppose your message `msg` consists of `n` capital letters, with no</span>
<span class="sd">    spaces. This may be regarded an `n`-tuple M of elements of</span>
<span class="sd">    `Z_{26}` (if the letters are those of the English alphabet). A key</span>
<span class="sd">    in the Hill cipher is a `k x k` matrix `K`, all of whose entries</span>
<span class="sd">    are in `Z_{26}`, such that the matrix `K` is invertible (i.e., the</span>
<span class="sd">    linear transformation `K: Z_{N}^k \rightarrow Z_{N}^k`</span>
<span class="sd">    is one-to-one).</span>

<span class="sd">    ALGORITHM:</span>

<span class="sd">        INPUT:</span>

<span class="sd">            ``msg``: plaintext message of `n` upper-case letters</span>

<span class="sd">            ``key``: a `k x k` invertible matrix `K`, all of whose</span>
<span class="sd">            entries are in `Z_{26}` (or whatever number of symbols</span>
<span class="sd">            are being used).</span>

<span class="sd">            ``pad``: character (default &quot;Q&quot;) to use to make length</span>
<span class="sd">            of text be a multiple of ``k``</span>

<span class="sd">        OUTPUT:</span>

<span class="sd">            ``ct``: ciphertext of upper-case letters</span>

<span class="sd">        STEPS:</span>
<span class="sd">            0. Number the letters of the alphabet from 0, ..., N</span>
<span class="sd">            1. Compute from the string ``msg`` a list ``L`` of</span>
<span class="sd">               corresponding integers. Let ``n = len(L)``.</span>
<span class="sd">            2. Break the list ``L`` up into ``t = ceiling(n/k)``</span>
<span class="sd">               sublists ``L_1``, ..., ``L_t`` of size ``k`` (with</span>
<span class="sd">               the last list &quot;padded&quot; to ensure its size is</span>
<span class="sd">               ``k``).</span>
<span class="sd">            3. Compute new list ``C_1``, ..., ``C_t`` given by</span>
<span class="sd">               ``C[i] = K*L_i`` (arithmetic is done mod N), for each</span>
<span class="sd">               ``i``.</span>
<span class="sd">            4. Concatenate these into a list ``C = C_1 + ... + C_t``.</span>
<span class="sd">            5. Compute from ``C`` a string ``ct`` of corresponding</span>
<span class="sd">               letters. This has length ``k*t``.</span>

<span class="sd">    References</span>
<span class="sd">    ==========</span>

<span class="sd">    .. [1] en.wikipedia.org/wiki/Hill_cipher</span>
<span class="sd">    .. [2] Lester S. Hill, Cryptography in an Algebraic Alphabet,</span>
<span class="sd">       The American Mathematical Monthly Vol.36, June-July 1929,</span>
<span class="sd">       pp.306-312.</span>

<span class="sd">    See Also</span>
<span class="sd">    ========</span>
<span class="sd">    decipher_hill</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="n">key</span><span class="o">.</span><span class="n">is_square</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">pad</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
    <span class="n">msg</span><span class="p">,</span> <span class="n">pad</span><span class="p">,</span> <span class="n">A</span> <span class="o">=</span> <span class="n">_prep</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">pad</span><span class="p">,</span> <span class="n">symbols</span><span class="p">)</span>
    <span class="nb">map</span> <span class="o">=</span> <span class="p">{</span><span class="n">c</span><span class="p">:</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">A</span><span class="p">)}</span>
    <span class="n">P</span> <span class="o">=</span> <span class="p">[</span><span class="nb">map</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">msg</span><span class="p">]</span>
    <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
    <span class="n">k</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="n">cols</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">P</span><span class="p">)</span>
    <span class="n">m</span><span class="p">,</span> <span class="n">r</span> <span class="o">=</span> <span class="nb">divmod</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">r</span><span class="p">:</span>
        <span class="n">P</span> <span class="o">=</span> <span class="n">P</span> <span class="o">+</span> <span class="p">[</span><span class="nb">map</span><span class="p">[</span><span class="n">pad</span><span class="p">]]</span><span class="o">*</span><span class="p">(</span><span class="n">k</span> <span class="o">-</span> <span class="n">r</span><span class="p">)</span>
        <span class="n">m</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="n">rv</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">A</span><span class="p">[</span><span class="n">c</span> <span class="o">%</span> <span class="n">N</span><span class="p">]</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span>
        <span class="nb">list</span><span class="p">(</span><span class="n">key</span><span class="o">*</span><span class="n">Matrix</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">[</span><span class="n">P</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k</span><span class="o">*</span><span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="o">*</span><span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))]))])</span>
    <span class="k">return</span> <span class="n">rv</span></div>


<div class="viewcode-block" id="decipher_hill"><a class="viewcode-back" href="../../../modules/crypto.html#sympy.crypto.crypto.decipher_hill">[docs]</a><span class="k">def</span> <span class="nf">decipher_hill</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">symbols</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Deciphering is the same as enciphering but using the inverse of the</span>
<span class="sd">    key matrix.</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy.crypto.crypto import encipher_hill, decipher_hill</span>
<span class="sd">    &gt;&gt;&gt; from sympy import Matrix</span>

<span class="sd">    &gt;&gt;&gt; key = Matrix([[1, 2], [3, 5]])</span>
<span class="sd">    &gt;&gt;&gt; encipher_hill(&quot;meet me on monday&quot;, key)</span>
<span class="sd">    &#39;UEQDUEODOCTCWQ&#39;</span>
<span class="sd">    &gt;&gt;&gt; decipher_hill(_, key)</span>
<span class="sd">    &#39;MEETMEONMONDAY&#39;</span>

<span class="sd">    When the length of the plaintext (stripped of invalid characters)</span>
<span class="sd">    is not a multiple of the key dimension, extra characters will</span>
<span class="sd">    appear at the end of the enciphered and deciphered text. In order to</span>
<span class="sd">    decipher the text, those characters must be included in the text to</span>
<span class="sd">    be deciphered. In the following, the key has a dimension of 4 but</span>
<span class="sd">    the text is 2 short of being a multiple of 4 so two characters will</span>
<span class="sd">    be added.</span>

<span class="sd">    &gt;&gt;&gt; key = Matrix([[1, 1, 1, 2], [0, 1, 1, 0],</span>
<span class="sd">    ...               [2, 2, 3, 4], [1, 1, 0, 1]])</span>
<span class="sd">    &gt;&gt;&gt; msg = &quot;ST&quot;</span>
<span class="sd">    &gt;&gt;&gt; encipher_hill(msg, key)</span>
<span class="sd">    &#39;HJEB&#39;</span>
<span class="sd">    &gt;&gt;&gt; decipher_hill(_, key)</span>
<span class="sd">    &#39;STQQ&#39;</span>
<span class="sd">    &gt;&gt;&gt; encipher_hill(msg, key, pad=&quot;Z&quot;)</span>
<span class="sd">    &#39;ISPK&#39;</span>
<span class="sd">    &gt;&gt;&gt; decipher_hill(_, key)</span>
<span class="sd">    &#39;STZZ&#39;</span>

<span class="sd">    If the last two characters of the ciphertext were ignored in</span>
<span class="sd">    either case, the wrong plaintext would be recovered:</span>

<span class="sd">    &gt;&gt;&gt; decipher_hill(&quot;HD&quot;, key)</span>
<span class="sd">    &#39;ORMV&#39;</span>
<span class="sd">    &gt;&gt;&gt; decipher_hill(&quot;IS&quot;, key)</span>
<span class="sd">    &#39;UIKY&#39;</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="n">key</span><span class="o">.</span><span class="n">is_square</span>
    <span class="n">msg</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">A</span> <span class="o">=</span> <span class="n">_prep</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">symbols</span><span class="p">)</span>
    <span class="nb">map</span> <span class="o">=</span> <span class="p">{</span><span class="n">c</span><span class="p">:</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">A</span><span class="p">)}</span>
    <span class="n">C</span> <span class="o">=</span> <span class="p">[</span><span class="nb">map</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">msg</span><span class="p">]</span>
    <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
    <span class="n">k</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="n">cols</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">C</span><span class="p">)</span>
    <span class="n">m</span><span class="p">,</span> <span class="n">r</span> <span class="o">=</span> <span class="nb">divmod</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">r</span><span class="p">:</span>
        <span class="n">C</span> <span class="o">=</span> <span class="n">C</span> <span class="o">+</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">k</span> <span class="o">-</span> <span class="n">r</span><span class="p">)</span>
        <span class="n">m</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="n">key_inv</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="n">inv_mod</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
    <span class="n">rv</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">A</span><span class="p">[</span><span class="n">p</span> <span class="o">%</span> <span class="n">N</span><span class="p">]</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span>
        <span class="nb">list</span><span class="p">(</span><span class="n">key_inv</span><span class="o">*</span><span class="n">Matrix</span><span class="p">(</span>
        <span class="n">k</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">[</span><span class="n">C</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k</span><span class="o">*</span><span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="o">*</span><span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))]))])</span>
    <span class="k">return</span> <span class="n">rv</span></div>


<span class="c1">#################### Bifid cipher  ########################</span>


<div class="viewcode-block" id="encipher_bifid"><a class="viewcode-back" href="../../../modules/crypto.html#sympy.crypto.crypto.encipher_bifid">[docs]</a><span class="k">def</span> <span class="nf">encipher_bifid</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">symbols</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    Performs the Bifid cipher encryption on plaintext ``msg``, and</span>
<span class="sd">    returns the ciphertext.</span>

<span class="sd">    This is the version of the Bifid cipher that uses an `n \times n`</span>
<span class="sd">    Polybius square.</span>

<span class="sd">        INPUT:</span>

<span class="sd">            ``msg``: plaintext string</span>

<span class="sd">            ``key``: short string for key; duplicate characters are</span>
<span class="sd">            ignored and then it is padded with the characters in</span>
<span class="sd">            ``symbols`` that were not in the short key</span>

<span class="sd">            ``symbols``: `n \times n` characters defining the alphabet</span>
<span class="sd">            (default is string.printable)</span>

<span class="sd">        OUTPUT:</span>

<span class="sd">            ciphertext (using Bifid5 cipher without spaces)</span>

<span class="sd">    See Also</span>
<span class="sd">    ========</span>
<span class="sd">    decipher_bifid, encipher_bifid5, encipher_bifid6</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">msg</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">A</span> <span class="o">=</span> <span class="n">_prep</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">symbols</span><span class="p">,</span> <span class="n">bifid10</span><span class="p">)</span>
    <span class="n">long_key</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">uniq</span><span class="p">(</span><span class="n">key</span><span class="p">))</span> <span class="ow">or</span> <span class="n">A</span>

    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">A</span><span class="p">)</span><span class="o">**.</span><span class="mi">5</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">!=</span> <span class="nb">int</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s1">&#39;Length of alphabet (</span><span class="si">%s</span><span class="s1">) is not a square number.&#39;</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">A</span><span class="p">))</span>
    <span class="n">N</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">long_key</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">N</span><span class="o">**</span><span class="mi">2</span><span class="p">:</span>
      <span class="n">long_key</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">long_key</span><span class="p">)</span> <span class="o">+</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">A</span> <span class="k">if</span> <span class="n">x</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">long_key</span><span class="p">]</span>

    <span class="c1"># the fractionalization</span>
    <span class="n">row_col</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">([(</span><span class="n">ch</span><span class="p">,</span> <span class="nb">divmod</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">N</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">ch</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">long_key</span><span class="p">)])</span>
    <span class="n">r</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">row_col</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">msg</span><span class="p">])</span>
    <span class="n">rc</span> <span class="o">=</span> <span class="n">r</span> <span class="o">+</span> <span class="n">c</span>
    <span class="n">ch</span> <span class="o">=</span> <span class="p">{</span><span class="n">i</span><span class="p">:</span> <span class="n">ch</span> <span class="k">for</span> <span class="n">ch</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">row_col</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
    <span class="n">rv</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">((</span><span class="n">ch</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">rc</span><span class="p">[::</span><span class="mi">2</span><span class="p">],</span> <span class="n">rc</span><span class="p">[</span><span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">])))</span>
    <span class="k">return</span> <span class="n">rv</span></div>


<div class="viewcode-block" id="decipher_bifid"><a class="viewcode-back" href="../../../modules/crypto.html#sympy.crypto.crypto.decipher_bifid">[docs]</a><span class="k">def</span> <span class="nf">decipher_bifid</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">symbols</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    Performs the Bifid cipher decryption on ciphertext ``msg``, and</span>
<span class="sd">    returns the plaintext.</span>

<span class="sd">    This is the version of the Bifid cipher that uses the `n \times n`</span>
<span class="sd">    Polybius square.</span>

<span class="sd">        INPUT:</span>

<span class="sd">            ``msg``: ciphertext string</span>

<span class="sd">            ``key``: short string for key; duplicate characters are</span>
<span class="sd">            ignored and then it is padded with the characters in</span>
<span class="sd">            ``symbols`` that were not in the short key</span>

<span class="sd">            ``symbols``: `n \times n` characters defining the alphabet</span>
<span class="sd">            (default=string.printable, a `10 \times 10` matrix)</span>

<span class="sd">        OUTPUT:</span>

<span class="sd">            deciphered text</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy.crypto.crypto import (</span>
<span class="sd">    ...     encipher_bifid, decipher_bifid, AZ)</span>

<span class="sd">    Do an encryption using the bifid5 alphabet:</span>

<span class="sd">    &gt;&gt;&gt; alp = AZ().replace(&#39;J&#39;, &#39;&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ct = AZ(&quot;meet me on monday!&quot;)</span>
<span class="sd">    &gt;&gt;&gt; key = AZ(&quot;gold bug&quot;)</span>
<span class="sd">    &gt;&gt;&gt; encipher_bifid(ct, key, alp)</span>
<span class="sd">    &#39;IEILHHFSTSFQYE&#39;</span>

<span class="sd">    When entering the text or ciphertext, spaces are ignored so it</span>
<span class="sd">    can be formatted as desired. Re-entering the ciphertext from the</span>
<span class="sd">    preceding, putting 4 characters per line and padding with an extra</span>
<span class="sd">    J, does not cause problems for the deciphering:</span>

<span class="sd">    &gt;&gt;&gt; decipher_bifid(&#39;&#39;&#39;</span>
<span class="sd">    ... IEILH</span>
<span class="sd">    ... HFSTS</span>
<span class="sd">    ... FQYEJ&#39;&#39;&#39;, key, alp)</span>
<span class="sd">    &#39;MEETMEONMONDAY&#39;</span>

<span class="sd">    When no alphabet is given, all 100 printable characters will be</span>
<span class="sd">    used:</span>

<span class="sd">    &gt;&gt;&gt; key = &#39;&#39;</span>
<span class="sd">    &gt;&gt;&gt; encipher_bifid(&#39;hello world!&#39;, key)</span>
<span class="sd">    &#39;bmtwmg-bIo*w&#39;</span>
<span class="sd">    &gt;&gt;&gt; decipher_bifid(_, key)</span>
<span class="sd">    &#39;hello world!&#39;</span>

<span class="sd">    If the key is changed, a different encryption is obtained:</span>

<span class="sd">    &gt;&gt;&gt; key = &#39;gold bug&#39;</span>
<span class="sd">    &gt;&gt;&gt; encipher_bifid(&#39;hello world!&#39;, &#39;gold_bug&#39;)</span>
<span class="sd">    &#39;hg2sfuei7t}w&#39;</span>

<span class="sd">    And if the key used to decrypt the message is not exact, the</span>
<span class="sd">    original text will not be perfectly obtained:</span>

<span class="sd">    &gt;&gt;&gt; decipher_bifid(_, &#39;gold pug&#39;)</span>
<span class="sd">    &#39;heldo~wor6d!&#39;</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">msg</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">A</span> <span class="o">=</span> <span class="n">_prep</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">symbols</span><span class="p">,</span> <span class="n">bifid10</span><span class="p">)</span>
    <span class="n">long_key</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">uniq</span><span class="p">(</span><span class="n">key</span><span class="p">))</span> <span class="ow">or</span> <span class="n">A</span>

    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">A</span><span class="p">)</span><span class="o">**.</span><span class="mi">5</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">!=</span> <span class="nb">int</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s1">&#39;Length of alphabet (</span><span class="si">%s</span><span class="s1">) is not a square number.&#39;</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">A</span><span class="p">))</span>
    <span class="n">N</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">long_key</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">N</span><span class="o">**</span><span class="mi">2</span><span class="p">:</span>
        <span class="n">long_key</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">long_key</span><span class="p">)</span> <span class="o">+</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">A</span> <span class="k">if</span> <span class="n">x</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">long_key</span><span class="p">]</span>

    <span class="c1"># the reverse fractionalization</span>
    <span class="n">row_col</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
        <span class="p">[(</span><span class="n">ch</span><span class="p">,</span> <span class="nb">divmod</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">N</span><span class="p">))</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">ch</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">long_key</span><span class="p">)])</span>
    <span class="n">rc</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">msg</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">row_col</span><span class="p">[</span><span class="n">c</span><span class="p">]]</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
    <span class="n">rc</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">rc</span><span class="p">[:</span><span class="n">n</span><span class="p">],</span> <span class="n">rc</span><span class="p">[</span><span class="n">n</span><span class="p">:]))</span>
    <span class="n">ch</span> <span class="o">=</span> <span class="p">{</span><span class="n">i</span><span class="p">:</span> <span class="n">ch</span> <span class="k">for</span> <span class="n">ch</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">row_col</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
    <span class="n">rv</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">((</span><span class="n">ch</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">rc</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">rv</span></div>


<span class="k">def</span> <span class="nf">bifid_square</span><span class="p">(</span><span class="n">key</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return characters of ``key`` arranged in a square.</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy.crypto.crypto import (</span>
<span class="sd">    ...    bifid_square, AZ, padded_key, bifid5)</span>
<span class="sd">    &gt;&gt;&gt; bifid_square(AZ().replace(&#39;J&#39;, &#39;&#39;))</span>
<span class="sd">    Matrix([</span>
<span class="sd">    [A, B, C, D, E],</span>
<span class="sd">    [F, G, H, I, K],</span>
<span class="sd">    [L, M, N, O, P],</span>
<span class="sd">    [Q, R, S, T, U],</span>
<span class="sd">    [V, W, X, Y, Z]])</span>

<span class="sd">    &gt;&gt;&gt; bifid_square(padded_key(AZ(&#39;gold bug!&#39;), bifid5))</span>
<span class="sd">    Matrix([</span>
<span class="sd">    [G, O, L, D, B],</span>
<span class="sd">    [U, A, C, E, F],</span>
<span class="sd">    [H, I, K, M, N],</span>
<span class="sd">    [P, Q, R, S, T],</span>
<span class="sd">    [V, W, X, Y, Z]])</span>

<span class="sd">    See Also</span>
<span class="sd">    ========</span>
<span class="sd">    padded_key</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">A</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">uniq</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">key</span><span class="p">)))</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">A</span><span class="p">)</span><span class="o">**.</span><span class="mi">5</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">!=</span> <span class="nb">int</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s1">&#39;Length of alphabet (</span><span class="si">%s</span><span class="s1">) is not a square number.&#39;</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">A</span><span class="p">))</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
    <span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">:</span> <span class="n">Symbol</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">n</span><span class="o">*</span><span class="n">i</span> <span class="o">+</span> <span class="n">j</span><span class="p">])</span>
    <span class="n">rv</span> <span class="o">=</span> <span class="n">Matrix</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">rv</span>


<div class="viewcode-block" id="encipher_bifid5"><a class="viewcode-back" href="../../../modules/crypto.html#sympy.crypto.crypto.encipher_bifid5">[docs]</a><span class="k">def</span> <span class="nf">encipher_bifid5</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    Performs the Bifid cipher encryption on plaintext ``msg``, and</span>
<span class="sd">    returns the ciphertext.</span>

<span class="sd">    This is the version of the Bifid cipher that uses the `5 \times 5`</span>
<span class="sd">    Polybius square. The letter &quot;J&quot; is ignored so it must be replaced</span>
<span class="sd">    with something else (traditionally an &quot;I&quot;) before encryption.</span>

<span class="sd">    Notes</span>
<span class="sd">    =====</span>

<span class="sd">    The Bifid cipher was invented around 1901 by Felix Delastelle.</span>
<span class="sd">    It is a *fractional substitution* cipher, where letters are</span>
<span class="sd">    replaced by pairs of symbols from a smaller alphabet. The</span>
<span class="sd">    cipher uses a `5 \times 5` square filled with some ordering of the</span>
<span class="sd">    alphabet, except that &quot;J&quot; is replaced with &quot;I&quot; (this is a so-called</span>
<span class="sd">    Polybius square; there is a `6 \times 6` analog if you add back in</span>
<span class="sd">    &quot;J&quot; and also append onto the usual 26 letter alphabet, the digits</span>
<span class="sd">    0, 1, ..., 9).</span>
<span class="sd">    According to Helen Gaines&#39; book *Cryptanalysis*, this type of cipher</span>
<span class="sd">    was used in the field by the German Army during World War I.</span>

<span class="sd">    ALGORITHM: (5x5 case)</span>

<span class="sd">        INPUT:</span>

<span class="sd">            ``msg``: plaintext string; converted to upper case and</span>
<span class="sd">            filtered of anything but all letters except J.</span>

<span class="sd">            ``key``: short string for key; non-alphabetic letters, J</span>
<span class="sd">            and duplicated characters are ignored and then, if the</span>
<span class="sd">            length is less than 25 characters, it is padded with other</span>
<span class="sd">            letters of the alphabet (in alphabetical order).</span>

<span class="sd">        OUTPUT:</span>

<span class="sd">            ciphertext (all caps, no spaces)</span>

<span class="sd">        STEPS:</span>
<span class="sd">            0. Create the `5 \times 5` Polybius square ``S`` associated</span>
<span class="sd">               to ``key`` as follows:</span>

<span class="sd">                a) moving from left-to-right, top-to-bottom,</span>
<span class="sd">                   place the letters of the key into a `5 \times 5`</span>
<span class="sd">                   matrix,</span>
<span class="sd">                b) if the key has less than 25 letters, add the</span>
<span class="sd">                   letters of the alphabet not in the key until the</span>
<span class="sd">                   `5 \times 5` square is filled.</span>

<span class="sd">            1. Create a list ``P`` of pairs of numbers which are the</span>
<span class="sd">               coordinates in the Polybius square of the letters in</span>
<span class="sd">               ``msg``.</span>
<span class="sd">            2. Let ``L1`` be the list of all first coordinates of ``P``</span>
<span class="sd">               (length of ``L1 = n``), let ``L2`` be the list of all</span>
<span class="sd">               second coordinates of ``P`` (so the length of ``L2``</span>
<span class="sd">               is also ``n``).</span>
<span class="sd">            3. Let ``L`` be the concatenation of ``L1`` and ``L2``</span>
<span class="sd">               (length ``L = 2*n``), except that consecutive numbers</span>
<span class="sd">               are paired ``(L[2*i], L[2*i + 1])``. You can regard</span>
<span class="sd">               ``L`` as a list of pairs of length ``n``.</span>
<span class="sd">            4. Let ``C`` be the list of all letters which are of the</span>
<span class="sd">               form ``S[i, j]``, for all ``(i, j)`` in ``L``. As a</span>
<span class="sd">               string, this is the ciphertext of ``msg``.</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy.crypto.crypto import (</span>
<span class="sd">    ...     encipher_bifid5, decipher_bifid5)</span>

<span class="sd">    &quot;J&quot; will be omitted unless it is replaced with somthing else:</span>

<span class="sd">    &gt;&gt;&gt; round_trip = lambda m, k: \</span>
<span class="sd">    ...     decipher_bifid5(encipher_bifid5(m, k), k)</span>
<span class="sd">    &gt;&gt;&gt; key = &#39;a&#39;</span>
<span class="sd">    &gt;&gt;&gt; msg = &quot;JOSIE&quot;</span>
<span class="sd">    &gt;&gt;&gt; round_trip(msg, key)</span>
<span class="sd">    &#39;OSIE&#39;</span>
<span class="sd">    &gt;&gt;&gt; round_trip(msg.replace(&quot;J&quot;, &quot;I&quot;), key)</span>
<span class="sd">    &#39;IOSIE&#39;</span>
<span class="sd">    &gt;&gt;&gt; j = &quot;QIQ&quot;</span>
<span class="sd">    &gt;&gt;&gt; round_trip(msg.replace(&quot;J&quot;, j), key).replace(j, &quot;J&quot;)</span>
<span class="sd">    &#39;JOSIE&#39;</span>

<span class="sd">    See Also</span>
<span class="sd">    ========</span>
<span class="sd">    decipher_bifid5, encipher_bifid</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">msg</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">_prep</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">upper</span><span class="p">(),</span> <span class="n">key</span><span class="o">.</span><span class="n">upper</span><span class="p">(),</span> <span class="bp">None</span><span class="p">,</span> <span class="n">bifid5</span><span class="p">)</span>
    <span class="n">key</span> <span class="o">=</span> <span class="n">padded_key</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">bifid5</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">encipher_bifid</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span></div>


<div class="viewcode-block" id="decipher_bifid5"><a class="viewcode-back" href="../../../modules/crypto.html#sympy.crypto.crypto.decipher_bifid5">[docs]</a><span class="k">def</span> <span class="nf">decipher_bifid5</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    Return the Bifid cipher decryption of ``msg``.</span>

<span class="sd">    This is the version of the Bifid cipher that uses the `5 \times 5`</span>
<span class="sd">    Polybius square; the letter &quot;J&quot; is ignored unless a ``key`` of</span>
<span class="sd">    length 25 is used.</span>

<span class="sd">    INPUT:</span>

<span class="sd">        ``msg``: ciphertext string</span>

<span class="sd">        ``key``: short string for key; duplicated characters are</span>
<span class="sd">        ignored and if the length is less then 25 characters, it</span>
<span class="sd">        will be padded with other letters from the alphabet omitting</span>
<span class="sd">        &quot;J&quot;. Non-alphabetic characters are ignored.</span>

<span class="sd">    OUTPUT:</span>

<span class="sd">        plaintext from Bifid5 cipher (all caps, no spaces)</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy.crypto.crypto import encipher_bifid5, decipher_bifid5</span>
<span class="sd">    &gt;&gt;&gt; key = &quot;gold bug&quot;</span>
<span class="sd">    &gt;&gt;&gt; encipher_bifid5(&#39;meet me on friday&#39;, key)</span>
<span class="sd">    &#39;IEILEHFSTSFXEE&#39;</span>
<span class="sd">    &gt;&gt;&gt; encipher_bifid5(&#39;meet me on monday&#39;, key)</span>
<span class="sd">    &#39;IEILHHFSTSFQYE&#39;</span>
<span class="sd">    &gt;&gt;&gt; decipher_bifid5(_, key)</span>
<span class="sd">    &#39;MEETMEONMONDAY&#39;</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">msg</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">_prep</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">upper</span><span class="p">(),</span> <span class="n">key</span><span class="o">.</span><span class="n">upper</span><span class="p">(),</span> <span class="bp">None</span><span class="p">,</span> <span class="n">bifid5</span><span class="p">)</span>
    <span class="n">key</span> <span class="o">=</span> <span class="n">padded_key</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">bifid5</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">decipher_bifid</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span></div>


<div class="viewcode-block" id="bifid5_square"><a class="viewcode-back" href="../../../modules/crypto.html#sympy.crypto.crypto.bifid5_square">[docs]</a><span class="k">def</span> <span class="nf">bifid5_square</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    5x5 Polybius square.</span>

<span class="sd">    Produce the Polybius square for the `5 \times 5` Bifid cipher.</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy.crypto.crypto import bifid5_square</span>
<span class="sd">    &gt;&gt;&gt; bifid5_square(&quot;gold bug&quot;)</span>
<span class="sd">    Matrix([</span>
<span class="sd">    [G, O, L, D, B],</span>
<span class="sd">    [U, A, C, E, F],</span>
<span class="sd">    [H, I, K, M, N],</span>
<span class="sd">    [P, Q, R, S, T],</span>
<span class="sd">    [V, W, X, Y, Z]])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">key</span><span class="p">:</span>
        <span class="n">key</span> <span class="o">=</span> <span class="n">bifid5</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">_prep</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">.</span><span class="n">upper</span><span class="p">(),</span> <span class="bp">None</span><span class="p">,</span> <span class="n">bifid5</span><span class="p">)</span>
        <span class="n">key</span> <span class="o">=</span> <span class="n">padded_key</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">bifid5</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">bifid_square</span><span class="p">(</span><span class="n">key</span><span class="p">)</span></div>


<div class="viewcode-block" id="encipher_bifid6"><a class="viewcode-back" href="../../../modules/crypto.html#sympy.crypto.crypto.encipher_bifid6">[docs]</a><span class="k">def</span> <span class="nf">encipher_bifid6</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    Performs the Bifid cipher encryption on plaintext ``msg``, and</span>
<span class="sd">    returns the ciphertext.</span>

<span class="sd">    This is the version of the Bifid cipher that uses the `6 \times 6`</span>
<span class="sd">    Polybius square.</span>

<span class="sd">    INPUT:</span>

<span class="sd">        ``msg``: plaintext string (digits okay)</span>

<span class="sd">        ``key``: short string for key (digits okay). If ``key`` is</span>
<span class="sd">        less than 36 characters long, the square will be filled with</span>
<span class="sd">        letters A through Z and digits 0 through 9.</span>

<span class="sd">    OUTPUT:</span>

<span class="sd">        ciphertext from Bifid cipher (all caps, no spaces)</span>

<span class="sd">    See Also</span>
<span class="sd">    ========</span>
<span class="sd">    decipher_bifid6, encipher_bifid</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">msg</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">_prep</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">upper</span><span class="p">(),</span> <span class="n">key</span><span class="o">.</span><span class="n">upper</span><span class="p">(),</span> <span class="bp">None</span><span class="p">,</span> <span class="n">bifid6</span><span class="p">)</span>
    <span class="n">key</span> <span class="o">=</span> <span class="n">padded_key</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">bifid6</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">encipher_bifid</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span></div>


<div class="viewcode-block" id="decipher_bifid6"><a class="viewcode-back" href="../../../modules/crypto.html#sympy.crypto.crypto.decipher_bifid6">[docs]</a><span class="k">def</span> <span class="nf">decipher_bifid6</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    Performs the Bifid cipher decryption on ciphertext ``msg``, and</span>
<span class="sd">    returns the plaintext.</span>

<span class="sd">    This is the version of the Bifid cipher that uses the `6 \times 6`</span>
<span class="sd">    Polybius square.</span>

<span class="sd">    INPUT:</span>

<span class="sd">        ``msg``: ciphertext string (digits okay); converted to upper case</span>

<span class="sd">        ``key``: short string for key (digits okay). If ``key`` is</span>
<span class="sd">        less than 36 characters long, the square will be filled with</span>
<span class="sd">        letters A through Z and digits 0 through 9. All letters are</span>
<span class="sd">        converted to uppercase.</span>

<span class="sd">    OUTPUT:</span>

<span class="sd">        plaintext from Bifid cipher (all caps, no spaces)</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy.crypto.crypto import encipher_bifid6, decipher_bifid6</span>
<span class="sd">    &gt;&gt;&gt; key = &quot;gold bug&quot;</span>
<span class="sd">    &gt;&gt;&gt; encipher_bifid6(&#39;meet me on monday at 8am&#39;, key)</span>
<span class="sd">    &#39;KFKLJJHF5MMMKTFRGPL&#39;</span>
<span class="sd">    &gt;&gt;&gt; decipher_bifid6(_, key)</span>
<span class="sd">    &#39;MEETMEONMONDAYAT8AM&#39;</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">msg</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">_prep</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">upper</span><span class="p">(),</span> <span class="n">key</span><span class="o">.</span><span class="n">upper</span><span class="p">(),</span> <span class="bp">None</span><span class="p">,</span> <span class="n">bifid6</span><span class="p">)</span>
    <span class="n">key</span> <span class="o">=</span> <span class="n">padded_key</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">bifid6</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">decipher_bifid</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span></div>


<div class="viewcode-block" id="bifid6_square"><a class="viewcode-back" href="../../../modules/crypto.html#sympy.crypto.crypto.bifid6_square">[docs]</a><span class="k">def</span> <span class="nf">bifid6_square</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    6x6 Polybius square.</span>

<span class="sd">    Produces the Polybius square for the `6 \times 6` Bifid cipher.</span>
<span class="sd">    Assumes alphabet of symbols is &quot;A&quot;, ..., &quot;Z&quot;, &quot;0&quot;, ..., &quot;9&quot;.</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy.crypto.crypto import bifid6_square</span>
<span class="sd">    &gt;&gt;&gt; key = &quot;gold bug&quot;</span>
<span class="sd">    &gt;&gt;&gt; bifid6_square(key)</span>
<span class="sd">    Matrix([</span>
<span class="sd">    [G, O, L, D, B, U],</span>
<span class="sd">    [A, C, E, F, H, I],</span>
<span class="sd">    [J, K, M, N, P, Q],</span>
<span class="sd">    [R, S, T, V, W, X],</span>
<span class="sd">    [Y, Z, 0, 1, 2, 3],</span>
<span class="sd">    [4, 5, 6, 7, 8, 9]])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">key</span><span class="p">:</span>
        <span class="n">key</span> <span class="o">=</span> <span class="n">bifid6</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">_prep</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">.</span><span class="n">upper</span><span class="p">(),</span> <span class="bp">None</span><span class="p">,</span> <span class="n">bifid6</span><span class="p">)</span>
        <span class="n">key</span> <span class="o">=</span> <span class="n">padded_key</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">bifid6</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">bifid_square</span><span class="p">(</span><span class="n">key</span><span class="p">)</span></div>


<span class="c1">#################### RSA  #############################</span>


<div class="viewcode-block" id="rsa_public_key"><a class="viewcode-back" href="../../../modules/crypto.html#sympy.crypto.crypto.rsa_public_key">[docs]</a><span class="k">def</span> <span class="nf">rsa_public_key</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">e</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    Return the RSA *public key* pair, `(n, e)`, where `n`</span>
<span class="sd">    is a product of two primes and `e` is relatively</span>
<span class="sd">    prime (coprime) to the Euler totient `\phi(n)`. False</span>
<span class="sd">    is returned if any assumption is violated.</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy.crypto.crypto import rsa_public_key</span>
<span class="sd">    &gt;&gt;&gt; p, q, e = 3, 5, 7</span>
<span class="sd">    &gt;&gt;&gt; rsa_public_key(p, q, e)</span>
<span class="sd">    (15, 7)</span>
<span class="sd">    &gt;&gt;&gt; rsa_public_key(p, q, 30)</span>
<span class="sd">    False</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">p</span><span class="o">*</span><span class="n">q</span>
    <span class="k">if</span> <span class="n">isprime</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="ow">and</span> <span class="n">isprime</span><span class="p">(</span><span class="n">q</span><span class="p">):</span>
        <span class="n">phi</span> <span class="o">=</span> <span class="n">totient</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">gcd</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">phi</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">n</span><span class="p">,</span> <span class="n">e</span>
    <span class="k">return</span> <span class="bp">False</span></div>


<div class="viewcode-block" id="rsa_private_key"><a class="viewcode-back" href="../../../modules/crypto.html#sympy.crypto.crypto.rsa_private_key">[docs]</a><span class="k">def</span> <span class="nf">rsa_private_key</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">e</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    Return the RSA *private key*, `(n,d)`, where `n`</span>
<span class="sd">    is a product of two primes and `d` is the inverse of</span>
<span class="sd">    `e` (mod `\phi(n)`). False is returned if any assumption</span>
<span class="sd">    is violated.</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy.crypto.crypto import rsa_private_key</span>
<span class="sd">    &gt;&gt;&gt; p, q, e = 3, 5, 7</span>
<span class="sd">    &gt;&gt;&gt; rsa_private_key(p, q, e)</span>
<span class="sd">    (15, 7)</span>
<span class="sd">    &gt;&gt;&gt; rsa_private_key(p, q, 30)</span>
<span class="sd">    False</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">p</span><span class="o">*</span><span class="n">q</span>
    <span class="k">if</span> <span class="n">isprime</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="ow">and</span> <span class="n">isprime</span><span class="p">(</span><span class="n">q</span><span class="p">):</span>
        <span class="n">phi</span> <span class="o">=</span> <span class="n">totient</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">gcd</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">phi</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">d</span> <span class="o">=</span> <span class="n">mod_inverse</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">phi</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">n</span><span class="p">,</span> <span class="n">d</span>
    <span class="k">return</span> <span class="bp">False</span></div>


<div class="viewcode-block" id="encipher_rsa"><a class="viewcode-back" href="../../../modules/crypto.html#sympy.crypto.crypto.encipher_rsa">[docs]</a><span class="k">def</span> <span class="nf">encipher_rsa</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return encryption of ``i`` by computing `i^e` (mod `n`),</span>
<span class="sd">    where ``key`` is the public key `(n, e)`.</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy.crypto.crypto import encipher_rsa, rsa_public_key</span>
<span class="sd">    &gt;&gt;&gt; p, q, e = 3, 5, 7</span>
<span class="sd">    &gt;&gt;&gt; puk = rsa_public_key(p, q, e)</span>
<span class="sd">    &gt;&gt;&gt; msg = 12</span>
<span class="sd">    &gt;&gt;&gt; encipher_rsa(msg, puk)</span>
<span class="sd">    3</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">n</span><span class="p">,</span> <span class="n">e</span> <span class="o">=</span> <span class="n">key</span>
    <span class="k">return</span> <span class="nb">pow</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span></div>


<div class="viewcode-block" id="decipher_rsa"><a class="viewcode-back" href="../../../modules/crypto.html#sympy.crypto.crypto.decipher_rsa">[docs]</a><span class="k">def</span> <span class="nf">decipher_rsa</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return decyption of ``i`` by computing `i^d` (mod `n`),</span>
<span class="sd">    where ``key`` is the private key `(n, d)`.</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy.crypto.crypto import decipher_rsa, rsa_private_key</span>
<span class="sd">    &gt;&gt;&gt; p, q, e = 3, 5, 7</span>
<span class="sd">    &gt;&gt;&gt; prk = rsa_private_key(p, q, e)</span>
<span class="sd">    &gt;&gt;&gt; msg = 3</span>
<span class="sd">    &gt;&gt;&gt; decipher_rsa(msg, prk)</span>
<span class="sd">    12</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">n</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="n">key</span>
    <span class="k">return</span> <span class="nb">pow</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span></div>


<span class="c1">#################### kid krypto (kid RSA) #############################</span>


<div class="viewcode-block" id="kid_rsa_public_key"><a class="viewcode-back" href="../../../modules/crypto.html#sympy.crypto.crypto.kid_rsa_public_key">[docs]</a><span class="k">def</span> <span class="nf">kid_rsa_public_key</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    Kid RSA is a version of RSA useful to teach grade school children</span>
<span class="sd">    since it does not involve exponentiation.</span>

<span class="sd">    Alice wants to talk to Bob. Bob generates keys as follows.</span>
<span class="sd">    Key generation:</span>

<span class="sd">    * Select positive integers `a, b, A, B` at random.</span>
<span class="sd">    * Compute `M = a b - 1`, `e = A M + a`, `d = B M + b`,</span>
<span class="sd">      `n = (e d - 1)//M`.</span>
<span class="sd">    * The *public key* is `(n, e)`. Bob sends these to Alice.</span>
<span class="sd">    * The *private key* is `(n, d)`, which Bob keeps secret.</span>

<span class="sd">    Encryption: If `p` is the plaintext message then the</span>
<span class="sd">    ciphertext is `c = p e \pmod n`.</span>

<span class="sd">    Decryption: If `c` is the ciphertext message then the</span>
<span class="sd">    plaintext is `p = c d \pmod n`.</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy.crypto.crypto import kid_rsa_public_key</span>
<span class="sd">    &gt;&gt;&gt; a, b, A, B = 3, 4, 5, 6</span>
<span class="sd">    &gt;&gt;&gt; kid_rsa_public_key(a, b, A, B)</span>
<span class="sd">    (369, 58)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">M</span> <span class="o">=</span> <span class="n">a</span><span class="o">*</span><span class="n">b</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="n">e</span> <span class="o">=</span> <span class="n">A</span><span class="o">*</span><span class="n">M</span> <span class="o">+</span> <span class="n">a</span>
    <span class="n">d</span> <span class="o">=</span> <span class="n">B</span><span class="o">*</span><span class="n">M</span> <span class="o">+</span> <span class="n">b</span>
    <span class="n">n</span> <span class="o">=</span> <span class="p">(</span><span class="n">e</span><span class="o">*</span><span class="n">d</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="o">//</span><span class="n">M</span>
    <span class="k">return</span> <span class="n">n</span><span class="p">,</span> <span class="n">e</span></div>


<div class="viewcode-block" id="kid_rsa_private_key"><a class="viewcode-back" href="../../../modules/crypto.html#sympy.crypto.crypto.kid_rsa_private_key">[docs]</a><span class="k">def</span> <span class="nf">kid_rsa_private_key</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute `M = a b - 1`, `e = A M + a`, `d = B M + b`,</span>
<span class="sd">    `n = (e d - 1) / M`. The *private key* is `d`, which Bob</span>
<span class="sd">    keeps secret.</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy.crypto.crypto import kid_rsa_private_key</span>
<span class="sd">    &gt;&gt;&gt; a, b, A, B = 3, 4, 5, 6</span>
<span class="sd">    &gt;&gt;&gt; kid_rsa_private_key(a, b, A, B)</span>
<span class="sd">    (369, 70)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">M</span> <span class="o">=</span> <span class="n">a</span><span class="o">*</span><span class="n">b</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="n">e</span> <span class="o">=</span> <span class="n">A</span><span class="o">*</span><span class="n">M</span> <span class="o">+</span> <span class="n">a</span>
    <span class="n">d</span> <span class="o">=</span> <span class="n">B</span><span class="o">*</span><span class="n">M</span> <span class="o">+</span> <span class="n">b</span>
    <span class="n">n</span> <span class="o">=</span> <span class="p">(</span><span class="n">e</span><span class="o">*</span><span class="n">d</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="o">//</span><span class="n">M</span>
    <span class="k">return</span> <span class="n">n</span><span class="p">,</span> <span class="n">d</span></div>


<div class="viewcode-block" id="encipher_kid_rsa"><a class="viewcode-back" href="../../../modules/crypto.html#sympy.crypto.crypto.encipher_kid_rsa">[docs]</a><span class="k">def</span> <span class="nf">encipher_kid_rsa</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Here ``msg`` is the plaintext and ``key`` is the public key.</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy.crypto.crypto import (</span>
<span class="sd">    ...     encipher_kid_rsa, kid_rsa_public_key)</span>
<span class="sd">    &gt;&gt;&gt; msg = 200</span>
<span class="sd">    &gt;&gt;&gt; a, b, A, B = 3, 4, 5, 6</span>
<span class="sd">    &gt;&gt;&gt; key = kid_rsa_public_key(a, b, A, B)</span>
<span class="sd">    &gt;&gt;&gt; encipher_kid_rsa(msg, key)</span>
<span class="sd">    161</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">n</span><span class="p">,</span> <span class="n">e</span> <span class="o">=</span> <span class="n">key</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">msg</span><span class="o">*</span><span class="n">e</span><span class="p">)</span> <span class="o">%</span> <span class="n">n</span></div>


<div class="viewcode-block" id="decipher_kid_rsa"><a class="viewcode-back" href="../../../modules/crypto.html#sympy.crypto.crypto.decipher_kid_rsa">[docs]</a><span class="k">def</span> <span class="nf">decipher_kid_rsa</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Here ``msg`` is the plaintext and ``key`` is the private key.</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy.crypto.crypto import (</span>
<span class="sd">    ...     kid_rsa_public_key, kid_rsa_private_key,</span>
<span class="sd">    ...     decipher_kid_rsa, encipher_kid_rsa)</span>
<span class="sd">    &gt;&gt;&gt; a, b, A, B = 3, 4, 5, 6</span>
<span class="sd">    &gt;&gt;&gt; d = kid_rsa_private_key(a, b, A, B)</span>
<span class="sd">    &gt;&gt;&gt; msg = 200</span>
<span class="sd">    &gt;&gt;&gt; pub = kid_rsa_public_key(a, b, A, B)</span>
<span class="sd">    &gt;&gt;&gt; pri = kid_rsa_private_key(a, b, A, B)</span>
<span class="sd">    &gt;&gt;&gt; ct = encipher_kid_rsa(msg, pub)</span>
<span class="sd">    &gt;&gt;&gt; decipher_kid_rsa(ct, pri)</span>
<span class="sd">    200</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">n</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="n">key</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">msg</span><span class="o">*</span><span class="n">d</span><span class="p">)</span> <span class="o">%</span> <span class="n">n</span></div>


<span class="c1">#################### Morse Code ######################################</span>

<span class="n">morse_char</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s2">&quot;.-&quot;</span><span class="p">:</span> <span class="s2">&quot;A&quot;</span><span class="p">,</span> <span class="s2">&quot;-...&quot;</span><span class="p">:</span> <span class="s2">&quot;B&quot;</span><span class="p">,</span>
    <span class="s2">&quot;-.-.&quot;</span><span class="p">:</span> <span class="s2">&quot;C&quot;</span><span class="p">,</span> <span class="s2">&quot;-..&quot;</span><span class="p">:</span> <span class="s2">&quot;D&quot;</span><span class="p">,</span>
    <span class="s2">&quot;.&quot;</span><span class="p">:</span> <span class="s2">&quot;E&quot;</span><span class="p">,</span> <span class="s2">&quot;..-.&quot;</span><span class="p">:</span> <span class="s2">&quot;F&quot;</span><span class="p">,</span>
    <span class="s2">&quot;--.&quot;</span><span class="p">:</span> <span class="s2">&quot;G&quot;</span><span class="p">,</span> <span class="s2">&quot;....&quot;</span><span class="p">:</span> <span class="s2">&quot;H&quot;</span><span class="p">,</span>
    <span class="s2">&quot;..&quot;</span><span class="p">:</span> <span class="s2">&quot;I&quot;</span><span class="p">,</span> <span class="s2">&quot;.---&quot;</span><span class="p">:</span> <span class="s2">&quot;J&quot;</span><span class="p">,</span>
    <span class="s2">&quot;-.-&quot;</span><span class="p">:</span> <span class="s2">&quot;K&quot;</span><span class="p">,</span> <span class="s2">&quot;.-..&quot;</span><span class="p">:</span> <span class="s2">&quot;L&quot;</span><span class="p">,</span>
    <span class="s2">&quot;--&quot;</span><span class="p">:</span> <span class="s2">&quot;M&quot;</span><span class="p">,</span> <span class="s2">&quot;-.&quot;</span><span class="p">:</span> <span class="s2">&quot;N&quot;</span><span class="p">,</span>
    <span class="s2">&quot;---&quot;</span><span class="p">:</span> <span class="s2">&quot;O&quot;</span><span class="p">,</span> <span class="s2">&quot;.--.&quot;</span><span class="p">:</span> <span class="s2">&quot;P&quot;</span><span class="p">,</span>
    <span class="s2">&quot;--.-&quot;</span><span class="p">:</span> <span class="s2">&quot;Q&quot;</span><span class="p">,</span> <span class="s2">&quot;.-.&quot;</span><span class="p">:</span> <span class="s2">&quot;R&quot;</span><span class="p">,</span>
    <span class="s2">&quot;...&quot;</span><span class="p">:</span> <span class="s2">&quot;S&quot;</span><span class="p">,</span> <span class="s2">&quot;-&quot;</span><span class="p">:</span> <span class="s2">&quot;T&quot;</span><span class="p">,</span>
    <span class="s2">&quot;..-&quot;</span><span class="p">:</span> <span class="s2">&quot;U&quot;</span><span class="p">,</span> <span class="s2">&quot;...-&quot;</span><span class="p">:</span> <span class="s2">&quot;V&quot;</span><span class="p">,</span>
    <span class="s2">&quot;.--&quot;</span><span class="p">:</span> <span class="s2">&quot;W&quot;</span><span class="p">,</span> <span class="s2">&quot;-..-&quot;</span><span class="p">:</span> <span class="s2">&quot;X&quot;</span><span class="p">,</span>
    <span class="s2">&quot;-.--&quot;</span><span class="p">:</span> <span class="s2">&quot;Y&quot;</span><span class="p">,</span> <span class="s2">&quot;--..&quot;</span><span class="p">:</span> <span class="s2">&quot;Z&quot;</span><span class="p">,</span>
    <span class="s2">&quot;-----&quot;</span><span class="p">:</span> <span class="s2">&quot;0&quot;</span><span class="p">,</span> <span class="s2">&quot;----&quot;</span><span class="p">:</span> <span class="s2">&quot;1&quot;</span><span class="p">,</span>
    <span class="s2">&quot;..---&quot;</span><span class="p">:</span> <span class="s2">&quot;2&quot;</span><span class="p">,</span> <span class="s2">&quot;...--&quot;</span><span class="p">:</span> <span class="s2">&quot;3&quot;</span><span class="p">,</span>
    <span class="s2">&quot;....-&quot;</span><span class="p">:</span> <span class="s2">&quot;4&quot;</span><span class="p">,</span> <span class="s2">&quot;.....&quot;</span><span class="p">:</span> <span class="s2">&quot;5&quot;</span><span class="p">,</span>
    <span class="s2">&quot;-....&quot;</span><span class="p">:</span> <span class="s2">&quot;6&quot;</span><span class="p">,</span> <span class="s2">&quot;--...&quot;</span><span class="p">:</span> <span class="s2">&quot;7&quot;</span><span class="p">,</span>
    <span class="s2">&quot;---..&quot;</span><span class="p">:</span> <span class="s2">&quot;8&quot;</span><span class="p">,</span> <span class="s2">&quot;----.&quot;</span><span class="p">:</span> <span class="s2">&quot;9&quot;</span><span class="p">,</span>
    <span class="s2">&quot;.-.-.-&quot;</span><span class="p">:</span> <span class="s2">&quot;.&quot;</span><span class="p">,</span> <span class="s2">&quot;--..--&quot;</span><span class="p">:</span> <span class="s2">&quot;,&quot;</span><span class="p">,</span>
    <span class="s2">&quot;---...&quot;</span><span class="p">:</span> <span class="s2">&quot;:&quot;</span><span class="p">,</span> <span class="s2">&quot;-.-.-.&quot;</span><span class="p">:</span> <span class="s2">&quot;;&quot;</span><span class="p">,</span>
    <span class="s2">&quot;..--..&quot;</span><span class="p">:</span> <span class="s2">&quot;?&quot;</span><span class="p">,</span> <span class="s2">&quot;-...-&quot;</span><span class="p">:</span> <span class="s2">&quot;-&quot;</span><span class="p">,</span>
    <span class="s2">&quot;..--.-&quot;</span><span class="p">:</span> <span class="s2">&quot;_&quot;</span><span class="p">,</span> <span class="s2">&quot;-.--.&quot;</span><span class="p">:</span> <span class="s2">&quot;(&quot;</span><span class="p">,</span>
    <span class="s2">&quot;-.--.-&quot;</span><span class="p">:</span> <span class="s2">&quot;)&quot;</span><span class="p">,</span> <span class="s2">&quot;.----.&quot;</span><span class="p">:</span> <span class="s2">&quot;&#39;&quot;</span><span class="p">,</span>
    <span class="s2">&quot;-...-&quot;</span><span class="p">:</span> <span class="s2">&quot;=&quot;</span><span class="p">,</span> <span class="s2">&quot;.-.-.&quot;</span><span class="p">:</span> <span class="s2">&quot;+&quot;</span><span class="p">,</span>
    <span class="s2">&quot;-..-.&quot;</span><span class="p">:</span> <span class="s2">&quot;/&quot;</span><span class="p">,</span> <span class="s2">&quot;.--.-.&quot;</span><span class="p">:</span> <span class="s2">&quot;@&quot;</span><span class="p">,</span>
    <span class="s2">&quot;...-..-&quot;</span><span class="p">:</span> <span class="s2">&quot;$&quot;</span><span class="p">,</span> <span class="s2">&quot;-.-.--&quot;</span><span class="p">:</span> <span class="s2">&quot;!&quot;</span><span class="p">}</span>
<span class="n">char_morse</span> <span class="o">=</span> <span class="p">{</span><span class="n">v</span><span class="p">:</span> <span class="n">k</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">morse_char</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>


<div class="viewcode-block" id="encode_morse"><a class="viewcode-back" href="../../../modules/crypto.html#sympy.crypto.crypto.encode_morse">[docs]</a><span class="k">def</span> <span class="nf">encode_morse</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s1">&#39;|&#39;</span><span class="p">,</span> <span class="n">mapping</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Encodes a plaintext into popular Morse Code with letters</span>
<span class="sd">    separated by `sep` and words by a double `sep`.</span>

<span class="sd">    References</span>
<span class="sd">    ==========</span>

<span class="sd">    .. [1] http://en.wikipedia.org/wiki/Morse_code</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy.crypto.crypto import encode_morse</span>
<span class="sd">    &gt;&gt;&gt; msg = &#39;ATTACK RIGHT FLANK&#39;</span>
<span class="sd">    &gt;&gt;&gt; encode_morse(msg)</span>
<span class="sd">    &#39;.-|-|-|.-|-.-.|-.-||.-.|..|--.|....|-||..-.|.-..|.-|-.|-.-&#39;</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">mapping</span> <span class="o">=</span> <span class="n">mapping</span> <span class="ow">or</span> <span class="n">char_morse</span>
    <span class="k">assert</span> <span class="n">sep</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">mapping</span>
    <span class="n">word_sep</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">sep</span>
    <span class="n">mapping</span><span class="p">[</span><span class="s2">&quot; &quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">word_sep</span>
    <span class="n">suffix</span> <span class="o">=</span> <span class="n">msg</span> <span class="ow">and</span> <span class="n">msg</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="n">whitespace</span>

    <span class="c1"># normalize whitespace</span>
    <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39; &#39;</span> <span class="k">if</span> <span class="n">word_sep</span> <span class="k">else</span> <span class="s1">&#39;&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">split</span><span class="p">())</span>
    <span class="c1"># omit unmapped chars</span>
    <span class="n">chars</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">split</span><span class="p">()))</span>
    <span class="n">ok</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">mapping</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
    <span class="n">msg</span> <span class="o">=</span> <span class="n">translate</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">chars</span> <span class="o">-</span> <span class="n">ok</span><span class="p">))</span>

    <span class="n">morsestring</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">words</span> <span class="o">=</span> <span class="n">msg</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">word</span> <span class="ow">in</span> <span class="n">words</span><span class="p">:</span>
        <span class="n">morseword</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">letter</span> <span class="ow">in</span> <span class="n">word</span><span class="p">:</span>
            <span class="n">morseletter</span> <span class="o">=</span> <span class="n">mapping</span><span class="p">[</span><span class="n">letter</span><span class="p">]</span>
            <span class="n">morseword</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">morseletter</span><span class="p">)</span>

        <span class="n">word</span> <span class="o">=</span> <span class="n">sep</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">morseword</span><span class="p">)</span>
        <span class="n">morsestring</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">word</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">word_sep</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">morsestring</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">word_sep</span> <span class="k">if</span> <span class="n">suffix</span> <span class="k">else</span> <span class="s1">&#39;&#39;</span><span class="p">)</span></div>


<div class="viewcode-block" id="decode_morse"><a class="viewcode-back" href="../../../modules/crypto.html#sympy.crypto.crypto.decode_morse">[docs]</a><span class="k">def</span> <span class="nf">decode_morse</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s1">&#39;|&#39;</span><span class="p">,</span> <span class="n">mapping</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Decodes a Morse Code with letters separated by `sep`</span>
<span class="sd">    (default is &#39;|&#39;) and words by `word_sep` (default is &#39;||)</span>
<span class="sd">    into plaintext.</span>

<span class="sd">    References</span>
<span class="sd">    ==========</span>

<span class="sd">    .. [1] http://en.wikipedia.org/wiki/Morse_code</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy.crypto.crypto import decode_morse</span>
<span class="sd">    &gt;&gt;&gt; mc = &#39;--|---|...-|.||.|.-|...|-&#39;</span>
<span class="sd">    &gt;&gt;&gt; decode_morse(mc)</span>
<span class="sd">    &#39;MOVE EAST&#39;</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">mapping</span> <span class="o">=</span> <span class="n">mapping</span> <span class="ow">or</span> <span class="n">morse_char</span>
    <span class="n">word_sep</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">sep</span>
    <span class="n">characterstring</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">words</span> <span class="o">=</span> <span class="n">msg</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="n">word_sep</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">word_sep</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">word</span> <span class="ow">in</span> <span class="n">words</span><span class="p">:</span>
        <span class="n">letters</span> <span class="o">=</span> <span class="n">word</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">sep</span><span class="p">)</span>
        <span class="n">chars</span> <span class="o">=</span> <span class="p">[</span><span class="n">mapping</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">letters</span><span class="p">]</span>
        <span class="n">word</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">chars</span><span class="p">)</span>
        <span class="n">characterstring</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">word</span><span class="p">)</span>
    <span class="n">rv</span> <span class="o">=</span> <span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">characterstring</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">rv</span></div>


<span class="c1">#################### LFSRs  ##########################################</span>


<div class="viewcode-block" id="lfsr_sequence"><a class="viewcode-back" href="../../../modules/crypto.html#sympy.crypto.crypto.lfsr_sequence">[docs]</a><span class="k">def</span> <span class="nf">lfsr_sequence</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">fill</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    This function creates an lfsr sequence.</span>

<span class="sd">    INPUT:</span>

<span class="sd">        ``key``: a list of finite field elements,</span>
<span class="sd">            `[c_0, c_1, \ldots, c_k].`</span>

<span class="sd">        ``fill``: the list of the initial terms of the lfsr</span>
<span class="sd">            sequence, `[x_0, x_1, \ldots, x_k].`</span>

<span class="sd">        ``n``: number of terms of the sequence that the</span>
<span class="sd">            function returns.</span>

<span class="sd">    OUTPUT:</span>

<span class="sd">        The lfsr sequence defined by</span>
<span class="sd">        `x_{n+1} = c_k x_n + \ldots + c_0 x_{n-k}`, for</span>
<span class="sd">        `n \leq k`.</span>

<span class="sd">    Notes</span>
<span class="sd">    =====</span>

<span class="sd">    S. Golomb [G]_ gives a list of three statistical properties a</span>
<span class="sd">    sequence of numbers `a = \{a_n\}_{n=1}^\infty`,</span>
<span class="sd">    `a_n \in \{0,1\}`, should display to be considered</span>
<span class="sd">    &quot;random&quot;. Define the autocorrelation of `a` to be</span>

<span class="sd">    .. math::</span>

<span class="sd">        C(k) = C(k,a) = \lim_{N\rightarrow \infty} {1\over N}\sum_{n=1}^N (-1)^{a_n + a_{n+k}}.</span>

<span class="sd">    In the case where `a` is periodic with period</span>
<span class="sd">    `P` then this reduces to</span>

<span class="sd">    .. math::</span>

<span class="sd">        C(k) = {1\over P}\sum_{n=1}^P (-1)^{a_n + a_{n+k}}.</span>

<span class="sd">    Assume `a` is periodic with period `P`.</span>

<span class="sd">    - balance:</span>

<span class="sd">      .. math::</span>

<span class="sd">        \left|\sum_{n=1}^P(-1)^{a_n}\right| \leq 1.</span>

<span class="sd">    - low autocorrelation:</span>

<span class="sd">       .. math::</span>

<span class="sd">         C(k) = \left\{ \begin{array}{cc} 1,&amp; k = 0,\\ \epsilon, &amp; k \ne 0. \end{array} \right.</span>

<span class="sd">      (For sequences satisfying these first two properties, it is known</span>
<span class="sd">      that `\epsilon = -1/P` must hold.)</span>

<span class="sd">    - proportional runs property: In each period, half the runs have</span>
<span class="sd">      length `1`, one-fourth have length `2`, etc.</span>
<span class="sd">      Moreover, there are as many runs of `1`&#39;s as there are of</span>
<span class="sd">      `0`&#39;s.</span>

<span class="sd">    References</span>
<span class="sd">    ==========</span>

<span class="sd">    .. [G] Solomon Golomb, Shift register sequences, Aegean Park Press,</span>
<span class="sd">       Laguna Hills, Ca, 1967</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy.crypto.crypto import lfsr_sequence</span>
<span class="sd">    &gt;&gt;&gt; from sympy.polys.domains import FF</span>
<span class="sd">    &gt;&gt;&gt; F = FF(2)</span>
<span class="sd">    &gt;&gt;&gt; fill = [F(1), F(1), F(0), F(1)]</span>
<span class="sd">    &gt;&gt;&gt; key = [F(1), F(0), F(0), F(1)]</span>
<span class="sd">    &gt;&gt;&gt; lfsr_sequence(key, fill, 10)</span>
<span class="sd">    [1 mod 2, 1 mod 2, 0 mod 2, 1 mod 2, 0 mod 2,</span>
<span class="sd">    1 mod 2, 1 mod 2, 0 mod 2, 0 mod 2, 1 mod 2]</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;key must be a list&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fill</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;fill must be a list&quot;</span><span class="p">)</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">key</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">mod</span>
    <span class="n">F</span> <span class="o">=</span> <span class="n">FF</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">fill</span>
    <span class="n">k</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">fill</span><span class="p">)</span>
    <span class="n">L</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="n">s0</span> <span class="o">=</span> <span class="n">s</span><span class="p">[:]</span>
        <span class="n">L</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="n">k</span><span class="p">]</span>
        <span class="n">x</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span><span class="nb">int</span><span class="p">(</span><span class="n">key</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">s0</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k</span><span class="p">)])</span>
        <span class="n">s</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">F</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">L</span>       <span class="c1"># use [x.to_int() for x in L] for int version</span></div>


<div class="viewcode-block" id="lfsr_autocorrelation"><a class="viewcode-back" href="../../../modules/crypto.html#sympy.crypto.crypto.lfsr_autocorrelation">[docs]</a><span class="k">def</span> <span class="nf">lfsr_autocorrelation</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function computes the LFSR autocorrelation function.</span>

<span class="sd">    INPUT:</span>

<span class="sd">        ``L``: is a periodic sequence of elements of `GF(2)`.</span>
<span class="sd">        ``L`` must have length larger than ``P``.</span>

<span class="sd">        ``P``: the period of ``L``</span>

<span class="sd">        ``k``: an integer (`0 &lt; k &lt; p`)</span>

<span class="sd">    OUTPUT:</span>

<span class="sd">        the ``k``-th value of the autocorrelation of the LFSR ``L``</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy.crypto.crypto import (</span>
<span class="sd">    ...     lfsr_sequence, lfsr_autocorrelation)</span>
<span class="sd">    &gt;&gt;&gt; from sympy.polys.domains import FF</span>
<span class="sd">    &gt;&gt;&gt; F = FF(2)</span>
<span class="sd">    &gt;&gt;&gt; fill = [F(1), F(1), F(0), F(1)]</span>
<span class="sd">    &gt;&gt;&gt; key = [F(1), F(0), F(0), F(1)]</span>
<span class="sd">    &gt;&gt;&gt; s = lfsr_sequence(key, fill, 20)</span>
<span class="sd">    &gt;&gt;&gt; lfsr_autocorrelation(s, 15, 7)</span>
<span class="sd">    -1/15</span>
<span class="sd">    &gt;&gt;&gt; lfsr_autocorrelation(s, 15, 0)</span>
<span class="sd">    1</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;L (=</span><span class="si">%s</span><span class="s2">) must be a list&quot;</span> <span class="o">%</span> <span class="n">L</span><span class="p">)</span>
    <span class="n">P</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">P</span><span class="p">)</span>
    <span class="n">k</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
    <span class="n">L0</span> <span class="o">=</span> <span class="n">L</span><span class="p">[:</span><span class="n">P</span><span class="p">]</span>     <span class="c1"># slices makes a copy</span>
    <span class="n">L1</span> <span class="o">=</span> <span class="n">L0</span> <span class="o">+</span> <span class="n">L0</span><span class="p">[:</span><span class="n">k</span><span class="p">]</span>
    <span class="n">L2</span> <span class="o">=</span> <span class="p">[(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="n">L1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">to_int</span><span class="p">()</span> <span class="o">+</span> <span class="n">L1</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">to_int</span><span class="p">())</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">P</span><span class="p">)]</span>
    <span class="n">tot</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">L2</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">Rational</span><span class="p">(</span><span class="n">tot</span><span class="p">,</span> <span class="n">P</span><span class="p">)</span></div>


<div class="viewcode-block" id="lfsr_connection_polynomial"><a class="viewcode-back" href="../../../modules/crypto.html#sympy.crypto.crypto.lfsr_connection_polynomial">[docs]</a><span class="k">def</span> <span class="nf">lfsr_connection_polynomial</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function computes the LFSR connection polynomial.</span>

<span class="sd">    INPUT:</span>

<span class="sd">        ``s``: a sequence of elements of even length, with entries in</span>
<span class="sd">        a finite field</span>

<span class="sd">    OUTPUT:</span>

<span class="sd">        ``C(x)``: the connection polynomial of a minimal LFSR yielding</span>
<span class="sd">        ``s``.</span>

<span class="sd">    This implements the algorithm in section 3 of J. L. Massey&#39;s</span>
<span class="sd">    article [M]_.</span>

<span class="sd">    References</span>
<span class="sd">    ==========</span>

<span class="sd">    .. [M] James L. Massey, &quot;Shift-Register Synthesis and BCH Decoding.&quot;</span>
<span class="sd">        IEEE Trans. on Information Theory, vol. 15(1), pp. 122-127,</span>
<span class="sd">        Jan 1969.</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy.crypto.crypto import (</span>
<span class="sd">    ...     lfsr_sequence, lfsr_connection_polynomial)</span>
<span class="sd">    &gt;&gt;&gt; from sympy.polys.domains import FF</span>
<span class="sd">    &gt;&gt;&gt; F = FF(2)</span>
<span class="sd">    &gt;&gt;&gt; fill = [F(1), F(1), F(0), F(1)]</span>
<span class="sd">    &gt;&gt;&gt; key = [F(1), F(0), F(0), F(1)]</span>
<span class="sd">    &gt;&gt;&gt; s = lfsr_sequence(key, fill, 20)</span>
<span class="sd">    &gt;&gt;&gt; lfsr_connection_polynomial(s)</span>
<span class="sd">    x**4 + x + 1</span>
<span class="sd">    &gt;&gt;&gt; fill = [F(1), F(0), F(0), F(1)]</span>
<span class="sd">    &gt;&gt;&gt; key = [F(1), F(1), F(0), F(1)]</span>
<span class="sd">    &gt;&gt;&gt; s = lfsr_sequence(key, fill, 20)</span>
<span class="sd">    &gt;&gt;&gt; lfsr_connection_polynomial(s)</span>
<span class="sd">    x**3 + 1</span>
<span class="sd">    &gt;&gt;&gt; fill = [F(1), F(0), F(1)]</span>
<span class="sd">    &gt;&gt;&gt; key = [F(1), F(1), F(0)]</span>
<span class="sd">    &gt;&gt;&gt; s = lfsr_sequence(key, fill, 20)</span>
<span class="sd">    &gt;&gt;&gt; lfsr_connection_polynomial(s)</span>
<span class="sd">    x**3 + x**2 + 1</span>
<span class="sd">    &gt;&gt;&gt; fill = [F(1), F(0), F(1)]</span>
<span class="sd">    &gt;&gt;&gt; key = [F(1), F(0), F(1)]</span>
<span class="sd">    &gt;&gt;&gt; s = lfsr_sequence(key, fill, 20)</span>
<span class="sd">    &gt;&gt;&gt; lfsr_connection_polynomial(s)</span>
<span class="sd">    x**3 + x + 1</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Initialization:</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">mod</span>
    <span class="n">F</span> <span class="o">=</span> <span class="n">FF</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">)</span>
    <span class="n">C</span> <span class="o">=</span> <span class="mi">1</span><span class="o">*</span><span class="n">x</span><span class="o">**</span><span class="mi">0</span>
    <span class="n">B</span> <span class="o">=</span> <span class="mi">1</span><span class="o">*</span><span class="n">x</span><span class="o">**</span><span class="mi">0</span>
    <span class="n">m</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">b</span> <span class="o">=</span> <span class="mi">1</span><span class="o">*</span><span class="n">x</span><span class="o">**</span><span class="mi">0</span>
    <span class="n">L</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">N</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">N</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">L</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">dC</span> <span class="o">=</span> <span class="n">Poly</span><span class="p">(</span><span class="n">C</span><span class="p">)</span><span class="o">.</span><span class="n">degree</span><span class="p">()</span>
            <span class="n">r</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">L</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dC</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">coeffsC</span> <span class="o">=</span> <span class="p">[</span><span class="n">C</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">)]</span> <span class="o">+</span> <span class="p">[</span><span class="n">C</span><span class="o">.</span><span class="n">coeff</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="n">i</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">dC</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>
            <span class="n">d</span> <span class="o">=</span> <span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">N</span><span class="p">]</span><span class="o">.</span><span class="n">to_int</span><span class="p">()</span> <span class="o">+</span> <span class="nb">sum</span><span class="p">([</span><span class="n">coeffsC</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">s</span><span class="p">[</span><span class="n">N</span> <span class="o">-</span> <span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">to_int</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">r</span><span class="p">)]))</span> <span class="o">%</span> <span class="n">p</span>
        <span class="k">if</span> <span class="n">L</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">d</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="n">N</span><span class="p">]</span><span class="o">.</span><span class="n">to_int</span><span class="p">()</span><span class="o">*</span><span class="n">x</span><span class="o">**</span><span class="mi">0</span>
        <span class="k">if</span> <span class="n">d</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">m</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">N</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">d</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="mi">2</span><span class="o">*</span><span class="n">L</span> <span class="o">&gt;</span> <span class="n">N</span><span class="p">:</span>
                <span class="n">C</span> <span class="o">=</span> <span class="p">(</span><span class="n">C</span> <span class="o">-</span> <span class="n">d</span><span class="o">*</span><span class="p">((</span><span class="n">b</span><span class="o">**</span><span class="p">(</span><span class="n">p</span> <span class="o">-</span> <span class="mi">2</span><span class="p">))</span> <span class="o">%</span> <span class="n">p</span><span class="p">)</span><span class="o">*</span><span class="n">x</span><span class="o">**</span><span class="n">m</span><span class="o">*</span><span class="n">B</span><span class="p">)</span><span class="o">.</span><span class="n">expand</span><span class="p">()</span>
                <span class="n">m</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">N</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">T</span> <span class="o">=</span> <span class="n">C</span>
                <span class="n">C</span> <span class="o">=</span> <span class="p">(</span><span class="n">C</span> <span class="o">-</span> <span class="n">d</span><span class="o">*</span><span class="p">((</span><span class="n">b</span><span class="o">**</span><span class="p">(</span><span class="n">p</span> <span class="o">-</span> <span class="mi">2</span><span class="p">))</span> <span class="o">%</span> <span class="n">p</span><span class="p">)</span><span class="o">*</span><span class="n">x</span><span class="o">**</span><span class="n">m</span><span class="o">*</span><span class="n">B</span><span class="p">)</span><span class="o">.</span><span class="n">expand</span><span class="p">()</span>
                <span class="n">L</span> <span class="o">=</span> <span class="n">N</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">L</span>
                <span class="n">m</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="n">b</span> <span class="o">=</span> <span class="n">d</span>
                <span class="n">B</span> <span class="o">=</span> <span class="n">T</span>
                <span class="n">N</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="n">dC</span> <span class="o">=</span> <span class="n">Poly</span><span class="p">(</span><span class="n">C</span><span class="p">)</span><span class="o">.</span><span class="n">degree</span><span class="p">()</span>
    <span class="n">coeffsC</span> <span class="o">=</span> <span class="p">[</span><span class="n">C</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">)]</span> <span class="o">+</span> <span class="p">[</span><span class="n">C</span><span class="o">.</span><span class="n">coeff</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">dC</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>
    <span class="k">return</span> <span class="nb">sum</span><span class="p">([</span><span class="n">coeffsC</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">%</span> <span class="n">p</span><span class="o">*</span><span class="n">x</span><span class="o">**</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dC</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">coeffsC</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">])</span></div>


<span class="c1">#################### ElGamal  #############################</span>


<div class="viewcode-block" id="elgamal_private_key"><a class="viewcode-back" href="../../../modules/crypto.html#sympy.crypto.crypto.elgamal_private_key">[docs]</a><span class="k">def</span> <span class="nf">elgamal_private_key</span><span class="p">(</span><span class="n">digit</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return three number tuple as private key.</span>

<span class="sd">    Elgamal encryption is based on the mathmatical problem</span>
<span class="sd">    called the Discrete Logarithm Problem (DLP). For example,</span>

<span class="sd">    `a^{b} \equiv c \pmod p`</span>

<span class="sd">    In general, if ``a`` and ``b`` are known, ``ct`` is easily</span>
<span class="sd">    calculated. If ``b`` is unknown, it is hard to use</span>
<span class="sd">    ``a`` and ``ct`` to get ``b``.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ==========</span>

<span class="sd">    digit : minimum number of binary digits for key</span>

<span class="sd">    Returns</span>
<span class="sd">    =======</span>

<span class="sd">    (p, r, d) : p = prime number, r = primitive root, d = random number</span>

<span class="sd">    Notes</span>
<span class="sd">    =====</span>

<span class="sd">    For testing purposes, the ``seed`` parameter may be set to control</span>
<span class="sd">    the output of this routine. See sympy.utilities.randtest._randrange.</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy.crypto.crypto import elgamal_private_key</span>
<span class="sd">    &gt;&gt;&gt; from sympy.ntheory import is_primitive_root, isprime</span>
<span class="sd">    &gt;&gt;&gt; a, b, _ = elgamal_private_key()</span>
<span class="sd">    &gt;&gt;&gt; isprime(a)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; is_primitive_root(b, a)</span>
<span class="sd">    True</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">randrange</span> <span class="o">=</span> <span class="n">_randrange</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">nextprime</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="n">digit</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">p</span><span class="p">,</span> <span class="n">primitive_root</span><span class="p">(</span><span class="n">p</span><span class="p">),</span> <span class="n">randrange</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span></div>


<div class="viewcode-block" id="elgamal_public_key"><a class="viewcode-back" href="../../../modules/crypto.html#sympy.crypto.crypto.elgamal_public_key">[docs]</a><span class="k">def</span> <span class="nf">elgamal_public_key</span><span class="p">(</span><span class="n">key</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return three number tuple as public key.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ==========</span>

<span class="sd">    key : Tuple (p, r, e)  generated by ``elgamal_private_key``</span>

<span class="sd">    Returns</span>
<span class="sd">    =======</span>
<span class="sd">    (p, r, e = r**d mod p) : d is a random number in private key.</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy.crypto.crypto import elgamal_public_key</span>
<span class="sd">    &gt;&gt;&gt; elgamal_public_key((1031, 14, 636))</span>
<span class="sd">    (1031, 14, 212)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">p</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">e</span> <span class="o">=</span> <span class="n">key</span>
    <span class="k">return</span> <span class="n">p</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="nb">pow</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span></div>


<div class="viewcode-block" id="encipher_elgamal"><a class="viewcode-back" href="../../../modules/crypto.html#sympy.crypto.crypto.encipher_elgamal">[docs]</a><span class="k">def</span> <span class="nf">encipher_elgamal</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Encrypt message with public key</span>

<span class="sd">    ``i`` is a plaintext message expressed as an integer.</span>
<span class="sd">    ``key`` is public key (p, r, e). In order to encrypt</span>
<span class="sd">    a message, a random number ``a`` in ``range(2, p)``</span>
<span class="sd">    is generated and the encryped message is returned as</span>
<span class="sd">    `c_{1}` and `c_{2}` where:</span>

<span class="sd">    `c_{1} \equiv r^{a} \pmod p`</span>

<span class="sd">    `c_{2} \equiv m e^{a} \pmod p`</span>

<span class="sd">    Parameters</span>
<span class="sd">    ==========</span>

<span class="sd">    msg : int of encoded message</span>
<span class="sd">    key : public key</span>

<span class="sd">    Returns</span>
<span class="sd">    =======</span>

<span class="sd">    (c1, c2) : Encipher into two number</span>

<span class="sd">    Notes</span>
<span class="sd">    =====</span>

<span class="sd">    For testing purposes, the ``seed`` parameter may be set to control</span>
<span class="sd">    the output of this routine. See sympy.utilities.randtest._randrange.</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy.crypto.crypto import encipher_elgamal, elgamal_private_key, elgamal_public_key</span>
<span class="sd">    &gt;&gt;&gt; pri = elgamal_private_key(5, seed=[3]); pri</span>
<span class="sd">    (37, 2, 3)</span>
<span class="sd">    &gt;&gt;&gt; pub = elgamal_public_key(pri); pub</span>
<span class="sd">    (37, 2, 8)</span>
<span class="sd">    &gt;&gt;&gt; msg = 36</span>
<span class="sd">    &gt;&gt;&gt; encipher_elgamal(msg, pub, seed=[3])</span>
<span class="sd">    (8, 6)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">p</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">e</span> <span class="o">=</span> <span class="n">key</span>
    <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="n">p</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s1">&#39;Message (</span><span class="si">%s</span><span class="s1">) should be in range(</span><span class="si">%s</span><span class="s1">)&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">p</span><span class="p">))</span>
    <span class="n">randrange</span> <span class="o">=</span> <span class="n">_randrange</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">randrange</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">pow</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">p</span><span class="p">),</span> <span class="n">i</span><span class="o">*</span><span class="nb">pow</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span> <span class="o">%</span> <span class="n">p</span></div>


<div class="viewcode-block" id="decipher_elgamal"><a class="viewcode-back" href="../../../modules/crypto.html#sympy.crypto.crypto.decipher_elgamal">[docs]</a><span class="k">def</span> <span class="nf">decipher_elgamal</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    Decrypt message with private key</span>

<span class="sd">    `msg = (c_{1}, c_{2})`</span>

<span class="sd">    `key = (p, r, d)`</span>

<span class="sd">    According to extended Eucliden theorem,</span>
<span class="sd">    `u c_{1}^{d} + p n = 1`</span>

<span class="sd">    `u \equiv 1/{{c_{1}}^d} \pmod p`</span>

<span class="sd">    `u c_{2} \equiv \frac{1}{c_{1}^d} c_{2} \equiv \frac{1}{r^{ad}} c_{2} \pmod p`</span>

<span class="sd">    `\frac{1}{r^{ad}} m e^a \equiv \frac{1}{r^{ad}} m {r^{d a}} \equiv m \pmod p`</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy.crypto.crypto import decipher_elgamal</span>
<span class="sd">    &gt;&gt;&gt; from sympy.crypto.crypto import encipher_elgamal</span>
<span class="sd">    &gt;&gt;&gt; from sympy.crypto.crypto import elgamal_private_key</span>
<span class="sd">    &gt;&gt;&gt; from sympy.crypto.crypto import elgamal_public_key</span>

<span class="sd">    &gt;&gt;&gt; pri = elgamal_private_key(5, seed=[3])</span>
<span class="sd">    &gt;&gt;&gt; pub = elgamal_public_key(pri); pub</span>
<span class="sd">    (37, 2, 8)</span>
<span class="sd">    &gt;&gt;&gt; msg = 17</span>
<span class="sd">    &gt;&gt;&gt; decipher_elgamal(encipher_elgamal(msg, pub), pri) == msg</span>
<span class="sd">    True</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">p</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="n">key</span>
    <span class="n">c1</span><span class="p">,</span> <span class="n">c2</span> <span class="o">=</span> <span class="n">msg</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">igcdex</span><span class="p">(</span><span class="n">c1</span><span class="o">**</span><span class="n">d</span><span class="p">,</span> <span class="n">p</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">u</span> <span class="o">*</span> <span class="n">c2</span> <span class="o">%</span> <span class="n">p</span></div>


<span class="c1">################ Diffie-Hellman Key Exchange  #########################</span>

<div class="viewcode-block" id="dh_private_key"><a class="viewcode-back" href="../../../modules/crypto.html#sympy.crypto.crypto.dh_private_key">[docs]</a><span class="k">def</span> <span class="nf">dh_private_key</span><span class="p">(</span><span class="n">digit</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return three integer tuple as private key.</span>

<span class="sd">    Diffie-Hellman key exchange is based on the mathematical problem</span>
<span class="sd">    called the Discrete Logarithm Problem (see ElGamal).</span>

<span class="sd">    Diffie-Hellman key exchange is divided into the following steps:</span>

<span class="sd">    *   Alice and Bob agree on a base that consist of a prime ``p``</span>
<span class="sd">        and a primitive root of ``p`` called ``g``</span>
<span class="sd">    *   Alice choses a number ``a`` and Bob choses a number ``b`` where</span>
<span class="sd">        ``a`` and ``b`` are random numbers in range `[2, p)`. These are</span>
<span class="sd">        their private keys.</span>
<span class="sd">    *   Alice then publicly sends Bob `g^{a} \pmod p` while Bob sends</span>
<span class="sd">        Alice `g^{b} \pmod p`</span>
<span class="sd">    *   They both raise the received value to their secretly chosen</span>
<span class="sd">        number (``a`` or ``b``) and now have both as their shared key</span>
<span class="sd">        `g^{ab} \pmod p`</span>

<span class="sd">    Parameters</span>
<span class="sd">    ==========</span>

<span class="sd">    digit: minimum number of binary digits required in key</span>

<span class="sd">    Returns</span>
<span class="sd">    =======</span>

<span class="sd">    (p, g, a) : p = prime number, g = primitive root of p,</span>
<span class="sd">                a = random number from 2 thru p - 1</span>

<span class="sd">    Notes</span>
<span class="sd">    =====</span>

<span class="sd">    For testing purposes, the ``seed`` parameter may be set to control</span>
<span class="sd">    the output of this routine. See sympy.utilities.randtest._randrange.</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy.crypto.crypto import dh_private_key</span>
<span class="sd">    &gt;&gt;&gt; from sympy.ntheory import isprime, is_primitive_root</span>
<span class="sd">    &gt;&gt;&gt; p, g, _ = dh_private_key()</span>
<span class="sd">    &gt;&gt;&gt; isprime(p)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; is_primitive_root(g, p)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; p, g, _ = dh_private_key(5)</span>
<span class="sd">    &gt;&gt;&gt; isprime(p)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; is_primitive_root(g, p)</span>
<span class="sd">    True</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">nextprime</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="n">digit</span><span class="p">)</span>
    <span class="n">g</span> <span class="o">=</span> <span class="n">primitive_root</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
    <span class="n">randrange</span> <span class="o">=</span> <span class="n">_randrange</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">randrange</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">p</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">a</span></div>


<div class="viewcode-block" id="dh_public_key"><a class="viewcode-back" href="../../../modules/crypto.html#sympy.crypto.crypto.dh_public_key">[docs]</a><span class="k">def</span> <span class="nf">dh_public_key</span><span class="p">(</span><span class="n">key</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return three number tuple as public key.</span>

<span class="sd">    This is the tuple that Alice sends to Bob.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ==========</span>

<span class="sd">    key: Tuple (p, g, a) generated by ``dh_private_key``</span>

<span class="sd">    Returns</span>
<span class="sd">    =======</span>

<span class="sd">    (p, g, g^a mod p) : p, g and a as in Parameters</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy.crypto.crypto import dh_private_key, dh_public_key</span>
<span class="sd">    &gt;&gt;&gt; p, g, a = dh_private_key();</span>
<span class="sd">    &gt;&gt;&gt; _p, _g, x = dh_public_key((p, g, a))</span>
<span class="sd">    &gt;&gt;&gt; p == _p and g == _g</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; x == pow(g, a, p)</span>
<span class="sd">    True</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">p</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">a</span> <span class="o">=</span> <span class="n">key</span>
    <span class="k">return</span> <span class="n">p</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="nb">pow</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span></div>


<div class="viewcode-block" id="dh_shared_key"><a class="viewcode-back" href="../../../modules/crypto.html#sympy.crypto.crypto.dh_shared_key">[docs]</a><span class="k">def</span> <span class="nf">dh_shared_key</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return an integer that is the shared key.</span>

<span class="sd">    This is what Bob and Alice can both calculate using the public</span>
<span class="sd">    keys they received from each other and their private keys.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ==========</span>

<span class="sd">    key: Tuple (p, g, x) generated by ``dh_public_key``</span>
<span class="sd">    b: Random number in the range of 2 to p - 1</span>
<span class="sd">       (Chosen by second key exchange member (Bob))</span>

<span class="sd">    Returns</span>
<span class="sd">    =======</span>

<span class="sd">    shared key (int)</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy.crypto.crypto import (</span>
<span class="sd">    ...     dh_private_key, dh_public_key, dh_shared_key)</span>
<span class="sd">    &gt;&gt;&gt; prk = dh_private_key();</span>
<span class="sd">    &gt;&gt;&gt; p, g, x = dh_public_key(prk);</span>
<span class="sd">    &gt;&gt;&gt; sk = dh_shared_key((p, g, x), 1000)</span>
<span class="sd">    &gt;&gt;&gt; sk == pow(x, 1000, p)</span>
<span class="sd">    True</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">p</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">x</span> <span class="o">=</span> <span class="n">key</span>
    <span class="k">if</span> <span class="mi">1</span> <span class="o">&gt;=</span> <span class="n">b</span> <span class="ow">or</span> <span class="n">b</span> <span class="o">&gt;=</span> <span class="n">p</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">filldedent</span><span class="p">(</span><span class="s1">&#39;&#39;&#39;</span>
<span class="s1">            Value of b should be greater 1 and less</span>
<span class="s1">            than prime </span><span class="si">%s</span><span class="s1">.&#39;&#39;&#39;</span> <span class="o">%</span> <span class="n">p</span><span class="p">))</span>

    <span class="k">return</span> <span class="nb">pow</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span></div>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../../index.html">
              <img class="logo" src="../../../_static/sympylogo.png" alt="Logo"/>
            </a></p><div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../index.html">Documentation overview</a><ul>
  <li><a href="../../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2015 SymPy Development Team.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.4.1</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.7</a>
      
    </div>

    

    
  </body>
</html>