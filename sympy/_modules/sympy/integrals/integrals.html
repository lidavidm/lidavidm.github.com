<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>sympy.integrals.integrals &mdash; SymPy 0.7.3 documentation</title>
    
    <link rel="stylesheet" href="../../../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="http://95.sympy-live-tests.appspot.com/static/live-core.css" type="text/css" />
    <link rel="stylesheet" href="http://95.sympy-live-tests.appspot.com/static/live-autocomplete.css" type="text/css" />
    <link rel="stylesheet" href="http://95.sympy-live-tests.appspot.com/static/live-sphinx.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '0.7.3',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="http://95.sympy-live-tests.appspot.com/static/utilities.js"></script>
    <script type="text/javascript" src="http://95.sympy-live-tests.appspot.com/static/external/classy.js"></script>
    <script type="text/javascript" src="http://95.sympy-live-tests.appspot.com/static/live-core.js"></script>
    <script type="text/javascript" src="http://95.sympy-live-tests.appspot.com/static/live-autocomplete.js"></script>
    <script type="text/javascript" src="http://95.sympy-live-tests.appspot.com/static/live-sphinx.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML-full"></script>
    <link rel="shortcut icon" href="../../../_static/sympy-notailtext-favicon.ico"/>
    <link rel="top" title="SymPy 0.7.3 documentation" href="../../../index.html" />
    <link rel="up" title="Module code" href="../../index.html" />
   
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head>
  <body role="document">  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for sympy.integrals.integrals</h1><div class="highlight"><pre>
<span></span><span class="kn">from</span> <span class="nn">sympy.core.add</span> <span class="kn">import</span> <span class="n">Add</span>
<span class="kn">from</span> <span class="nn">sympy.core.basic</span> <span class="kn">import</span> <span class="n">Basic</span><span class="p">,</span> <span class="n">C</span>
<span class="kn">from</span> <span class="nn">sympy.core.compatibility</span> <span class="kn">import</span> <span class="n">is_sequence</span>
<span class="kn">from</span> <span class="nn">sympy.core.containers</span> <span class="kn">import</span> <span class="n">Tuple</span>
<span class="kn">from</span> <span class="nn">sympy.core.expr</span> <span class="kn">import</span> <span class="n">Expr</span>
<span class="kn">from</span> <span class="nn">sympy.core.function</span> <span class="kn">import</span> <span class="n">diff</span>
<span class="kn">from</span> <span class="nn">sympy.core.numbers</span> <span class="kn">import</span> <span class="n">oo</span>
<span class="kn">from</span> <span class="nn">sympy.core.relational</span> <span class="kn">import</span> <span class="n">Eq</span>
<span class="kn">from</span> <span class="nn">sympy.core.sets</span> <span class="kn">import</span> <span class="n">Interval</span>
<span class="kn">from</span> <span class="nn">sympy.core.singleton</span> <span class="kn">import</span> <span class="n">S</span>
<span class="kn">from</span> <span class="nn">sympy.core.symbol</span> <span class="kn">import</span> <span class="p">(</span><span class="n">Dummy</span><span class="p">,</span> <span class="n">Symbol</span><span class="p">,</span> <span class="n">Wild</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">sympy.core.sympify</span> <span class="kn">import</span> <span class="n">sympify</span>
<span class="kn">from</span> <span class="nn">sympy.integrals.manualintegrate</span> <span class="kn">import</span> <span class="n">manualintegrate</span>
<span class="kn">from</span> <span class="nn">sympy.integrals.trigonometry</span> <span class="kn">import</span> <span class="n">trigintegrate</span>
<span class="kn">from</span> <span class="nn">sympy.integrals.deltafunctions</span> <span class="kn">import</span> <span class="n">deltaintegrate</span>
<span class="kn">from</span> <span class="nn">sympy.integrals.rationaltools</span> <span class="kn">import</span> <span class="n">ratint</span>
<span class="kn">from</span> <span class="nn">sympy.integrals.heurisch</span> <span class="kn">import</span> <span class="n">heurisch</span><span class="p">,</span> <span class="n">heurisch_wrapper</span>
<span class="kn">from</span> <span class="nn">sympy.integrals.meijerint</span> <span class="kn">import</span> <span class="n">meijerint_definite</span><span class="p">,</span> <span class="n">meijerint_indefinite</span>
<span class="kn">from</span> <span class="nn">sympy.utilities</span> <span class="kn">import</span> <span class="n">xthreaded</span><span class="p">,</span> <span class="n">flatten</span>
<span class="kn">from</span> <span class="nn">sympy.utilities.misc</span> <span class="kn">import</span> <span class="n">filldedent</span>
<span class="kn">from</span> <span class="nn">sympy.polys</span> <span class="kn">import</span> <span class="n">Poly</span><span class="p">,</span> <span class="n">PolynomialError</span>
<span class="kn">from</span> <span class="nn">sympy.solvers.solvers</span> <span class="kn">import</span> <span class="n">solve</span><span class="p">,</span> <span class="n">posify</span>
<span class="kn">from</span> <span class="nn">sympy.functions</span> <span class="kn">import</span> <span class="n">Piecewise</span><span class="p">,</span> <span class="n">sqrt</span><span class="p">,</span> <span class="n">sign</span>
<span class="kn">from</span> <span class="nn">sympy.geometry</span> <span class="kn">import</span> <span class="n">Curve</span>
<span class="kn">from</span> <span class="nn">sympy.functions.elementary.piecewise</span> <span class="kn">import</span> <span class="n">piecewise_fold</span>
<span class="kn">from</span> <span class="nn">sympy.series</span> <span class="kn">import</span> <span class="n">limit</span>


<span class="c1"># TODO get these helper functions into a super class for sum-like</span>
<span class="c1"># objects: Sum, Product, Integral (issue 3662)</span>

<span class="k">def</span> <span class="nf">_free_symbols</span><span class="p">(</span><span class="n">expr_with_limits</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This method returns the symbols that will exist when the object is</span>
<span class="sd">    evaluated. This is useful if one is trying to determine whether the</span>
<span class="sd">    objet contains a certain symbol or not.</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy import Sum</span>
<span class="sd">    &gt;&gt;&gt; from sympy.abc import x, y</span>
<span class="sd">    &gt;&gt;&gt; Sum(x, (x, y, 1)).free_symbols</span>
<span class="sd">    set([y])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="bp">self</span> <span class="o">=</span> <span class="n">expr_with_limits</span>
    <span class="n">function</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">function</span>
    <span class="k">if</span> <span class="n">function</span><span class="o">.</span><span class="n">is_zero</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">set</span><span class="p">()</span>
    <span class="n">limits</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">limits</span>
    <span class="n">isyms</span> <span class="o">=</span> <span class="n">function</span><span class="o">.</span><span class="n">free_symbols</span>
    <span class="k">for</span> <span class="n">xab</span> <span class="ow">in</span> <span class="n">limits</span><span class="p">:</span>
        <span class="c1"># take out the target symbol</span>
        <span class="k">if</span> <span class="n">xab</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="n">isyms</span><span class="p">:</span>
            <span class="n">isyms</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">xab</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="c1"># add in the new symbols</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">xab</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
            <span class="n">isyms</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">free_symbols</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">isyms</span>


<span class="k">def</span> <span class="nf">_process_limits</span><span class="p">(</span><span class="o">*</span><span class="n">symbols</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Process the list of symbols and convert them to canonical limits,</span>
<span class="sd">    storing them as Tuple(symbol, lower, upper). The sign of</span>
<span class="sd">    the function is also returned when the upper limit is missing</span>
<span class="sd">    so (x, 1, None) becomes (x, None, 1) and the sign is changed.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">limits</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">sign</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">for</span> <span class="n">V</span> <span class="ow">in</span> <span class="n">symbols</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">Symbol</span><span class="p">):</span>
            <span class="n">limits</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Tuple</span><span class="p">(</span><span class="n">V</span><span class="p">))</span>
            <span class="k">continue</span>
        <span class="k">elif</span> <span class="n">is_sequence</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">):</span>
            <span class="n">V</span> <span class="o">=</span> <span class="n">sympify</span><span class="p">(</span><span class="n">flatten</span><span class="p">(</span><span class="n">V</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">V</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">is_Symbol</span><span class="p">:</span>
                <span class="n">newsymbol</span> <span class="o">=</span> <span class="n">V</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">V</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">V</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">Interval</span><span class="p">):</span>
                    <span class="n">V</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="p">[</span><span class="n">V</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="n">V</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">end</span><span class="p">]</span>

                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">V</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">V</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">and</span> <span class="n">V</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                        <span class="n">nlim</span> <span class="o">=</span> <span class="p">[</span><span class="n">V</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span>
                    <span class="k">elif</span> <span class="n">V</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> <span class="n">V</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                        <span class="n">sign</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span>
                        <span class="n">nlim</span> <span class="o">=</span> <span class="p">[</span><span class="n">V</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
                    <span class="k">elif</span> <span class="n">V</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">and</span> <span class="n">V</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                        <span class="n">nlim</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">nlim</span> <span class="o">=</span> <span class="n">V</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
                    <span class="n">limits</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Tuple</span><span class="p">(</span><span class="n">newsymbol</span><span class="p">,</span> <span class="o">*</span><span class="n">nlim</span> <span class="p">))</span>
                    <span class="k">continue</span>
                <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">V</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">V</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">V</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">):</span>
                    <span class="n">limits</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Tuple</span><span class="p">(</span><span class="n">newsymbol</span><span class="p">))</span>
                    <span class="k">continue</span>
                <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">V</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="n">limits</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Tuple</span><span class="p">(</span><span class="n">newsymbol</span><span class="p">,</span> <span class="n">V</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
                    <span class="k">continue</span>

        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Invalid limits given: </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">symbols</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">limits</span><span class="p">,</span> <span class="n">sign</span>


<span class="k">def</span> <span class="nf">_as_dummy</span><span class="p">(</span><span class="n">expr_with_limits</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Replace instances of the limit variables with their dummy</span>
<span class="sd">    counterparts to make clear what are dummy variables and what</span>
<span class="sd">    are real-world symbols in an object.</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy import Integral</span>
<span class="sd">    &gt;&gt;&gt; from sympy.abc import x, y</span>
<span class="sd">    &gt;&gt;&gt; Integral(x, (x, x, y), (y, x, y)).as_dummy()</span>
<span class="sd">    Integral(_x, (_x, x, _y), (_y, x, y))</span>

<span class="sd">    If the object supperts the &quot;integral at&quot; limit ``(x,)`` it</span>
<span class="sd">    is not treated as a dummy, but the explicit form, ``(x, x)``</span>
<span class="sd">    of length 2 does treat the variable as a dummy.</span>

<span class="sd">    &gt;&gt;&gt; Integral(x, x).as_dummy()</span>
<span class="sd">    Integral(x, x)</span>
<span class="sd">    &gt;&gt;&gt; Integral(x, (x, x)).as_dummy()</span>
<span class="sd">    Integral(_x, (_x, x))</span>

<span class="sd">    If there were no dummies in the original expression, then the</span>
<span class="sd">    the symbols which cannot be changed by subs() are clearly seen as</span>
<span class="sd">    those with an underscore prefix.</span>

<span class="sd">    See Also</span>
<span class="sd">    ========</span>

<span class="sd">    variables : Lists the integration variables</span>
<span class="sd">    transform : Perform mapping on the integration variable</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="bp">self</span> <span class="o">=</span> <span class="n">expr_with_limits</span>
    <span class="n">reps</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">f</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">function</span>
    <span class="n">limits</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">limits</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">limits</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">xab</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">limits</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">xab</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">xab</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">xab</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">as_dummy</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">xab</span><span class="p">)):</span>
            <span class="n">xab</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">xab</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">reps</span><span class="p">)</span>
        <span class="n">reps</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">xab</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">limits</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">xab</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">reps</span><span class="p">)</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">func</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">limits</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_eval_subs</span><span class="p">(</span><span class="n">expr_with_limits</span><span class="p">,</span> <span class="n">old</span><span class="p">,</span> <span class="n">new</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Substitute old with new in the function and the limits, but don&#39;t</span>
<span class="sd">        change anything that is (or corresponds to) a bound symbol,</span>

<span class="sd">        The normal substitution semantics -- traversing all arguments looking</span>
<span class="sd">        for matching patterns -- should not be applied to the sum-like objects</span>
<span class="sd">        since changing the limit variables should also entail a change in the</span>
<span class="sd">        limits (which should be done with the transform method). So</span>
<span class="sd">        this method just makes changes in the function and the limits.</span>

<span class="sd">        Not all instances of a given variable are conceptually the same: the</span>
<span class="sd">        first argument of the limit tuple with length greater than 1 and any</span>
<span class="sd">        corresponding variable in the function are dummy variables while</span>
<span class="sd">        every other symbol is a symbol that will be unchanged when the integral</span>
<span class="sd">        is evaluated. For example, the dummy variables for ``i`` can be seen</span>
<span class="sd">        as symbols with a preppended underscore. (The discussion below applies</span>
<span class="sd">        ti Integral and any other &quot;function with limits&quot; sort of objects.)</span>

<span class="sd">        &gt;&gt;&gt; from sympy import Integral</span>
<span class="sd">        &gt;&gt;&gt; from sympy.abc import a, b, c, x, y</span>
<span class="sd">        &gt;&gt;&gt; i = Integral(a + x, (a, a, b))</span>
<span class="sd">        &gt;&gt;&gt; i.as_dummy()</span>
<span class="sd">        Integral(_a + x, (_a, a, b))</span>

<span class="sd">        If you want to change the lower limit to 1 there is no reason to</span>
<span class="sd">        prohibit this since it is not conceptually related to the integration</span>
<span class="sd">        variable, ``_a``. Nor is there reason to disallow changing the ``b``</span>
<span class="sd">        to 1.</span>

<span class="sd">        If a second limit were added, however, as in:</span>

<span class="sd">        &gt;&gt;&gt; i = Integral(x + a, (a, a, b), (b, 1, 2))</span>

<span class="sd">        the dummy variables become:</span>

<span class="sd">        &gt;&gt;&gt; i.as_dummy()</span>
<span class="sd">        Integral(_a + x, (_a, a, _b), (_b, 1, 2))</span>

<span class="sd">        Note that the ``b`` of the first limit is now a dummy variable since</span>
<span class="sd">        ``b`` is a dummy variable in the second limit.</span>

<span class="sd">        The &quot;evaluate at&quot; form of an integral allows some flexibility in how</span>
<span class="sd">        the integral will be treated by subs: if there is no second argument,</span>
<span class="sd">        none of the symbols matching the integration symbol are considered to</span>
<span class="sd">        be dummy variables, but if an explicit expression is given for a limit</span>
<span class="sd">        then the usual interpretation of the integration symbol as a dummy</span>
<span class="sd">        symbol applies:</span>

<span class="sd">        &gt;&gt;&gt; Integral(x).as_dummy() # implicit integration wrt x</span>
<span class="sd">        Integral(x, x)</span>
<span class="sd">        &gt;&gt;&gt; Integral(x, x).as_dummy()</span>
<span class="sd">        Integral(x, x)</span>
<span class="sd">        &gt;&gt;&gt; _.subs(x, 1)</span>
<span class="sd">        Integral(1, x)</span>
<span class="sd">        &gt;&gt;&gt; i = Integral(x, (x, x))</span>
<span class="sd">        &gt;&gt;&gt; i.as_dummy()</span>
<span class="sd">        Integral(_x, (_x, x))</span>
<span class="sd">        &gt;&gt;&gt; i.subs(x, 1)</span>
<span class="sd">        Integral(x, (x, 1))</span>

<span class="sd">        Summary</span>
<span class="sd">        =======</span>

<span class="sd">        No variable of the integrand or limit can be the target of</span>
<span class="sd">        substitution if it appears as a variable of integration in a limit</span>
<span class="sd">        positioned to the right of it. The only exception is for a variable</span>
<span class="sd">        that defines an indefinite integral limit (a single symbol): that</span>
<span class="sd">        symbol *can* be replaced in the integrand.</span>

<span class="sd">        &gt;&gt;&gt; i = Integral(a + x, (a, a, 3), (b, x, c))</span>
<span class="sd">        &gt;&gt;&gt; i.free_symbols # only these can be changed</span>
<span class="sd">        set([a, c, x])</span>
<span class="sd">        &gt;&gt;&gt; i.subs(a, c) # note that the variable of integration is unchanged</span>
<span class="sd">        Integral(a + x, (a, c, 3), (b, x, c))</span>
<span class="sd">        &gt;&gt;&gt; i.subs(a + x, b) == i # there is no x + a, only x + &lt;a&gt;</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; i.subs(x, y - c)</span>
<span class="sd">        Integral(a - c + y, (a, a, 3), (b, -c + y, c))</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span> <span class="o">=</span> <span class="n">expr_with_limits</span>
        <span class="n">func</span><span class="p">,</span> <span class="n">limits</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">function</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">limits</span>
        <span class="n">old_atoms</span> <span class="o">=</span> <span class="n">old</span><span class="o">.</span><span class="n">free_symbols</span>
        <span class="n">limits</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">limits</span><span class="p">)</span>

        <span class="n">dummies</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">limits</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">xab</span> <span class="o">=</span> <span class="n">limits</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">xab</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">dummies</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">old_atoms</span><span class="p">):</span>
                <span class="n">limits</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">Tuple</span><span class="p">(</span>
                    <span class="n">xab</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">*</span><span class="p">[</span><span class="n">l</span><span class="o">.</span><span class="n">_subs</span><span class="p">(</span><span class="n">old</span><span class="p">,</span> <span class="n">new</span><span class="p">)</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">xab</span><span class="p">[</span><span class="mi">1</span><span class="p">:]])</span>
            <span class="n">dummies</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">xab</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">dummies</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">old_atoms</span><span class="p">):</span>
            <span class="n">func</span> <span class="o">=</span> <span class="n">func</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">old</span><span class="p">,</span> <span class="n">new</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">func</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="o">*</span><span class="n">limits</span><span class="p">)</span>


<div class="viewcode-block" id="Integral"><a class="viewcode-back" href="../../../modules/integrals/integrals.html#sympy.integrals.Integral">[docs]</a><span class="k">class</span> <span class="nc">Integral</span><span class="p">(</span><span class="n">Expr</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Represents unevaluated integral.&quot;&quot;&quot;</span>

    <span class="n">__slots__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;is_commutative&#39;</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">function</span><span class="p">,</span> <span class="o">*</span><span class="n">symbols</span><span class="p">,</span> <span class="o">**</span><span class="n">assumptions</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create an unevaluated integral.</span>

<span class="sd">        Arguments are an integrand followed by one or more limits.</span>

<span class="sd">        If no limits are given and there is only one free symbol in the</span>
<span class="sd">        expression, that symbol will be used, otherwise an error will be</span>
<span class="sd">        raised.</span>

<span class="sd">        &gt;&gt;&gt; from sympy import Integral</span>
<span class="sd">        &gt;&gt;&gt; from sympy.abc import x, y</span>
<span class="sd">        &gt;&gt;&gt; Integral(x)</span>
<span class="sd">        Integral(x, x)</span>
<span class="sd">        &gt;&gt;&gt; Integral(y)</span>
<span class="sd">        Integral(y, y)</span>

<span class="sd">        When limits are provided, they are interpreted as follows (using</span>
<span class="sd">        ``x`` as though it were the variable of integration):</span>

<span class="sd">            (x,) or x - indefinite integral</span>
<span class="sd">            (x, a) - &quot;evaluate at&quot; integral</span>
<span class="sd">            (x, a, b) - definite integral</span>

<span class="sd">        Although the same integral will be obtained from an indefinite</span>
<span class="sd">        integral and an &quot;evaluate at&quot; integral when ``a == x``, they</span>
<span class="sd">        respond differently to substitution:</span>

<span class="sd">        &gt;&gt;&gt; i = Integral(x, x)</span>
<span class="sd">        &gt;&gt;&gt; at = Integral(x, (x, x))</span>
<span class="sd">        &gt;&gt;&gt; i.doit() == at.doit()</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; i.subs(x, 1)</span>
<span class="sd">        Integral(1, x)</span>
<span class="sd">        &gt;&gt;&gt; at.subs(x, 1)</span>
<span class="sd">        Integral(x, (x, 1))</span>

<span class="sd">        The ``as_dummy`` method can be used to see which symbols cannot be</span>
<span class="sd">        targeted by subs: those with a preppended underscore cannot be</span>
<span class="sd">        changed with ``subs``. (Also, the integration variables themselves --</span>
<span class="sd">        the first element of a limit -- can never be changed by subs.)</span>

<span class="sd">        &gt;&gt;&gt; i.as_dummy()</span>
<span class="sd">        Integral(x, x)</span>
<span class="sd">        &gt;&gt;&gt; at.as_dummy()</span>
<span class="sd">        Integral(_x, (_x, x))</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Any embedded piecewise functions need to be brought out to the</span>
        <span class="c1"># top level so that integration can go into piecewise mode at the</span>
        <span class="c1"># earliest possible moment.</span>
        <span class="n">function</span> <span class="o">=</span> <span class="n">piecewise_fold</span><span class="p">(</span><span class="n">sympify</span><span class="p">(</span><span class="n">function</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">function</span> <span class="ow">is</span> <span class="n">S</span><span class="o">.</span><span class="n">NaN</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">S</span><span class="o">.</span><span class="n">NaN</span>

        <span class="k">if</span> <span class="n">symbols</span><span class="p">:</span>
            <span class="n">limits</span><span class="p">,</span> <span class="n">sign</span> <span class="o">=</span> <span class="n">_process_limits</span><span class="p">(</span><span class="o">*</span><span class="n">symbols</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># no symbols provided -- let&#39;s compute full anti-derivative</span>
            <span class="n">free</span> <span class="o">=</span> <span class="n">function</span><span class="o">.</span><span class="n">free_symbols</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">free</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;specify variables of integration for </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">function</span><span class="p">)</span>
            <span class="n">limits</span><span class="p">,</span> <span class="n">sign</span> <span class="o">=</span> <span class="p">[</span><span class="n">Tuple</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">free</span><span class="p">],</span> <span class="mi">1</span>

        <span class="k">while</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">function</span><span class="p">,</span> <span class="n">Integral</span><span class="p">):</span>
            <span class="c1"># denest the integrand</span>
            <span class="n">limits</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">function</span><span class="o">.</span><span class="n">limits</span><span class="p">)</span> <span class="o">+</span> <span class="n">limits</span>
            <span class="n">function</span> <span class="o">=</span> <span class="n">function</span><span class="o">.</span><span class="n">function</span>

        <span class="n">obj</span> <span class="o">=</span> <span class="n">Expr</span><span class="o">.</span><span class="n">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="o">**</span><span class="n">assumptions</span><span class="p">)</span>
        <span class="n">arglist</span> <span class="o">=</span> <span class="p">[</span><span class="n">sign</span><span class="o">*</span><span class="n">function</span><span class="p">]</span>
        <span class="n">arglist</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">limits</span><span class="p">)</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">_args</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">arglist</span><span class="p">)</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">is_commutative</span> <span class="o">=</span> <span class="n">function</span><span class="o">.</span><span class="n">is_commutative</span>  <span class="c1"># limits already checked</span>

        <span class="k">return</span> <span class="n">obj</span>

    <span class="k">def</span> <span class="nf">__getnewargs__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">function</span><span class="p">,)</span> <span class="o">+</span> <span class="nb">tuple</span><span class="p">([</span><span class="nb">tuple</span><span class="p">(</span><span class="n">xab</span><span class="p">)</span> <span class="k">for</span> <span class="n">xab</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">limits</span><span class="p">])</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">function</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the function to be integrated.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy import Integral</span>
<span class="sd">        &gt;&gt;&gt; from sympy.abc import x</span>
<span class="sd">        &gt;&gt;&gt; Integral(x**2, (x,)).function</span>
<span class="sd">        x**2</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        limits, variables, free_symbols</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">limits</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the limits of integration.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy import Integral</span>
<span class="sd">        &gt;&gt;&gt; from sympy.abc import x, i</span>
<span class="sd">        &gt;&gt;&gt; Integral(x**i, (i, 1, 3)).limits</span>
<span class="sd">        ((i, 1, 3),)</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        function, variables, free_symbols</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_args</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">variables</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a list of the integration variables.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy import Integral</span>
<span class="sd">        &gt;&gt;&gt; from sympy.abc import x, i</span>
<span class="sd">        &gt;&gt;&gt; Integral(x**i, (i, 1, 3)).variables</span>
<span class="sd">        [i]</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        function, limits, free_symbols</span>
<span class="sd">        as_dummy : Replace integration variables with dummy ones</span>
<span class="sd">        transform : Perform mapping on the integration variable</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">l</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">limits</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">free_symbols</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method returns the symbols that will exist when the</span>
<span class="sd">        integral is evaluated. This is useful if one is trying to</span>
<span class="sd">        determine whether an integral depends on a certain</span>
<span class="sd">        symbol or not.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy import Integral</span>
<span class="sd">        &gt;&gt;&gt; from sympy.abc import x, y</span>
<span class="sd">        &gt;&gt;&gt; Integral(x, (x, y, 1)).free_symbols</span>
<span class="sd">        set([y])</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        function, limits, variables</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">function</span><span class="p">,</span> <span class="n">limits</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">function</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">limits</span>
        <span class="k">if</span> <span class="n">function</span><span class="o">.</span><span class="n">is_zero</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">isyms</span> <span class="o">=</span> <span class="n">function</span><span class="o">.</span><span class="n">free_symbols</span>
        <span class="k">for</span> <span class="n">xab</span> <span class="ow">in</span> <span class="n">limits</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">xab</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">isyms</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">xab</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="k">continue</span>
            <span class="c1"># take out the target symbol</span>
            <span class="k">if</span> <span class="n">xab</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="n">isyms</span><span class="p">:</span>
                <span class="n">isyms</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">xab</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">xab</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span> <span class="ow">and</span> <span class="n">xab</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">xab</span><span class="p">[</span><span class="mi">2</span><span class="p">]:</span>
                <span class="c1"># if two limits are the same the integral is 0</span>
                <span class="c1"># and there are no symbols</span>
                <span class="k">return</span> <span class="nb">set</span><span class="p">()</span>
            <span class="c1"># add in the new symbols</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">xab</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
                <span class="n">isyms</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">free_symbols</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">isyms</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_zero</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Since Integral doesn&#39;t autosimplify it it useful to see if</span>
<span class="sd">        it would simplify to zero or not in a trivial manner, i.e. when</span>
<span class="sd">        the function is 0 or two limits of a definite integral are the same.</span>

<span class="sd">        This is a very naive and quick test, not intended to check for special</span>
<span class="sd">        patterns like Integral(sin(m*x)*cos(n*x), (x, 0, 2*pi)) == 0.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy import Integral</span>
<span class="sd">        &gt;&gt;&gt; from sympy.abc import x, y, z</span>
<span class="sd">        &gt;&gt;&gt; Integral(1, (x, 1, 1)).is_zero</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; Integral(0, (x, y, z)).is_zero</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; Integral(1, (x, 1, 2)).is_zero</span>
<span class="sd">        False</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        is_number</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">function</span><span class="o">.</span><span class="n">is_zero</span> <span class="ow">or</span>
                <span class="nb">any</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">xab</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span> <span class="ow">and</span> <span class="n">xab</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">xab</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="k">for</span> <span class="n">xab</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">limits</span><span class="p">)):</span>
            <span class="k">return</span> <span class="bp">True</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">free_symbols</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">function</span><span class="o">.</span><span class="n">is_number</span><span class="p">:</span>
            <span class="c1"># the integrand is a number and the limits are numerical</span>
            <span class="k">return</span> <span class="bp">False</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_number</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return True if the Integral will result in a number, else False.</span>

<span class="sd">        Integrals are a special case since they contain symbols that can</span>
<span class="sd">        be replaced with numbers. Whether the integral can be done or not is</span>
<span class="sd">        another issue. But answering whether the final result is a number is</span>
<span class="sd">        not difficult.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy import Integral</span>
<span class="sd">        &gt;&gt;&gt; from sympy.abc import x, y</span>
<span class="sd">        &gt;&gt;&gt; Integral(x).is_number</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; Integral(x, y).is_number</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; Integral(x, (y, 1, x)).is_number</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; Integral(x, (y, 1, 2)).is_number</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; Integral(x, (y, 1, 1)).is_number</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; Integral(x, (x, 1, 2)).is_number</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; Integral(x*y, (x, 1, 2), (y, 1, 3)).is_number</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; Integral(1, x, (x, 1, 2)).is_number</span>
<span class="sd">        True</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        is_zero</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">integrand</span><span class="p">,</span> <span class="n">limits</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">function</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">limits</span>
        <span class="n">isyms</span> <span class="o">=</span> <span class="n">integrand</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">Symbol</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">xab</span> <span class="ow">in</span> <span class="n">limits</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">xab</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">isyms</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">xab</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="k">continue</span>  <span class="c1"># it may be removed later</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">xab</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span> <span class="ow">and</span> <span class="n">xab</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">xab</span><span class="p">[</span><span class="mi">2</span><span class="p">]:</span>  <span class="c1"># XXX naive equality test</span>
                <span class="k">return</span> <span class="bp">True</span>  <span class="c1"># integral collapsed</span>
            <span class="k">if</span> <span class="n">xab</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="n">isyms</span><span class="p">:</span>
                <span class="c1"># take it out of the symbols since it will be replace</span>
                <span class="c1"># with whatever the limits of the integral are</span>
                <span class="n">isyms</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">xab</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="c1"># add in the new symbols</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">xab</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
                <span class="n">isyms</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">free_symbols</span><span class="p">)</span>
        <span class="c1"># if there are no surviving symbols then the result is a number</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">isyms</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">as_dummy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">_as_dummy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

<div class="viewcode-block" id="Integral.transform"><a class="viewcode-back" href="../../../modules/integrals/integrals.html#sympy.integrals.Integral.transform">[docs]</a>    <span class="k">def</span> <span class="nf">transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">inverse</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">        Performs a change of variables from `x` to `u` using the relationship</span>
<span class="sd">        given by `x` and `u` which will define the transformations `f` and `F`</span>
<span class="sd">        (which are inverses of each other) as follows:</span>

<span class="sd">        1) If `x` is a Symbol (which is a variable of integration) then `u`</span>
<span class="sd">           will be interpreted as some function, f(u), with inverse F(u).</span>
<span class="sd">           This, in effect, just makes the substitution of x with f(x).</span>

<span class="sd">        2) If `u` is a Symbol then `x` will be interpreted as some function,</span>
<span class="sd">           F(x), with inverse f(u). This is commonly referred to as</span>
<span class="sd">           u-substitution.</span>

<span class="sd">        The `inverse` option will reverse `x` and `u`. It is a deprecated option</span>
<span class="sd">        since `x` and `u` can just be passed in reverse order.</span>

<span class="sd">        Once f and F have been identified, the transformation is made as</span>
<span class="sd">        follows:</span>

<span class="sd">        .. math:: \int_a^b x \mathrm{d}x \rightarrow \int_{F(a)}^{F(b)} f(x)</span>
<span class="sd">                  \frac{\mathrm{d}}{\mathrm{d}x}</span>

<span class="sd">        where `F(x)` is the inverse of `f(x)` and the limits and integrand have</span>
<span class="sd">        been corrected so as to retain the same value after integration.</span>

<span class="sd">        Notes</span>
<span class="sd">        =====</span>

<span class="sd">        The mappings, F(x) or f(u), must lead to a unique integral. Linear</span>
<span class="sd">        or rational linear expression, `2*x`, `1/x` and `sqrt(x)`, will</span>
<span class="sd">        always work; quadratic expressions like `x**2 - 1` are acceptable</span>
<span class="sd">        as long as the resulting integrand does not depend on the sign of</span>
<span class="sd">        the solutions (see examples).</span>

<span class="sd">        The integral will be returned unchanged if `x` is not a variable of</span>
<span class="sd">        integration.</span>

<span class="sd">        `x` must be (or contain) only one of of the integration variables. If</span>
<span class="sd">        `u` has more than one free symbol then it should be sent as a tuple</span>
<span class="sd">        (`u`, `uvar`) where `uvar` identifies which variable is replacing</span>
<span class="sd">        the integration variable.</span>
<span class="sd">        XXX can it contain another integration variable?</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.abc import a, b, c, d, x, u, y</span>
<span class="sd">        &gt;&gt;&gt; from sympy import Integral, S, cos, sqrt</span>

<span class="sd">        &gt;&gt;&gt; i = Integral(x*cos(x**2 - 1), (x, 0, 1))</span>

<span class="sd">        transform can change the variable of integration</span>

<span class="sd">        &gt;&gt;&gt; i.transform(x, u)</span>
<span class="sd">        Integral(u*cos(u**2 - 1), (u, 0, 1))</span>

<span class="sd">        transform can perform u-substitution as long as a unique</span>
<span class="sd">        integrand is obtained:</span>

<span class="sd">        &gt;&gt;&gt; i.transform(x**2 - 1, u)</span>
<span class="sd">        Integral(cos(u)/2, (u, -1, 0))</span>

<span class="sd">        This attempt fails because x = +/-sqrt(u + 1) and the</span>
<span class="sd">        sign does not cancel out of the integrand:</span>

<span class="sd">        &gt;&gt;&gt; Integral(cos(x**2 - 1), (x, 0, 1)).transform(x**2 - 1, u)</span>
<span class="sd">        Traceback (most recent call last):</span>
<span class="sd">        ...</span>
<span class="sd">        ValueError:</span>
<span class="sd">        The mapping between F(x) and f(u) did not give a unique integrand.</span>

<span class="sd">        transform can do a substitution. Here, the previous</span>
<span class="sd">        result is transformed back into the original expression</span>
<span class="sd">        using &quot;u-substitution&quot;:</span>

<span class="sd">        &gt;&gt;&gt; ui = _</span>
<span class="sd">        &gt;&gt;&gt; _.transform(sqrt(u + 1), x) == i</span>
<span class="sd">        True</span>

<span class="sd">        We can accomplish the same with a regular substitution:</span>

<span class="sd">        &gt;&gt;&gt; ui.transform(u, x**2 - 1) == i</span>
<span class="sd">        True</span>

<span class="sd">        If the `x` does not contain a symbol of integration then</span>
<span class="sd">        the integral will be returned unchanged. Integral `i` does</span>
<span class="sd">        not have an integration variable `a` so no change is made:</span>

<span class="sd">        &gt;&gt;&gt; i.transform(a, x) == i</span>
<span class="sd">        True</span>

<span class="sd">        When `u` has more than one free symbol the symbol that is</span>
<span class="sd">        replacing `x` must be identified by passing `u` as a tuple:</span>

<span class="sd">        &gt;&gt;&gt; Integral(x, (x, 0, 1)).transform(x, (u + a, u))</span>
<span class="sd">        Integral(a + u, (u, -a, -a + 1))</span>
<span class="sd">        &gt;&gt;&gt; Integral(x, (x, 0, 1)).transform(x, (u + a, a))</span>
<span class="sd">        Integral(a + u, (a, -u, -u + 1))</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        variables : Lists the integration variables</span>
<span class="sd">        as_dummy : Replace integration variables with dummy ones</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">inverse</span><span class="p">:</span>
            <span class="c1"># when this is removed, update the docstring</span>
            <span class="kn">from</span> <span class="nn">sympy.utilities.exceptions</span> <span class="kn">import</span> <span class="n">SymPyDeprecationWarning</span>
            <span class="n">SymPyDeprecationWarning</span><span class="p">(</span>
                <span class="n">feature</span><span class="o">=</span><span class="s2">&quot;transform(x, f(x), inverse=True)&quot;</span><span class="p">,</span>
                <span class="n">useinstead</span><span class="o">=</span><span class="s2">&quot;transform(f(x), x)&quot;</span><span class="p">,</span>
                <span class="n">issue</span><span class="o">=</span><span class="mi">3380</span><span class="p">,</span> <span class="n">deprecated_since_version</span><span class="o">=</span><span class="s2">&quot;0.7.2&quot;</span><span class="p">,</span>
            <span class="p">)</span><span class="o">.</span><span class="n">warn</span><span class="p">()</span>
            <span class="c1"># in the old style x and u contained the same variable so</span>
            <span class="c1"># don&#39;t worry about using the old-style feature with the</span>
            <span class="c1"># new style input...but it will still work:</span>
            <span class="c1"># i.transform(x, u).transform(x, u, inverse=True) -&gt; i</span>
            <span class="n">x</span><span class="p">,</span> <span class="n">u</span> <span class="o">=</span> <span class="n">u</span><span class="p">,</span> <span class="n">x</span>

        <span class="n">d</span> <span class="o">=</span> <span class="n">Dummy</span><span class="p">(</span><span class="s1">&#39;d&#39;</span><span class="p">)</span>

        <span class="n">xfree</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">free_symbols</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">xfree</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s1">&#39;F(x) can only contain one of: </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">)</span>
        <span class="n">xvar</span> <span class="o">=</span> <span class="n">xfree</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span> <span class="k">if</span> <span class="n">xfree</span> <span class="k">else</span> <span class="n">d</span>

        <span class="k">if</span> <span class="n">xvar</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>

        <span class="n">u</span> <span class="o">=</span> <span class="n">sympify</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">Expr</span><span class="p">):</span>
            <span class="n">ufree</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">free_symbols</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ufree</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">filldedent</span><span class="p">(</span><span class="s1">&#39;&#39;&#39;</span>
<span class="s1">                When f(u) has more than one free symbol, the one replacing x</span>
<span class="s1">                must be identified: pass f(u) as (f(u), u)&#39;&#39;&#39;</span><span class="p">))</span>
            <span class="n">uvar</span> <span class="o">=</span> <span class="n">ufree</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">u</span><span class="p">,</span> <span class="n">uvar</span> <span class="o">=</span> <span class="n">u</span>
            <span class="k">if</span> <span class="n">uvar</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">u</span><span class="o">.</span><span class="n">free_symbols</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">filldedent</span><span class="p">(</span><span class="s1">&#39;&#39;&#39;</span>
<span class="s1">                Expecting a tuple (expr, symbol) where symbol identified</span>
<span class="s1">                a free symbol in expr, but symbol is not in expr&#39;s free</span>
<span class="s1">                symbols.&#39;&#39;&#39;</span><span class="p">))</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">uvar</span><span class="p">,</span> <span class="n">Symbol</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">filldedent</span><span class="p">(</span><span class="s1">&#39;&#39;&#39;</span>
<span class="s1">                Expecting a tuple (expr, symbol) but didn&#39;t get</span>
<span class="s1">                a symbol; got </span><span class="si">%s</span><span class="s1">&#39;&#39;&#39;</span> <span class="o">%</span> <span class="n">uvar</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">is_Symbol</span> <span class="ow">and</span> <span class="n">u</span><span class="o">.</span><span class="n">is_Symbol</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">xreplace</span><span class="p">({</span><span class="n">x</span><span class="p">:</span> <span class="n">u</span><span class="p">})</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">x</span><span class="o">.</span><span class="n">is_Symbol</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">u</span><span class="o">.</span><span class="n">is_Symbol</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;either x or u must be a symbol&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">uvar</span> <span class="o">==</span> <span class="n">xvar</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">u</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">uvar</span><span class="p">,</span> <span class="n">d</span><span class="p">))</span><span class="o">.</span><span class="n">xreplace</span><span class="p">({</span><span class="n">d</span><span class="p">:</span> <span class="n">uvar</span><span class="p">})</span>

        <span class="k">if</span> <span class="n">uvar</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">limits</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">filldedent</span><span class="p">(</span><span class="s1">&#39;&#39;&#39;</span>
<span class="s1">            u must contain the same variable as in x</span>
<span class="s1">            or a variable that is not already an integration variable&#39;&#39;&#39;</span><span class="p">))</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">x</span><span class="o">.</span><span class="n">is_Symbol</span><span class="p">:</span>
            <span class="n">F</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">xvar</span><span class="p">,</span> <span class="n">d</span><span class="p">)]</span>
            <span class="n">soln</span> <span class="o">=</span> <span class="n">solve</span><span class="p">(</span><span class="n">u</span> <span class="o">-</span> <span class="n">x</span><span class="p">,</span> <span class="n">xvar</span><span class="p">,</span> <span class="n">check</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">soln</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;no solution for solve(F(x) - f(u), x)&#39;</span><span class="p">)</span>
            <span class="n">f</span> <span class="o">=</span> <span class="p">[</span><span class="n">fi</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">uvar</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span> <span class="k">for</span> <span class="n">fi</span> <span class="ow">in</span> <span class="n">soln</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">f</span> <span class="o">=</span> <span class="p">[</span><span class="n">u</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">uvar</span><span class="p">,</span> <span class="n">d</span><span class="p">)]</span>
            <span class="n">pdiff</span><span class="p">,</span> <span class="n">reps</span> <span class="o">=</span> <span class="n">posify</span><span class="p">(</span><span class="n">u</span> <span class="o">-</span> <span class="n">x</span><span class="p">)</span>
            <span class="n">puvar</span> <span class="o">=</span> <span class="n">uvar</span><span class="o">.</span><span class="n">subs</span><span class="p">([(</span><span class="n">v</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">reps</span><span class="o">.</span><span class="n">iteritems</span><span class="p">()])</span>
            <span class="n">soln</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">reps</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">solve</span><span class="p">(</span><span class="n">pdiff</span><span class="p">,</span> <span class="n">puvar</span><span class="p">)]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">soln</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;no solution for solve(F(x) - f(u), u)&#39;</span><span class="p">)</span>
            <span class="n">F</span> <span class="o">=</span> <span class="p">[</span><span class="n">fi</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">xvar</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span> <span class="k">for</span> <span class="n">fi</span> <span class="ow">in</span> <span class="n">soln</span><span class="p">]</span>

        <span class="n">newfuncs</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([(</span><span class="bp">self</span><span class="o">.</span><span class="n">function</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">xvar</span><span class="p">,</span> <span class="n">fi</span><span class="p">)</span><span class="o">*</span><span class="n">fi</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
                        <span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">uvar</span><span class="p">)</span> <span class="k">for</span> <span class="n">fi</span> <span class="ow">in</span> <span class="n">f</span><span class="p">])</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">newfuncs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">filldedent</span><span class="p">(</span><span class="s1">&#39;&#39;&#39;</span>
<span class="s1">            The mapping between F(x) and f(u) did not give</span>
<span class="s1">            a unique integrand.&#39;&#39;&#39;</span><span class="p">))</span>
        <span class="n">newfunc</span> <span class="o">=</span> <span class="n">newfuncs</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>

        <span class="k">def</span> <span class="nf">_calc_limit_1</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            replace d with a, using subs if possible, otherwise limit</span>
<span class="sd">            where sign of b is considered</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">wok</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">wok</span> <span class="ow">is</span> <span class="n">S</span><span class="o">.</span><span class="n">NaN</span> <span class="ow">or</span> <span class="n">wok</span><span class="o">.</span><span class="n">is_bounded</span> <span class="ow">is</span> <span class="bp">False</span> <span class="ow">and</span> <span class="n">a</span><span class="o">.</span><span class="n">is_bounded</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">limit</span><span class="p">(</span><span class="n">sign</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">*</span><span class="n">F</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">wok</span>

        <span class="k">def</span> <span class="nf">_calc_limit</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            replace d with a, using subs if possible, otherwise limit</span>
<span class="sd">            where sign of b is considered</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">avals</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">([</span><span class="n">_calc_limit_1</span><span class="p">(</span><span class="n">Fi</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="k">for</span> <span class="n">Fi</span> <span class="ow">in</span> <span class="n">F</span><span class="p">]))</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">avals</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">filldedent</span><span class="p">(</span><span class="s1">&#39;&#39;&#39;</span>
<span class="s1">                The mapping between F(x) and f(u) did not</span>
<span class="s1">                give a unique limit.&#39;&#39;&#39;</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">avals</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">newlimits</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">xab</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">limits</span><span class="p">:</span>
            <span class="n">sym</span> <span class="o">=</span> <span class="n">xab</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">sym</span> <span class="o">==</span> <span class="n">xvar</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">xab</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                    <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">xab</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
                    <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">_calc_limit</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">),</span> <span class="n">_calc_limit</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">a</span> <span class="o">&gt;</span> <span class="n">b</span><span class="p">:</span>
                        <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">b</span><span class="p">,</span> <span class="n">a</span>
                        <span class="n">newfunc</span> <span class="o">=</span> <span class="o">-</span><span class="n">newfunc</span>
                    <span class="n">newlimits</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">uvar</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">))</span>
                <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">xab</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="n">a</span> <span class="o">=</span> <span class="n">_calc_limit</span><span class="p">(</span><span class="n">xab</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">1</span><span class="p">)</span>
                    <span class="n">newlimits</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">uvar</span><span class="p">,</span> <span class="n">a</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">newlimits</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">uvar</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">newlimits</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">xab</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">func</span><span class="p">(</span><span class="n">newfunc</span><span class="p">,</span> <span class="o">*</span><span class="n">newlimits</span><span class="p">)</span></div>

<div class="viewcode-block" id="Integral.doit"><a class="viewcode-back" href="../../../modules/integrals/integrals.html#sympy.integrals.Integral.doit">[docs]</a>    <span class="k">def</span> <span class="nf">doit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">hints</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Perform the integration using any hints given.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy import Integral</span>
<span class="sd">        &gt;&gt;&gt; from sympy.abc import x, i</span>
<span class="sd">        &gt;&gt;&gt; Integral(x**i, (i, 1, 3)).doit()</span>
<span class="sd">        Piecewise((2, log(x) == 0), (x**3/log(x) - x/log(x), True))</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        sympy.integrals.trigonometry.trigintegrate</span>
<span class="sd">        sympy.integrals.risch.heurisch</span>
<span class="sd">        sympy.integrals.rationaltools.ratint</span>
<span class="sd">        as_sum : Approximate the integral using a sum</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">hints</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;integrals&#39;</span><span class="p">,</span> <span class="bp">True</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span>

        <span class="n">deep</span> <span class="o">=</span> <span class="n">hints</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;deep&#39;</span><span class="p">,</span> <span class="bp">True</span><span class="p">)</span>
        <span class="n">meijerg</span> <span class="o">=</span> <span class="n">hints</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;meijerg&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
        <span class="n">conds</span> <span class="o">=</span> <span class="n">hints</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;conds&#39;</span><span class="p">,</span> <span class="s1">&#39;piecewise&#39;</span><span class="p">)</span>
        <span class="n">risch</span> <span class="o">=</span> <span class="n">hints</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;risch&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
        <span class="n">manual</span> <span class="o">=</span> <span class="n">hints</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;manual&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">conds</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;separate&#39;</span><span class="p">,</span> <span class="s1">&#39;piecewise&#39;</span><span class="p">,</span> <span class="s1">&#39;none&#39;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;conds must be one of &quot;separate&quot;, &quot;piecewise&quot;, &#39;</span>
                             <span class="s1">&#39;&quot;none&quot;, got: </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">conds</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">risch</span> <span class="ow">and</span> <span class="nb">any</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">xab</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">xab</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">limits</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;risch=True is only allowed for indefinite integrals.&#39;</span><span class="p">)</span>

        <span class="c1"># check for the trivial case of equal upper and lower limits</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_zero</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">S</span><span class="o">.</span><span class="n">Zero</span>

        <span class="c1"># now compute and check the function</span>
        <span class="n">function</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">function</span>
        <span class="k">if</span> <span class="n">deep</span><span class="p">:</span>
            <span class="n">function</span> <span class="o">=</span> <span class="n">function</span><span class="o">.</span><span class="n">doit</span><span class="p">(</span><span class="o">**</span><span class="n">hints</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">function</span><span class="o">.</span><span class="n">is_zero</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">S</span><span class="o">.</span><span class="n">Zero</span>

        <span class="c1"># There is no trivial answer, so continue</span>

        <span class="n">undone_limits</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># ulj = free symbols of any undone limits&#39; upper and lower limits</span>
        <span class="n">ulj</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">xab</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">limits</span><span class="p">:</span>
            <span class="c1"># compute uli, the free symbols in the</span>
            <span class="c1"># Upper and Lower limits of limit I</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">xab</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">uli</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">xab</span><span class="p">[:</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">xab</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">uli</span> <span class="o">=</span> <span class="n">xab</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">free_symbols</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">xab</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                <span class="n">uli</span> <span class="o">=</span> <span class="n">xab</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">free_symbols</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">xab</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">free_symbols</span><span class="p">)</span>
            <span class="c1"># this integral can be done as long as there is no blocking</span>
            <span class="c1"># limit that has been undone. An undone limit is blocking if</span>
            <span class="c1"># it contains an integration variable that is in this limit&#39;s</span>
            <span class="c1"># upper or lower free symbols or vice versa</span>
            <span class="k">if</span> <span class="n">xab</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="n">ulj</span> <span class="ow">or</span> <span class="nb">any</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="n">uli</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">undone_limits</span><span class="p">):</span>
                <span class="n">undone_limits</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">xab</span><span class="p">)</span>
                <span class="n">ulj</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">uli</span><span class="p">)</span>
                <span class="k">continue</span>

            <span class="c1"># There are a number of tradeoffs in using the meijer g method.</span>
            <span class="c1"># It can sometimes be a lot faster than other methods, and</span>
            <span class="c1"># sometimes slower. And there are certain types of integrals for</span>
            <span class="c1"># which it is more likely to work than others.</span>
            <span class="c1"># These heuristics are incorporated in deciding what integration</span>
            <span class="c1"># methods to try, in what order.</span>
            <span class="c1"># See the integrate() docstring for details.</span>
            <span class="k">def</span> <span class="nf">try_meijerg</span><span class="p">(</span><span class="n">function</span><span class="p">,</span> <span class="n">xab</span><span class="p">):</span>
                <span class="n">ret</span> <span class="o">=</span> <span class="bp">None</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">xab</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span> <span class="ow">and</span> <span class="n">meijerg</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">False</span><span class="p">:</span>
                    <span class="n">x</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">xab</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">res</span> <span class="o">=</span> <span class="n">meijerint_definite</span><span class="p">(</span><span class="n">function</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
                    <span class="k">except</span> <span class="ne">NotImplementedError</span><span class="p">:</span>
                        <span class="kn">from</span> <span class="nn">sympy.integrals.meijerint</span> <span class="kn">import</span> <span class="n">_debug</span>
                        <span class="n">_debug</span><span class="p">(</span><span class="s1">&#39;NotImplementedError from meijerint_definite&#39;</span><span class="p">)</span>
                        <span class="n">res</span> <span class="o">=</span> <span class="bp">None</span>
                    <span class="k">if</span> <span class="n">res</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                        <span class="n">f</span><span class="p">,</span> <span class="n">cond</span> <span class="o">=</span> <span class="n">res</span>
                        <span class="k">if</span> <span class="n">conds</span> <span class="o">==</span> <span class="s1">&#39;piecewise&#39;</span><span class="p">:</span>
                            <span class="n">ret</span> <span class="o">=</span> <span class="n">Piecewise</span><span class="p">((</span><span class="n">f</span><span class="p">,</span> <span class="n">cond</span><span class="p">),</span>
                                          <span class="p">(</span><span class="n">Integral</span><span class="p">(</span><span class="n">function</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)),</span> <span class="bp">True</span><span class="p">))</span>
                        <span class="k">elif</span> <span class="n">conds</span> <span class="o">==</span> <span class="s1">&#39;separate&#39;</span><span class="p">:</span>
                            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">limits</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;conds=separate not supported in &#39;</span>
                                                 <span class="s1">&#39;multiple integrals&#39;</span><span class="p">)</span>
                            <span class="n">ret</span> <span class="o">=</span> <span class="n">f</span><span class="p">,</span> <span class="n">cond</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">ret</span> <span class="o">=</span> <span class="n">f</span>
                <span class="k">return</span> <span class="n">ret</span>

            <span class="n">meijerg1</span> <span class="o">=</span> <span class="n">meijerg</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">xab</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span> <span class="ow">and</span> <span class="n">xab</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">is_real</span> <span class="ow">and</span> <span class="n">xab</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">is_real</span> \
                <span class="ow">and</span> <span class="ow">not</span> <span class="n">function</span><span class="o">.</span><span class="n">is_Poly</span> <span class="ow">and</span> \
                    <span class="p">(</span><span class="n">xab</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">oo</span><span class="p">,</span> <span class="o">-</span><span class="n">oo</span><span class="p">)</span> <span class="ow">or</span> <span class="n">xab</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">oo</span><span class="p">,</span> <span class="o">-</span><span class="n">oo</span><span class="p">)):</span>
                <span class="n">ret</span> <span class="o">=</span> <span class="n">try_meijerg</span><span class="p">(</span><span class="n">function</span><span class="p">,</span> <span class="n">xab</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">ret</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="n">function</span> <span class="o">=</span> <span class="n">ret</span>
                    <span class="k">continue</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">meijerg1</span> <span class="o">=</span> <span class="bp">False</span>

            <span class="c1"># If the special meijerg code did not succeed finding a definite</span>
            <span class="c1"># integral, then the code using meijerint_indefinite will not either</span>
            <span class="c1"># (it might find an antiderivative, but the answer is likely to be</span>
            <span class="c1">#  nonsensical).</span>
            <span class="c1"># Thus if we are requested to only use meijer g-function methods,</span>
            <span class="c1"># we give up at this stage. Otherwise we just disable g-function</span>
            <span class="c1"># methods.</span>
            <span class="k">if</span> <span class="n">meijerg1</span> <span class="ow">is</span> <span class="bp">False</span> <span class="ow">and</span> <span class="n">meijerg</span> <span class="ow">is</span> <span class="bp">True</span><span class="p">:</span>
                <span class="n">antideriv</span> <span class="o">=</span> <span class="bp">None</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">antideriv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_eval_integral</span><span class="p">(</span>
                    <span class="n">function</span><span class="p">,</span> <span class="n">xab</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                    <span class="n">meijerg</span><span class="o">=</span><span class="n">meijerg1</span><span class="p">,</span> <span class="n">risch</span><span class="o">=</span><span class="n">risch</span><span class="p">,</span> <span class="n">manual</span><span class="o">=</span><span class="n">manual</span><span class="p">,</span>
                    <span class="n">conds</span><span class="o">=</span><span class="n">conds</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">antideriv</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">and</span> <span class="n">meijerg1</span> <span class="ow">is</span> <span class="bp">True</span><span class="p">:</span>
                    <span class="n">ret</span> <span class="o">=</span> <span class="n">try_meijerg</span><span class="p">(</span><span class="n">function</span><span class="p">,</span> <span class="n">xab</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">ret</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                        <span class="n">function</span> <span class="o">=</span> <span class="n">ret</span>
                        <span class="k">continue</span>

            <span class="k">if</span> <span class="n">antideriv</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">undone_limits</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">xab</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">xab</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">function</span> <span class="o">=</span> <span class="n">antideriv</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">xab</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                        <span class="n">x</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">xab</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">xab</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                        <span class="n">x</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">xab</span>
                        <span class="n">a</span> <span class="o">=</span> <span class="bp">None</span>

                    <span class="k">if</span> <span class="n">deep</span><span class="p">:</span>
                        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">Basic</span><span class="p">):</span>
                            <span class="n">a</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">doit</span><span class="p">(</span><span class="o">**</span><span class="n">hints</span><span class="p">)</span>
                        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">Basic</span><span class="p">):</span>
                            <span class="n">b</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">doit</span><span class="p">(</span><span class="o">**</span><span class="n">hints</span><span class="p">)</span>

                    <span class="k">if</span> <span class="n">antideriv</span><span class="o">.</span><span class="n">is_Poly</span><span class="p">:</span>
                        <span class="n">gens</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">antideriv</span><span class="o">.</span><span class="n">gens</span><span class="p">)</span>
                        <span class="n">gens</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

                        <span class="n">antideriv</span> <span class="o">=</span> <span class="n">antideriv</span><span class="o">.</span><span class="n">as_expr</span><span class="p">()</span>

                        <span class="n">function</span> <span class="o">=</span> <span class="n">antideriv</span><span class="o">.</span><span class="n">_eval_interval</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
                        <span class="n">function</span> <span class="o">=</span> <span class="n">Poly</span><span class="p">(</span><span class="n">function</span><span class="p">,</span> <span class="o">*</span><span class="n">gens</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">try</span><span class="p">:</span>
                            <span class="n">function</span> <span class="o">=</span> <span class="n">antideriv</span><span class="o">.</span><span class="n">_eval_interval</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
                        <span class="k">except</span> <span class="ne">NotImplementedError</span><span class="p">:</span>
                            <span class="c1"># This can happen if _eval_interval depends in a</span>
                            <span class="c1"># complicated way on limits that cannot be computed</span>
                            <span class="n">undone_limits</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">xab</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">undone_limits</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="p">([</span><span class="n">function</span><span class="p">]</span> <span class="o">+</span> <span class="n">undone_limits</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">function</span></div>

    <span class="k">def</span> <span class="nf">_eval_adjoint</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">is_real</span><span class="p">,</span> <span class="n">flatten</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">limits</span><span class="p">))):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">func</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">function</span><span class="o">.</span><span class="n">adjoint</span><span class="p">(),</span> <span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">limits</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">None</span>

    <span class="k">def</span> <span class="nf">_eval_conjugate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">is_real</span><span class="p">,</span> <span class="n">flatten</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">limits</span><span class="p">))):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">func</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">function</span><span class="o">.</span><span class="n">conjugate</span><span class="p">(),</span> <span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">limits</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">None</span>

    <span class="k">def</span> <span class="nf">_eval_derivative</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sym</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Evaluate the derivative of the current Integral object by</span>
<span class="sd">        differentiating under the integral sign [1], using the Fundamental</span>
<span class="sd">        Theorem of Calculus [2] when possible.</span>

<span class="sd">        Whenever an Integral is encountered that is equivalent to zero or</span>
<span class="sd">        has an integrand that is independent of the variable of integration</span>
<span class="sd">        those integrals are performed. All others are returned as Integral</span>
<span class="sd">        instances which can be resolved with doit() (provided they are integrable).</span>

<span class="sd">        References:</span>
<span class="sd">           [1] http://en.wikipedia.org/wiki/Differentiation_under_the_integral_sign</span>
<span class="sd">           [2] http://en.wikipedia.org/wiki/Fundamental_theorem_of_calculus</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy import Integral</span>
<span class="sd">        &gt;&gt;&gt; from sympy.abc import x, y</span>
<span class="sd">        &gt;&gt;&gt; i = Integral(x + y, y, (y, 1, x))</span>
<span class="sd">        &gt;&gt;&gt; i.diff(x)</span>
<span class="sd">        Integral(x + y, (y, x)) + Integral(1, y, (y, 1, x))</span>
<span class="sd">        &gt;&gt;&gt; i.doit().diff(x) == i.diff(x).doit()</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; i.diff(y)</span>
<span class="sd">        0</span>

<span class="sd">        The previous must be true since there is no y in the evaluated integral:</span>
<span class="sd">        &gt;&gt;&gt; i.free_symbols</span>
<span class="sd">        set([x])</span>
<span class="sd">        &gt;&gt;&gt; i.doit()</span>
<span class="sd">        2*x**3/3 - x/2 - 1/6</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># differentiate under the integral sign; we do not</span>
        <span class="c1"># check for regularity conditions (TODO), see issue 1116</span>

        <span class="c1"># get limits and the function</span>
        <span class="n">f</span><span class="p">,</span> <span class="n">limits</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">function</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">limits</span><span class="p">)</span>

        <span class="c1"># the order matters if variables of integration appear in the limits</span>
        <span class="c1"># so work our way in from the outside to the inside.</span>
        <span class="n">limit</span> <span class="o">=</span> <span class="n">limits</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">limit</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">x</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">limit</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">limit</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">x</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">limit</span>
            <span class="n">a</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">b</span> <span class="o">=</span> <span class="bp">None</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">limit</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">limits</span><span class="p">:</span>  <span class="c1"># f is the argument to an integral</span>
            <span class="n">f</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">func</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="nb">tuple</span><span class="p">(</span><span class="n">limits</span><span class="p">))</span>

        <span class="c1"># assemble the pieces</span>
        <span class="k">def</span> <span class="nf">_do</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">ab</span><span class="p">):</span>
            <span class="n">dab_dsym</span> <span class="o">=</span> <span class="n">diff</span><span class="p">(</span><span class="n">ab</span><span class="p">,</span> <span class="n">sym</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">dab_dsym</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">S</span><span class="o">.</span><span class="n">Zero</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">Integral</span><span class="p">):</span>
                <span class="n">limits</span> <span class="o">=</span> <span class="p">[(</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">l</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">x</span><span class="p">)</span> <span class="k">else</span> <span class="n">l</span>
                          <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">f</span><span class="o">.</span><span class="n">limits</span><span class="p">]</span>
                <span class="n">f</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">func</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">function</span><span class="p">,</span> <span class="o">*</span><span class="n">limits</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">f</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">ab</span><span class="p">)</span><span class="o">*</span><span class="n">dab_dsym</span>
        <span class="n">rv</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">b</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">rv</span> <span class="o">+=</span> <span class="n">_do</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">a</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">rv</span> <span class="o">-=</span> <span class="n">_do</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">limit</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">sym</span> <span class="o">==</span> <span class="n">x</span><span class="p">:</span>
            <span class="c1"># the dummy variable *is* also the real-world variable</span>
            <span class="n">arg</span> <span class="o">=</span> <span class="n">f</span>
            <span class="n">rv</span> <span class="o">+=</span> <span class="n">arg</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># the dummy variable might match sym but it&#39;s</span>
            <span class="c1"># only a dummy and the actual variable is determined</span>
            <span class="c1"># by the limits, so mask off the variable of integration</span>
            <span class="c1"># while differentiating</span>
            <span class="n">u</span> <span class="o">=</span> <span class="n">Dummy</span><span class="p">(</span><span class="s1">&#39;u&#39;</span><span class="p">)</span>
            <span class="n">arg</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">sym</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
            <span class="n">rv</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">func</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">rv</span>

    <span class="k">def</span> <span class="nf">_eval_integral</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">meijerg</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">risch</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">manual</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                       <span class="n">conds</span><span class="o">=</span><span class="s1">&#39;piecewise&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the anti-derivative to the function f(x).</span>

<span class="sd">        The following algorithms are applied (roughly in this order):</span>

<span class="sd">        1. Simple heuristics (based on pattern matching and integral table):</span>

<span class="sd">           - most frequently used functions (e.g. polynomials, products of trig functions)</span>

<span class="sd">        2. Integration of rational functions:</span>

<span class="sd">           - A complete algorithm for integrating rational functions is</span>
<span class="sd">             implemented (the Lazard-Rioboo-Trager algorithm).  The algorithm</span>
<span class="sd">             also uses the partial fraction decomposition algorithm</span>
<span class="sd">             implemented in apart() as a preprocessor to make this process</span>
<span class="sd">             faster.  Note that the integral of a rational function is always</span>
<span class="sd">             elementary, but in general, it may include a RootSum.</span>

<span class="sd">        3. Full Risch algorithm:</span>

<span class="sd">           - The Risch algorithm is a complete decision</span>
<span class="sd">             procedure for integrating elementary functions, which means that</span>
<span class="sd">             given any elementary function, it will either compute an</span>
<span class="sd">             elementary antiderivative, or else prove that none exists.</span>
<span class="sd">             Currently, part of transcendental case is implemented, meaning</span>
<span class="sd">             elementary integrals containing exponentials, logarithms, and</span>
<span class="sd">             (soon!) trigonometric functions can be computed.  The algebraic</span>
<span class="sd">             case, e.g., functions containing roots, is much more difficult</span>
<span class="sd">             and is not implemented yet.</span>

<span class="sd">           - If the routine fails (because the integrand is not elementary, or</span>
<span class="sd">             because a case is not implemented yet), it continues on to the</span>
<span class="sd">             next algorithms below.  If the routine proves that the integrals</span>
<span class="sd">             is nonelementary, it still moves on to the algorithms below,</span>
<span class="sd">             because we might be able to find a closed-form solution in terms</span>
<span class="sd">             of special functions.  If risch=True, however, it will stop here.</span>

<span class="sd">        4. The Meijer G-Function algorithm:</span>

<span class="sd">           - This algorithm works by first rewriting the integrand in terms of</span>
<span class="sd">             very general Meijer G-Function (meijerg in SymPy), integrating</span>
<span class="sd">             it, and then rewriting the result back, if possible.  This</span>
<span class="sd">             algorithm is particularly powerful for definite integrals (which</span>
<span class="sd">             is actually part of a different method of Integral), since it can</span>
<span class="sd">             compute closed-form solutions of definite integrals even when no</span>
<span class="sd">             closed-form indefinite integral exists.  But it also is capable</span>
<span class="sd">             of computing many indefinite integrals as well.</span>

<span class="sd">           - Another advantage of this method is that it can use some results</span>
<span class="sd">             about the Meijer G-Function to give a result in terms of a</span>
<span class="sd">             Piecewise expression, which allows to express conditionally</span>
<span class="sd">             convergent integrals.</span>

<span class="sd">           - Setting meijerg=True will cause integrate() to use only this</span>
<span class="sd">             method.</span>

<span class="sd">        5. The &quot;manual integration&quot; algorithm:</span>

<span class="sd">           - This algorithm tries to mimic how a person would find an</span>
<span class="sd">             antiderivative by hand, for example by looking for a</span>
<span class="sd">             substitution or applying integration by parts. This algorithm</span>
<span class="sd">             does not handle as many integrands but can return results in a</span>
<span class="sd">             more familiar form.</span>

<span class="sd">           - Sometimes this algorithm can evaluate parts of an integral; in</span>
<span class="sd">             this case integrate() will try to evaluate the rest of the</span>
<span class="sd">             integrand using the other methods here.</span>

<span class="sd">           - Setting manual=True will cause integrate() to use only this</span>
<span class="sd">             method.</span>

<span class="sd">        6. The Heuristic Risch algorithm:</span>

<span class="sd">           - This is a heuristic version of the Risch algorithm, meaning that</span>
<span class="sd">             it is not deterministic.  This is tried as a last resort because</span>
<span class="sd">             it can be very slow.  It is still used because not enough of the</span>
<span class="sd">             full Risch algorithm is implemented, so that there are still some</span>
<span class="sd">             integrals that can only be computed using this method.  The goal</span>
<span class="sd">             is to implement enough of the Risch and Meijer G methods so that</span>
<span class="sd">             this can be deleted.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">sympy.integrals.risch</span> <span class="kn">import</span> <span class="n">risch_integrate</span>

        <span class="k">if</span> <span class="n">risch</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">risch_integrate</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">conds</span><span class="o">=</span><span class="n">conds</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">NotImplementedError</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">None</span>

        <span class="k">if</span> <span class="n">manual</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">manualintegrate</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">result</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> <span class="n">result</span><span class="o">.</span><span class="n">func</span> <span class="o">!=</span> <span class="n">Integral</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">result</span>
            <span class="k">except</span> <span class="p">(</span><span class="ne">ValueError</span><span class="p">,</span> <span class="n">PolynomialError</span><span class="p">):</span>
                <span class="k">pass</span>


        <span class="c1"># if it is a poly(x) then let the polynomial integrate itself (fast)</span>
        <span class="c1">#</span>
        <span class="c1"># It is important to make this check first, otherwise the other code</span>
        <span class="c1"># will return a sympy expression instead of a Polynomial.</span>
        <span class="c1">#</span>
        <span class="c1"># see Polynomial for details.</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">Poly</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">meijerg</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">f</span><span class="o">.</span><span class="n">integrate</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

        <span class="c1"># Piecewise antiderivatives need to call special integrate.</span>
        <span class="k">if</span> <span class="n">f</span><span class="o">.</span><span class="n">func</span> <span class="ow">is</span> <span class="n">Piecewise</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">f</span><span class="o">.</span><span class="n">_eval_integral</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

        <span class="c1"># let&#39;s cut it short if `f` does not depend on `x`</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">f</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">f</span><span class="o">*</span><span class="n">x</span>

        <span class="c1"># try to convert to poly(x) and then integrate if successful (fast)</span>
        <span class="n">poly</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">as_poly</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">poly</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">meijerg</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">poly</span><span class="o">.</span><span class="n">integrate</span><span class="p">()</span><span class="o">.</span><span class="n">as_expr</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">risch</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">False</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">result</span><span class="p">,</span> <span class="n">i</span> <span class="o">=</span> <span class="n">risch_integrate</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">separate_integral</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">conds</span><span class="o">=</span><span class="n">conds</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">NotImplementedError</span><span class="p">:</span>
                <span class="k">pass</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">i</span><span class="p">:</span>
                    <span class="c1"># There was a nonelementary integral. Try integrating it.</span>
                    <span class="k">return</span> <span class="n">result</span> <span class="o">+</span> <span class="n">i</span><span class="o">.</span><span class="n">doit</span><span class="p">(</span><span class="n">risch</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">result</span>

        <span class="c1"># since Integral(f=g1+g2+...) == Integral(g1) + Integral(g2) + ...</span>
        <span class="c1"># we are going to handle Add terms separately,</span>
        <span class="c1"># if `f` is not Add -- we only have one term</span>

        <span class="c1"># Note that in general, this is a bad idea, because Integral(g1) +</span>
        <span class="c1"># Integral(g2) might not be computable, even if Integral(g1 + g2) is.</span>
        <span class="c1"># For example, Integral(x**x + x**x*log(x)).  But many heuristics only</span>
        <span class="c1"># work term-wise.  So we compute this step last, after trying</span>
        <span class="c1"># risch_integrate.  We also try risch_integrate again in this loop,</span>
        <span class="c1"># because maybe the integral is a sum of an elementary part and a</span>
        <span class="c1"># nonelementary part (like erf(x) + exp(x)).  risch_integrate() is</span>
        <span class="c1"># quite fast, so this is acceptable.</span>
        <span class="n">parts</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">args</span> <span class="o">=</span> <span class="n">Add</span><span class="o">.</span><span class="n">make_args</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
            <span class="n">coeff</span><span class="p">,</span> <span class="n">g</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">as_independent</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

            <span class="c1"># g(x) = const</span>
            <span class="k">if</span> <span class="n">g</span> <span class="ow">is</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">meijerg</span><span class="p">:</span>
                <span class="n">parts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">coeff</span><span class="o">*</span><span class="n">x</span><span class="p">)</span>
                <span class="k">continue</span>

            <span class="c1"># g(x) = expr + O(x**n)</span>
            <span class="n">order_term</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">getO</span><span class="p">()</span>

            <span class="k">if</span> <span class="n">order_term</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">h</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_eval_integral</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">removeO</span><span class="p">(),</span> <span class="n">x</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">h</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="n">h_order_expr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_eval_integral</span><span class="p">(</span><span class="n">order_term</span><span class="o">.</span><span class="n">expr</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>

                    <span class="k">if</span> <span class="n">h_order_expr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                        <span class="n">h_order_term</span> <span class="o">=</span> <span class="n">order_term</span><span class="o">.</span><span class="n">func</span><span class="p">(</span>
                            <span class="n">h_order_expr</span><span class="p">,</span> <span class="o">*</span><span class="n">order_term</span><span class="o">.</span><span class="n">variables</span><span class="p">)</span>
                        <span class="n">parts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">coeff</span><span class="o">*</span><span class="p">(</span><span class="n">h</span> <span class="o">+</span> <span class="n">h_order_term</span><span class="p">))</span>
                        <span class="k">continue</span>

                <span class="c1"># NOTE: if there is O(x**n) and we fail to integrate then there is</span>
                <span class="c1"># no point in trying other methods because they will fail anyway.</span>
                <span class="k">return</span> <span class="bp">None</span>

            <span class="c1">#               c</span>
            <span class="c1"># g(x) = (a*x+b)</span>
            <span class="k">if</span> <span class="n">g</span><span class="o">.</span><span class="n">is_Pow</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">g</span><span class="o">.</span><span class="n">exp</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">meijerg</span><span class="p">:</span>
                <span class="n">a</span> <span class="o">=</span> <span class="n">Wild</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="n">exclude</span><span class="o">=</span><span class="p">[</span><span class="n">x</span><span class="p">])</span>
                <span class="n">b</span> <span class="o">=</span> <span class="n">Wild</span><span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="n">exclude</span><span class="o">=</span><span class="p">[</span><span class="n">x</span><span class="p">])</span>

                <span class="n">M</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">b</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">M</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">g</span><span class="o">.</span><span class="n">exp</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                        <span class="n">h</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">base</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="n">conds</span> <span class="o">!=</span> <span class="s1">&#39;piecewise&#39;</span><span class="p">:</span>
                        <span class="n">h</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">base</span><span class="o">**</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">exp</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">exp</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">h1</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">base</span><span class="p">)</span>
                        <span class="n">h2</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">base</span><span class="o">**</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">exp</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">exp</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                        <span class="n">h</span> <span class="o">=</span> <span class="n">Piecewise</span><span class="p">((</span><span class="n">h1</span><span class="p">,</span> <span class="n">Eq</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">exp</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)),</span> <span class="p">(</span><span class="n">h2</span><span class="p">,</span> <span class="bp">True</span><span class="p">))</span>

                    <span class="n">parts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">coeff</span> <span class="o">*</span> <span class="n">h</span> <span class="o">/</span> <span class="n">M</span><span class="p">[</span><span class="n">a</span><span class="p">])</span>
                    <span class="k">continue</span>

            <span class="c1">#        poly(x)</span>
            <span class="c1"># g(x) = -------</span>
            <span class="c1">#        poly(x)</span>
            <span class="k">if</span> <span class="n">g</span><span class="o">.</span><span class="n">is_rational_function</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">meijerg</span><span class="p">:</span>
                <span class="n">parts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">coeff</span> <span class="o">*</span> <span class="n">ratint</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">x</span><span class="p">))</span>
                <span class="k">continue</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">meijerg</span><span class="p">:</span>
                <span class="c1"># g(x) = Mul(trig)</span>
                <span class="n">h</span> <span class="o">=</span> <span class="n">trigintegrate</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">conds</span><span class="o">=</span><span class="n">conds</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">h</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="n">parts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">coeff</span> <span class="o">*</span> <span class="n">h</span><span class="p">)</span>
                    <span class="k">continue</span>

                <span class="c1"># g(x) has at least a DiracDelta term</span>
                <span class="n">h</span> <span class="o">=</span> <span class="n">deltaintegrate</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">h</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="n">parts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">coeff</span> <span class="o">*</span> <span class="n">h</span><span class="p">)</span>
                    <span class="k">continue</span>

                <span class="c1"># Try risch again.</span>
                <span class="k">if</span> <span class="n">risch</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">False</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">h</span><span class="p">,</span> <span class="n">i</span> <span class="o">=</span> <span class="n">risch_integrate</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">separate_integral</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">conds</span><span class="o">=</span><span class="n">conds</span><span class="p">)</span>
                    <span class="k">except</span> <span class="ne">NotImplementedError</span><span class="p">:</span>
                        <span class="n">h</span> <span class="o">=</span> <span class="bp">None</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">i</span><span class="p">:</span>
                            <span class="n">h</span> <span class="o">=</span> <span class="n">h</span> <span class="o">+</span> <span class="n">i</span><span class="o">.</span><span class="n">doit</span><span class="p">(</span><span class="n">risch</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>

                        <span class="n">parts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">coeff</span><span class="o">*</span><span class="n">h</span><span class="p">)</span>
                        <span class="k">continue</span>

                <span class="c1"># fall back to heurisch</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">conds</span> <span class="o">==</span> <span class="s1">&#39;piecewise&#39;</span><span class="p">:</span>
                        <span class="n">h</span> <span class="o">=</span> <span class="n">heurisch_wrapper</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">hints</span><span class="o">=</span><span class="p">[])</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">h</span> <span class="o">=</span> <span class="n">heurisch</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">hints</span><span class="o">=</span><span class="p">[])</span>
                <span class="k">except</span> <span class="n">PolynomialError</span><span class="p">:</span>
                    <span class="c1"># XXX: this exception means there is a bug in the</span>
                    <span class="c1"># implementation of heuristic Risch integration</span>
                    <span class="c1"># algorithm.</span>
                    <span class="n">h</span> <span class="o">=</span> <span class="bp">None</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">h</span> <span class="o">=</span> <span class="bp">None</span>

            <span class="k">if</span> <span class="n">meijerg</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">False</span> <span class="ow">and</span> <span class="n">h</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="c1"># rewrite using G functions</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">h</span> <span class="o">=</span> <span class="n">meijerint_indefinite</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">NotImplementedError</span><span class="p">:</span>
                    <span class="kn">from</span> <span class="nn">sympy.integrals.meijerint</span> <span class="kn">import</span> <span class="n">_debug</span>
                    <span class="n">_debug</span><span class="p">(</span><span class="s1">&#39;NotImplementedError from meijerint_definite&#39;</span><span class="p">)</span>
                    <span class="n">res</span> <span class="o">=</span> <span class="bp">None</span>
                <span class="k">if</span> <span class="n">h</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="n">parts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">coeff</span> <span class="o">*</span> <span class="n">h</span><span class="p">)</span>
                    <span class="k">continue</span>

            <span class="k">if</span> <span class="n">h</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">and</span> <span class="n">manual</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">False</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">result</span> <span class="o">=</span> <span class="n">manualintegrate</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">result</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">Integral</span><span class="p">):</span>
                        <span class="k">if</span> <span class="n">result</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">Integral</span><span class="p">):</span>
                            <span class="c1"># try to have other algorithms do the integrals</span>
                            <span class="c1"># manualintegrate can&#39;t handle</span>
                            <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="p">[</span>
                                <span class="n">arg</span><span class="o">.</span><span class="n">doit</span><span class="p">(</span><span class="n">manual</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span> <span class="k">if</span> <span class="n">arg</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">Integral</span><span class="p">)</span> <span class="k">else</span> <span class="n">arg</span>
                                <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">result</span><span class="o">.</span><span class="n">args</span>
                            <span class="p">])</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="n">multinomial</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                                      <span class="n">log</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                                      <span class="n">power_exp</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                                      <span class="n">power_base</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="n">result</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">Integral</span><span class="p">):</span>
                            <span class="n">parts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">coeff</span> <span class="o">*</span> <span class="n">result</span><span class="p">)</span>
                            <span class="k">continue</span>
                <span class="k">except</span> <span class="p">(</span><span class="ne">ValueError</span><span class="p">,</span> <span class="n">PolynomialError</span><span class="p">):</span>
                    <span class="c1"># can&#39;t handle some SymPy expressions</span>
                    <span class="k">pass</span>

            <span class="c1"># if we failed maybe it was because we had</span>
            <span class="c1"># a product that could have been expanded,</span>
            <span class="c1"># so let&#39;s try an expansion of the whole</span>
            <span class="c1"># thing before giving up; we don&#39;t try this</span>
            <span class="c1"># out the outset because there are things</span>
            <span class="c1"># that cannot be solved unless they are</span>
            <span class="c1"># NOT expanded e.g., x**x*(1+log(x)). There</span>
            <span class="c1"># should probably be a checker somewhere in this</span>
            <span class="c1"># routine to look for such cases and try to do</span>
            <span class="c1"># collection on the expressions if they are already</span>
            <span class="c1"># in an expanded form</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">h</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">f</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="n">mul</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">f</span><span class="o">.</span><span class="n">is_Add</span><span class="p">:</span>
                    <span class="c1"># Note: risch will be identical on the expanded</span>
                    <span class="c1"># expression, but maybe it will be able to pick out parts,</span>
                    <span class="c1"># like x*(exp(x) + erf(x)).</span>
                    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_eval_integral</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">meijerg</span><span class="o">=</span><span class="n">meijerg</span><span class="p">,</span> <span class="n">risch</span><span class="o">=</span><span class="n">risch</span><span class="p">,</span> <span class="n">conds</span><span class="o">=</span><span class="n">conds</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">h</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">parts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">coeff</span> <span class="o">*</span> <span class="n">h</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">None</span>

        <span class="k">return</span> <span class="n">Add</span><span class="p">(</span><span class="o">*</span><span class="n">parts</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_eval_lseries</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">term</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">function</span><span class="o">.</span><span class="n">lseries</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="k">yield</span> <span class="n">integrate</span><span class="p">(</span><span class="n">term</span><span class="p">,</span> <span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">limits</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_eval_nseries</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">logx</span><span class="p">):</span>
        <span class="n">terms</span><span class="p">,</span> <span class="n">order</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">function</span><span class="o">.</span><span class="n">nseries</span><span class="p">(</span>
            <span class="n">x</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="p">,</span> <span class="n">logx</span><span class="o">=</span><span class="n">logx</span><span class="p">)</span><span class="o">.</span><span class="n">as_coeff_add</span><span class="p">(</span><span class="n">C</span><span class="o">.</span><span class="n">Order</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">integrate</span><span class="p">(</span><span class="n">terms</span><span class="p">,</span> <span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">limits</span><span class="p">)</span> <span class="o">+</span> <span class="n">Add</span><span class="p">(</span><span class="o">*</span><span class="n">order</span><span class="p">)</span><span class="o">*</span><span class="n">x</span>

    <span class="k">def</span> <span class="nf">_eval_subs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">old</span><span class="p">,</span> <span class="n">new</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">_eval_subs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">old</span><span class="p">,</span> <span class="n">new</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_eval_transpose</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">is_real</span><span class="p">,</span> <span class="n">flatten</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">limits</span><span class="p">))):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">func</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">function</span><span class="o">.</span><span class="n">transpose</span><span class="p">(),</span> <span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">limits</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">None</span>

<div class="viewcode-block" id="Integral.as_sum"><a class="viewcode-back" href="../../../modules/integrals/integrals.html#sympy.integrals.Integral.as_sum">[docs]</a>    <span class="k">def</span> <span class="nf">as_sum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;midpoint&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Approximates the definite integral by a sum.</span>

<span class="sd">        method ... one of: left, right, midpoint, trapezoid</span>

<span class="sd">        These are all basically the rectangle method [1], the only difference</span>
<span class="sd">        is where the function value is taken in each interval to define the</span>
<span class="sd">        rectangle.</span>

<span class="sd">        [1] http://en.wikipedia.org/wiki/Rectangle_method</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy import sin, sqrt</span>
<span class="sd">        &gt;&gt;&gt; from sympy.abc import x</span>
<span class="sd">        &gt;&gt;&gt; from sympy.integrals import Integral</span>
<span class="sd">        &gt;&gt;&gt; e = Integral(sin(x), (x, 3, 7))</span>
<span class="sd">        &gt;&gt;&gt; e</span>
<span class="sd">        Integral(sin(x), (x, 3, 7))</span>

<span class="sd">        For demonstration purposes, this interval will only be split into 2</span>
<span class="sd">        regions, bounded by [3, 5] and [5, 7].</span>

<span class="sd">        The left-hand rule uses function evaluations at the left of each</span>
<span class="sd">        interval:</span>

<span class="sd">        &gt;&gt;&gt; e.as_sum(2, &#39;left&#39;)</span>
<span class="sd">        2*sin(5) + 2*sin(3)</span>

<span class="sd">        The midpoint rule uses evaluations at the center of each interval:</span>

<span class="sd">        &gt;&gt;&gt; e.as_sum(2, &#39;midpoint&#39;)</span>
<span class="sd">        2*sin(4) + 2*sin(6)</span>

<span class="sd">        The right-hand rule uses function evaluations at the right of each</span>
<span class="sd">        interval:</span>

<span class="sd">        &gt;&gt;&gt; e.as_sum(2, &#39;right&#39;)</span>
<span class="sd">        2*sin(5) + 2*sin(7)</span>

<span class="sd">        The trapezoid rule uses function evaluations on both sides of the</span>
<span class="sd">        intervals. This is equivalent to taking the average of the left and</span>
<span class="sd">        right hand rule results:</span>

<span class="sd">        &gt;&gt;&gt; e.as_sum(2, &#39;trapezoid&#39;)</span>
<span class="sd">        2*sin(5) + sin(3) + sin(7)</span>
<span class="sd">        &gt;&gt;&gt; (e.as_sum(2, &#39;left&#39;) + e.as_sum(2, &#39;right&#39;))/2 == _</span>
<span class="sd">        True</span>

<span class="sd">        All but the trapexoid method may be used when dealing with a function</span>
<span class="sd">        with a discontinuity. Here, the discontinuity at x = 0 can be avoided</span>
<span class="sd">        by using the midpoint or right-hand method:</span>

<span class="sd">        &gt;&gt;&gt; e = Integral(1/sqrt(x), (x, 0, 1))</span>
<span class="sd">        &gt;&gt;&gt; e.as_sum(5).n(4)</span>
<span class="sd">        1.730</span>
<span class="sd">        &gt;&gt;&gt; e.as_sum(10).n(4)</span>
<span class="sd">        1.809</span>
<span class="sd">        &gt;&gt;&gt; e.doit().n(4)  # the actual value is 2</span>
<span class="sd">        2.000</span>

<span class="sd">        The left- or trapezoid method will encounter the discontinuity and</span>
<span class="sd">        return oo:</span>

<span class="sd">        &gt;&gt;&gt; e.as_sum(5, &#39;left&#39;)</span>
<span class="sd">        oo</span>
<span class="sd">        &gt;&gt;&gt; e.as_sum(5, &#39;trapezoid&#39;)</span>
<span class="sd">        oo</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        Integral.doit : Perform the integration using any hints</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">limits</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">limits</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">limits</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                <span class="s2">&quot;Multidimensional midpoint rule not implemented yet&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">limit</span> <span class="o">=</span> <span class="n">limits</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">limit</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Expecting a definite integral.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;n must be &gt; 0&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="n">oo</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Infinite summation not yet implemented&quot;</span><span class="p">)</span>
        <span class="n">sym</span><span class="p">,</span> <span class="n">lower_limit</span><span class="p">,</span> <span class="n">upper_limit</span> <span class="o">=</span> <span class="n">limit</span>
        <span class="n">dx</span> <span class="o">=</span> <span class="p">(</span><span class="n">upper_limit</span> <span class="o">-</span> <span class="n">lower_limit</span><span class="p">)</span><span class="o">/</span><span class="n">n</span>

        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;trapezoid&#39;</span><span class="p">:</span>
            <span class="n">l</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">function</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">sym</span><span class="p">,</span> <span class="n">lower_limit</span><span class="p">)</span>
            <span class="n">r</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">function</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">sym</span><span class="p">,</span> <span class="n">upper_limit</span><span class="p">)</span>
            <span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="n">l</span> <span class="o">+</span> <span class="n">r</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">lower_limit</span> <span class="o">+</span> <span class="n">i</span><span class="o">*</span><span class="n">dx</span>
                <span class="n">result</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">function</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">sym</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">result</span><span class="o">*</span><span class="n">dx</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;left&#39;</span><span class="p">,</span> <span class="s1">&#39;right&#39;</span><span class="p">,</span> <span class="s1">&#39;midpoint&#39;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Unknown method </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">method</span><span class="p">)</span>

        <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;midpoint&quot;</span><span class="p">:</span>
                <span class="n">xi</span> <span class="o">=</span> <span class="n">lower_limit</span> <span class="o">+</span> <span class="n">i</span><span class="o">*</span><span class="n">dx</span> <span class="o">+</span> <span class="n">dx</span><span class="o">/</span><span class="mi">2</span>
            <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;left&quot;</span><span class="p">:</span>
                <span class="n">xi</span> <span class="o">=</span> <span class="n">lower_limit</span> <span class="o">+</span> <span class="n">i</span><span class="o">*</span><span class="n">dx</span>
            <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;right&quot;</span><span class="p">:</span>
                <span class="n">xi</span> <span class="o">=</span> <span class="n">lower_limit</span> <span class="o">+</span> <span class="n">i</span><span class="o">*</span><span class="n">dx</span> <span class="o">+</span> <span class="n">dx</span>
            <span class="n">result</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">function</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">sym</span><span class="p">,</span> <span class="n">xi</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span><span class="o">*</span><span class="n">dx</span></div></div>


<span class="nd">@xthreaded</span>
<div class="viewcode-block" id="integrate"><a class="viewcode-back" href="../../../modules/integrals/integrals.html#sympy.integrals.integrate">[docs]</a><span class="k">def</span> <span class="nf">integrate</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;integrate(f, var, ...)</span>

<span class="sd">    Compute definite or indefinite integral of one or more variables</span>
<span class="sd">    using Risch-Norman algorithm and table lookup. This procedure is</span>
<span class="sd">    able to handle elementary algebraic and transcendental functions</span>
<span class="sd">    and also a huge class of special functions, including Airy,</span>
<span class="sd">    Bessel, Whittaker and Lambert.</span>

<span class="sd">    var can be:</span>

<span class="sd">    - a symbol                   -- indefinite integration</span>
<span class="sd">    - a tuple (symbol, a)        -- indefinite integration with result</span>
<span class="sd">                                    given with `a` replacing `symbol`</span>
<span class="sd">    - a tuple (symbol, a, b)     -- definite integration</span>

<span class="sd">    Several variables can be specified, in which case the result is</span>
<span class="sd">    multiple integration. (If var is omitted and the integrand is</span>
<span class="sd">    univariate, the indefinite integral in that variable will be performed.)</span>

<span class="sd">    Indefinite integrals are returned without terms that are independent</span>
<span class="sd">    of the integration variables. (see examples)</span>

<span class="sd">    Definite improper integrals often entail delicate convergence</span>
<span class="sd">    conditions. Pass conds=&#39;piecewise&#39;, &#39;separate&#39; or &#39;none&#39; to have</span>
<span class="sd">    these returned, respectively, as a Piecewise function, as a separate</span>
<span class="sd">    result (i.e. result will be a tuple), or not at all (default is</span>
<span class="sd">    &#39;piecewise&#39;).</span>

<span class="sd">    **Strategy**</span>

<span class="sd">    SymPy uses various approaches to definite integration. One method is to</span>
<span class="sd">    find an antiderivative for the integrand, and then use the fundamental</span>
<span class="sd">    theorem of calculus. Various functions are implemented to integrate</span>
<span class="sd">    polynomial, rational and trigonometric functions, and integrands</span>
<span class="sd">    containing DiracDelta terms.</span>

<span class="sd">    SymPy also implements the part of the Risch algorithm, which is a decision</span>
<span class="sd">    procedure for integrating elementary functions, i.e., the algorithm can</span>
<span class="sd">    either find an elementary antiderivative, or prove that one does not</span>
<span class="sd">    exist.  There is also a (very successful, albeit somewhat slow) general</span>
<span class="sd">    implementation of the heuristic Risch algorithm.  This algorithm will</span>
<span class="sd">    eventually be phased out as more of the full Risch algorithm is</span>
<span class="sd">    implemented. See the docstring of Integral._eval_integral() for more</span>
<span class="sd">    details on computing the antiderivative using algebraic methods.</span>

<span class="sd">    The option risch=True can be used to use only the (full) Risch algorithm.</span>
<span class="sd">    This is useful if you want to know if an elementary function has an</span>
<span class="sd">    elementary antiderivative.  If the indefinite Integral returned by this</span>
<span class="sd">    function is an instance of NonElementaryIntegral, that means that the</span>
<span class="sd">    Risch algorithm has proven that integral to be non-elementary.  Note that</span>
<span class="sd">    by default, additional methods (such as the Meijer G method outlined</span>
<span class="sd">    below) are tried on these integrals, as they may be expressible in terms</span>
<span class="sd">    of special functions, so if you only care about elementary answers, use</span>
<span class="sd">    risch=True.  Also note that an unevaluated Integral returned by this</span>
<span class="sd">    function is not necessarily a NonElementaryIntegral, even with risch=True,</span>
<span class="sd">    as it may just be an indication that the particular part of the Risch</span>
<span class="sd">    algorithm needed to integrate that function is not yet implemented.</span>

<span class="sd">    Another family of strategies comes from re-writing the integrand in</span>
<span class="sd">    terms of so-called Meijer G-functions. Indefinite integrals of a</span>
<span class="sd">    single G-function can always be computed, and the definite integral</span>
<span class="sd">    of a product of two G-functions can be computed from zero to</span>
<span class="sd">    infinity. Various strategies are implemented to rewrite integrands</span>
<span class="sd">    as G-functions, and use this information to compute integrals (see</span>
<span class="sd">    the ``meijerint`` module).</span>

<span class="sd">    The option manual=True can be used to use only an algorithm that tries</span>
<span class="sd">    to mimic integration by hand. This algorithm does not handle as many</span>
<span class="sd">    integrands as the other algorithms implemented but may return results in</span>
<span class="sd">    a more familiar form. The ``manualintegrate`` module has functions that</span>
<span class="sd">    return the steps used (see the module docstring for more information).</span>

<span class="sd">    In general, the algebraic methods work best for computing</span>
<span class="sd">    antiderivatives of (possibly complicated) combinations of elementary</span>
<span class="sd">    functions. The G-function methods work best for computing definite</span>
<span class="sd">    integrals from zero to infinity of moderately complicated</span>
<span class="sd">    combinations of special functions, or indefinite integrals of very</span>
<span class="sd">    simple combinations of special functions.</span>

<span class="sd">    The strategy employed by the integration code is as follows:</span>

<span class="sd">    - If computing a definite integral, and both limits are real,</span>
<span class="sd">      and at least one limit is +- oo, try the G-function method of</span>
<span class="sd">      definite integration first.</span>

<span class="sd">    - Try to find an antiderivative, using all available methods, ordered</span>
<span class="sd">      by performance (that is try fastest method first, slowest last; in</span>
<span class="sd">      particular polynomial integration is tried first, meijer</span>
<span class="sd">      g-functions second to last, and heuristic risch last).</span>

<span class="sd">    - If still not successful, try G-functions irrespective of the</span>
<span class="sd">      limits.</span>

<span class="sd">    The option meijerg=True, False, None can be used to, respectively:</span>
<span class="sd">    always use G-function methods and no others, never use G-function</span>
<span class="sd">    methods, or use all available methods (in order as described above).</span>
<span class="sd">    It defaults to None.</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy import integrate, log, exp, oo</span>
<span class="sd">    &gt;&gt;&gt; from sympy.abc import a, x, y</span>

<span class="sd">    &gt;&gt;&gt; integrate(x*y, x)</span>
<span class="sd">    x**2*y/2</span>

<span class="sd">    &gt;&gt;&gt; integrate(log(x), x)</span>
<span class="sd">    x*log(x) - x</span>

<span class="sd">    &gt;&gt;&gt; integrate(log(x), (x, 1, a))</span>
<span class="sd">    a*log(a) - a + 1</span>

<span class="sd">    &gt;&gt;&gt; integrate(x)</span>
<span class="sd">    x**2/2</span>

<span class="sd">    Terms that are independent of x are dropped by indefinite integration:</span>

<span class="sd">    &gt;&gt;&gt; from sympy import sqrt</span>
<span class="sd">    &gt;&gt;&gt; integrate(sqrt(1 + x), (x, 0, x))</span>
<span class="sd">    2*(x + 1)**(3/2)/3 - 2/3</span>
<span class="sd">    &gt;&gt;&gt; integrate(sqrt(1 + x), x)</span>
<span class="sd">    2*(x + 1)**(3/2)/3</span>

<span class="sd">    &gt;&gt;&gt; integrate(x*y)</span>
<span class="sd">    Traceback (most recent call last):</span>
<span class="sd">    ...</span>
<span class="sd">    ValueError: specify integration variables to integrate x*y</span>

<span class="sd">    Note that ``integrate(x)`` syntax is meant only for convenience</span>
<span class="sd">    in interactive sessions and should be avoided in library code.</span>

<span class="sd">    &gt;&gt;&gt; integrate(x**a*exp(-x), (x, 0, oo)) # same as conds=&#39;piecewise&#39;</span>
<span class="sd">    Piecewise((gamma(a + 1), -re(a) &lt; 1),</span>
<span class="sd">        (Integral(x**a*exp(-x), (x, 0, oo)), True))</span>

<span class="sd">    &gt;&gt;&gt; integrate(x**a*exp(-x), (x, 0, oo), conds=&#39;none&#39;)</span>
<span class="sd">    gamma(a + 1)</span>

<span class="sd">    &gt;&gt;&gt; integrate(x**a*exp(-x), (x, 0, oo), conds=&#39;separate&#39;)</span>
<span class="sd">    (gamma(a + 1), -re(a) &lt; 1)</span>

<span class="sd">    See Also</span>
<span class="sd">    ========</span>

<span class="sd">    Integral, Integral.doit</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">meijerg</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;meijerg&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
    <span class="n">conds</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;conds&#39;</span><span class="p">,</span> <span class="s1">&#39;piecewise&#39;</span><span class="p">)</span>
    <span class="n">risch</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;risch&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
    <span class="n">manual</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;manual&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
    <span class="n">integral</span> <span class="o">=</span> <span class="n">Integral</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">integral</span><span class="p">,</span> <span class="n">Integral</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">integral</span><span class="o">.</span><span class="n">doit</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">meijerg</span><span class="o">=</span><span class="n">meijerg</span><span class="p">,</span> <span class="n">conds</span><span class="o">=</span><span class="n">conds</span><span class="p">,</span>
                             <span class="n">risch</span><span class="o">=</span><span class="n">risch</span><span class="p">,</span> <span class="n">manual</span><span class="o">=</span><span class="n">manual</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">integral</span></div>


<span class="nd">@xthreaded</span>
<div class="viewcode-block" id="line_integrate"><a class="viewcode-back" href="../../../modules/integrals/integrals.html#sympy.integrals.line_integrate">[docs]</a><span class="k">def</span> <span class="nf">line_integrate</span><span class="p">(</span><span class="n">field</span><span class="p">,</span> <span class="n">curve</span><span class="p">,</span> <span class="nb">vars</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;line_integrate(field, Curve, variables)</span>

<span class="sd">    Compute the line integral.</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy import Curve, line_integrate, E, ln</span>
<span class="sd">    &gt;&gt;&gt; from sympy.abc import x, y, t</span>
<span class="sd">    &gt;&gt;&gt; C = Curve([E**t + 1, E**t - 1], (t, 0, ln(2)))</span>
<span class="sd">    &gt;&gt;&gt; line_integrate(x + y, C, [x, y])</span>
<span class="sd">    3*sqrt(2)</span>

<span class="sd">    See Also</span>
<span class="sd">    ========</span>

<span class="sd">    integrate, Integral</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">F</span> <span class="o">=</span> <span class="n">sympify</span><span class="p">(</span><span class="n">field</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">F</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;Expecting function specifying field as first argument.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">curve</span><span class="p">,</span> <span class="n">Curve</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Expecting Curve entity as second argument.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">is_sequence</span><span class="p">(</span><span class="nb">vars</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Expecting ordered iterable for variables.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">curve</span><span class="o">.</span><span class="n">functions</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">vars</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Field variable size does not match curve dimension.&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">curve</span><span class="o">.</span><span class="n">parameter</span> <span class="ow">in</span> <span class="nb">vars</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Curve parameter clashes with field parameters.&quot;</span><span class="p">)</span>

    <span class="c1"># Calculate derivatives for line parameter functions</span>
    <span class="c1"># F(r) -&gt; F(r(t)) and finally F(r(t)*r&#39;(t))</span>
    <span class="n">Ft</span> <span class="o">=</span> <span class="n">F</span>
    <span class="n">dldt</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">var</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">vars</span><span class="p">):</span>
        <span class="n">_f</span> <span class="o">=</span> <span class="n">curve</span><span class="o">.</span><span class="n">functions</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">_dn</span> <span class="o">=</span> <span class="n">diff</span><span class="p">(</span><span class="n">_f</span><span class="p">,</span> <span class="n">curve</span><span class="o">.</span><span class="n">parameter</span><span class="p">)</span>
        <span class="c1"># ...arc length</span>
        <span class="n">dldt</span> <span class="o">=</span> <span class="n">dldt</span> <span class="o">+</span> <span class="p">(</span><span class="n">_dn</span> <span class="o">*</span> <span class="n">_dn</span><span class="p">)</span>
        <span class="n">Ft</span> <span class="o">=</span> <span class="n">Ft</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="n">_f</span><span class="p">)</span>
    <span class="n">Ft</span> <span class="o">=</span> <span class="n">Ft</span> <span class="o">*</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">dldt</span><span class="p">)</span>

    <span class="n">integral</span> <span class="o">=</span> <span class="n">Integral</span><span class="p">(</span><span class="n">Ft</span><span class="p">,</span> <span class="n">curve</span><span class="o">.</span><span class="n">limits</span><span class="p">)</span><span class="o">.</span><span class="n">doit</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">integral</span></div>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../../index.html">
              <img class="logo" src="../../../_static/sympylogo.png" alt="Logo"/>
            </a></p><div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../index.html">Documentation overview</a><ul>
  <li><a href="../../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2015 SymPy Development Team.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.4.1</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.7</a>
      
    </div>

    

    
  </body>
</html>