<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>sympy.matrices.matrices &mdash; SymPy 1.0.1.dev documentation</title>
    
    <link rel="stylesheet" href="../../../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="http://96.sympy-live-tests.appspot.com/static/live-core.css" type="text/css" />
    <link rel="stylesheet" href="http://96.sympy-live-tests.appspot.com/static/live-autocomplete.css" type="text/css" />
    <link rel="stylesheet" href="http://96.sympy-live-tests.appspot.com/static/live-sphinx.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '1.0.1.dev',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="http://96.sympy-live-tests.appspot.com/static/utilities.js"></script>
    <script type="text/javascript" src="http://96.sympy-live-tests.appspot.com/static/external/classy.js"></script>
    <script type="text/javascript" src="http://96.sympy-live-tests.appspot.com/static/live-core.js"></script>
    <script type="text/javascript" src="http://96.sympy-live-tests.appspot.com/static/live-autocomplete.js"></script>
    <script type="text/javascript" src="http://96.sympy-live-tests.appspot.com/static/live-sphinx.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML-full"></script>
    <link rel="shortcut icon" href="../../../_static/sympy-notailtext-favicon.ico"/>
    <link rel="top" title="SymPy 1.0.1.dev documentation" href="../../../index.html" />
    <link rel="up" title="Module code" href="../../index.html" />
   
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head>
  <body role="document">  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for sympy.matrices.matrices</h1><div class="highlight"><pre>
<span></span><span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">print_function</span><span class="p">,</span> <span class="n">division</span>

<span class="kn">import</span> <span class="nn">collections</span>
<span class="kn">from</span> <span class="nn">sympy.core.add</span> <span class="kn">import</span> <span class="n">Add</span>
<span class="kn">from</span> <span class="nn">sympy.core.basic</span> <span class="kn">import</span> <span class="n">Basic</span><span class="p">,</span> <span class="n">Atom</span>
<span class="kn">from</span> <span class="nn">sympy.core.expr</span> <span class="kn">import</span> <span class="n">Expr</span>
<span class="kn">from</span> <span class="nn">sympy.core.function</span> <span class="kn">import</span> <span class="n">count_ops</span>
<span class="kn">from</span> <span class="nn">sympy.core.logic</span> <span class="kn">import</span> <span class="n">fuzzy_and</span>
<span class="kn">from</span> <span class="nn">sympy.core.power</span> <span class="kn">import</span> <span class="n">Pow</span>
<span class="kn">from</span> <span class="nn">sympy.core.symbol</span> <span class="kn">import</span> <span class="n">Symbol</span><span class="p">,</span> <span class="n">Dummy</span><span class="p">,</span> <span class="n">symbols</span>
<span class="kn">from</span> <span class="nn">sympy.core.numbers</span> <span class="kn">import</span> <span class="n">Integer</span><span class="p">,</span> <span class="n">ilcm</span><span class="p">,</span> <span class="n">Float</span>
<span class="kn">from</span> <span class="nn">sympy.core.singleton</span> <span class="kn">import</span> <span class="n">S</span>
<span class="kn">from</span> <span class="nn">sympy.core.sympify</span> <span class="kn">import</span> <span class="n">sympify</span>
<span class="kn">from</span> <span class="nn">sympy.core.compatibility</span> <span class="kn">import</span> <span class="n">is_sequence</span><span class="p">,</span> <span class="n">default_sort_key</span><span class="p">,</span> <span class="nb">range</span><span class="p">,</span> <span class="n">NotIterable</span>

<span class="kn">from</span> <span class="nn">sympy.polys</span> <span class="kn">import</span> <span class="n">PurePoly</span><span class="p">,</span> <span class="n">roots</span><span class="p">,</span> <span class="n">cancel</span><span class="p">,</span> <span class="n">gcd</span>
<span class="kn">from</span> <span class="nn">sympy.simplify</span> <span class="kn">import</span> <span class="n">simplify</span> <span class="k">as</span> <span class="n">_simplify</span><span class="p">,</span> <span class="n">signsimp</span><span class="p">,</span> <span class="n">nsimplify</span>
<span class="kn">from</span> <span class="nn">sympy.utilities.iterables</span> <span class="kn">import</span> <span class="n">flatten</span><span class="p">,</span> <span class="n">numbered_symbols</span>
<span class="kn">from</span> <span class="nn">sympy.functions.elementary.miscellaneous</span> <span class="kn">import</span> <span class="n">sqrt</span><span class="p">,</span> <span class="n">Max</span><span class="p">,</span> <span class="n">Min</span>
<span class="kn">from</span> <span class="nn">sympy.functions</span> <span class="kn">import</span> <span class="n">exp</span><span class="p">,</span> <span class="n">factorial</span>
<span class="kn">from</span> <span class="nn">sympy.printing</span> <span class="kn">import</span> <span class="n">sstr</span>
<span class="kn">from</span> <span class="nn">sympy.core.compatibility</span> <span class="kn">import</span> <span class="nb">reduce</span><span class="p">,</span> <span class="n">as_int</span><span class="p">,</span> <span class="n">string_types</span>
<span class="kn">from</span> <span class="nn">sympy.assumptions.refine</span> <span class="kn">import</span> <span class="n">refine</span>

<span class="kn">from</span> <span class="nn">types</span> <span class="kn">import</span> <span class="n">FunctionType</span>


<span class="k">def</span> <span class="nf">_iszero</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns True if x is zero.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="n">is_zero</span>


<div class="viewcode-block" id="MatrixError"><a class="viewcode-back" href="../../../modules/matrices/matrices.html#sympy.matrices.immutable.MatrixError">[docs]</a><span class="k">class</span> <span class="nc">MatrixError</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="ShapeError"><a class="viewcode-back" href="../../../modules/matrices/matrices.html#sympy.matrices.immutable.ShapeError">[docs]</a><span class="k">class</span> <span class="nc">ShapeError</span><span class="p">(</span><span class="ne">ValueError</span><span class="p">,</span> <span class="n">MatrixError</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Wrong matrix shape&quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="NonSquareMatrixError"><a class="viewcode-back" href="../../../modules/matrices/matrices.html#sympy.matrices.immutable.NonSquareMatrixError">[docs]</a><span class="k">class</span> <span class="nc">NonSquareMatrixError</span><span class="p">(</span><span class="n">ShapeError</span><span class="p">):</span>
    <span class="k">pass</span></div>


<span class="k">class</span> <span class="nc">DeferredVector</span><span class="p">(</span><span class="n">Symbol</span><span class="p">,</span> <span class="n">NotIterable</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A vector whose components are deferred (e.g. for use with lambdify)</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy import DeferredVector, lambdify</span>
<span class="sd">    &gt;&gt;&gt; X = DeferredVector( &#39;X&#39; )</span>
<span class="sd">    &gt;&gt;&gt; X</span>
<span class="sd">    X</span>
<span class="sd">    &gt;&gt;&gt; expr = (X[0] + 2, X[2] + 3)</span>
<span class="sd">    &gt;&gt;&gt; func = lambdify( X, expr)</span>
<span class="sd">    &gt;&gt;&gt; func( [1, 2, 3] )</span>
<span class="sd">    (3, 6)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="o">-</span><span class="mi">0</span><span class="p">:</span>
            <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s1">&#39;DeferredVector index out of range&#39;</span><span class="p">)</span>
        <span class="n">component_name</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1">[</span><span class="si">%d</span><span class="s1">]&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Symbol</span><span class="p">(</span><span class="n">component_name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">sstr</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;DeferredVector(&#39;</span><span class="si">%s</span><span class="s2">&#39;)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>


<div class="viewcode-block" id="MatrixBase"><a class="viewcode-back" href="../../../modules/matrices/matrices.html#sympy.matrices.immutable.MatrixBase">[docs]</a><span class="k">class</span> <span class="nc">MatrixBase</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

    <span class="c1"># Added just for numpy compatibility</span>
    <span class="n">__array_priority__</span> <span class="o">=</span> <span class="mi">11</span>

    <span class="n">is_Matrix</span> <span class="o">=</span> <span class="bp">True</span>
    <span class="n">is_Identity</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="n">_class_priority</span> <span class="o">=</span> <span class="mi">3</span>
    <span class="n">_sympify</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">sympify</span><span class="p">)</span>

    <span class="n">__hash__</span> <span class="o">=</span> <span class="bp">None</span> <span class="c1"># Mutable</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_handle_creation_inputs</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the number of rows, cols and flat matrix elements.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy import Matrix, I</span>

<span class="sd">        Matrix can be constructed as follows:</span>

<span class="sd">        * from a nested list of iterables</span>

<span class="sd">        &gt;&gt;&gt; Matrix( ((1, 2+I), (3, 4)) )</span>
<span class="sd">        Matrix([</span>
<span class="sd">        [1, 2 + I],</span>
<span class="sd">        [3,     4]])</span>

<span class="sd">        * from un-nested iterable (interpreted as a column)</span>

<span class="sd">        &gt;&gt;&gt; Matrix( [1, 2] )</span>
<span class="sd">        Matrix([</span>
<span class="sd">        [1],</span>
<span class="sd">        [2]])</span>

<span class="sd">        * from un-nested iterable with dimensions</span>

<span class="sd">        &gt;&gt;&gt; Matrix(1, 2, [1, 2] )</span>
<span class="sd">        Matrix([[1, 2]])</span>

<span class="sd">        * from no arguments (a 0 x 0 matrix)</span>

<span class="sd">        &gt;&gt;&gt; Matrix()</span>
<span class="sd">        Matrix(0, 0, [])</span>

<span class="sd">        * from a rule</span>

<span class="sd">        &gt;&gt;&gt; Matrix(2, 2, lambda i, j: i/(j + 1) )</span>
<span class="sd">        Matrix([</span>
<span class="sd">        [0,   0],</span>
<span class="sd">        [1, 1/2]])</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">sympy.matrices.sparse</span> <span class="kn">import</span> <span class="n">SparseMatrix</span>

        <span class="n">flat_list</span> <span class="o">=</span> <span class="bp">None</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># Matrix(SparseMatrix(...))</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">SparseMatrix</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">rows</span><span class="p">,</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">cols</span><span class="p">,</span> <span class="n">flatten</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>

            <span class="c1"># Matrix(Matrix(...))</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">MatrixBase</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">rows</span><span class="p">,</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">cols</span><span class="p">,</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">_mat</span>

            <span class="c1"># Matrix(MatrixSymbol(&#39;X&#39;, 2, 2))</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Basic</span><span class="p">)</span> <span class="ow">and</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">is_Matrix</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">rows</span><span class="p">,</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">cols</span><span class="p">,</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">as_explicit</span><span class="p">()</span><span class="o">.</span><span class="n">_mat</span>

            <span class="c1"># Matrix(numpy.ones((2, 2)))</span>
            <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s2">&quot;__array__&quot;</span><span class="p">):</span>
                <span class="c1"># NumPy array or matrix or some other object that implements</span>
                <span class="c1"># __array__. So let&#39;s first use this method to get a</span>
                <span class="c1"># numpy.array() and then make a python list out of it.</span>
                <span class="n">arr</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">__array__</span><span class="p">()</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="n">rows</span><span class="p">,</span> <span class="n">cols</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">flat_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">cls</span><span class="o">.</span><span class="n">_sympify</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">arr</span><span class="o">.</span><span class="n">ravel</span><span class="p">()]</span>
                    <span class="k">return</span> <span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">,</span> <span class="n">flat_list</span>
                <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">rows</span><span class="p">,</span> <span class="n">cols</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span>
                    <span class="n">flat_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">S</span><span class="o">.</span><span class="n">Zero</span><span class="p">]</span><span class="o">*</span><span class="n">rows</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)):</span>
                        <span class="n">flat_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">cls</span><span class="o">.</span><span class="n">_sympify</span><span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                    <span class="k">return</span> <span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">,</span> <span class="n">flat_list</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                        <span class="s2">&quot;SymPy supports just 1D and 2D matrices&quot;</span><span class="p">)</span>

            <span class="c1"># Matrix([1, 2, 3]) or Matrix([[1, 2], [3, 4]])</span>
            <span class="k">elif</span> <span class="n">is_sequence</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>\
                    <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">DeferredVector</span><span class="p">):</span>
                <span class="n">in_mat</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">ncol</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">MatrixBase</span><span class="p">):</span>
                        <span class="n">in_mat</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">row</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>
                        <span class="k">if</span> <span class="n">row</span><span class="o">.</span><span class="n">cols</span> <span class="ow">or</span> <span class="n">row</span><span class="o">.</span><span class="n">rows</span><span class="p">:</span>  <span class="c1"># only pay attention if it&#39;s not 0x0</span>
                            <span class="n">ncol</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">row</span><span class="o">.</span><span class="n">cols</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">in_mat</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">row</span><span class="p">)</span>
                        <span class="k">try</span><span class="p">:</span>
                            <span class="n">ncol</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">row</span><span class="p">))</span>
                        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                            <span class="n">ncol</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ncol</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Got rows of variable lengths: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span>
                        <span class="nb">sorted</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">ncol</span><span class="p">)))</span>
                <span class="n">cols</span> <span class="o">=</span> <span class="n">ncol</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span> <span class="k">if</span> <span class="n">ncol</span> <span class="k">else</span> <span class="mi">0</span>
                <span class="n">rows</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">in_mat</span><span class="p">)</span> <span class="k">if</span> <span class="n">cols</span> <span class="k">else</span> <span class="mi">0</span>
                <span class="k">if</span> <span class="n">rows</span><span class="p">:</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">is_sequence</span><span class="p">(</span><span class="n">in_mat</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                        <span class="n">cols</span> <span class="o">=</span> <span class="mi">1</span>
                        <span class="n">flat_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">cls</span><span class="o">.</span><span class="n">_sympify</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">in_mat</span><span class="p">]</span>
                        <span class="k">return</span> <span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">,</span> <span class="n">flat_list</span>
                <span class="n">flat_list</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">rows</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">cols</span><span class="p">):</span>
                        <span class="n">flat_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cls</span><span class="o">.</span><span class="n">_sympify</span><span class="p">(</span><span class="n">in_mat</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">i</span><span class="p">]))</span>

        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">rows</span> <span class="o">=</span> <span class="n">as_int</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">cols</span> <span class="o">=</span> <span class="n">as_int</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

            <span class="c1"># Matrix(2, 2, lambda i, j: i+j)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">collections</span><span class="o">.</span><span class="n">Callable</span><span class="p">):</span>
                <span class="n">op</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
                <span class="n">flat_list</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">rows</span><span class="p">):</span>
                    <span class="n">flat_list</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
                        <span class="p">[</span><span class="n">cls</span><span class="o">.</span><span class="n">_sympify</span><span class="p">(</span><span class="n">op</span><span class="p">(</span><span class="n">cls</span><span class="o">.</span><span class="n">_sympify</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="n">cls</span><span class="o">.</span><span class="n">_sympify</span><span class="p">(</span><span class="n">j</span><span class="p">)))</span>
                        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">cols</span><span class="p">)])</span>

            <span class="c1"># Matrix(2, 2, [1, 2, 3, 4])</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span> <span class="ow">and</span> <span class="n">is_sequence</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">2</span><span class="p">]):</span>
                <span class="n">flat_list</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">flat_list</span><span class="p">)</span> <span class="o">!=</span> <span class="n">rows</span><span class="o">*</span><span class="n">cols</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;List length should be equal to rows*columns&#39;</span><span class="p">)</span>
                <span class="n">flat_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">cls</span><span class="o">.</span><span class="n">_sympify</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">flat_list</span><span class="p">]</span>


        <span class="c1"># Matrix()</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># Empty Matrix</span>
            <span class="n">rows</span> <span class="o">=</span> <span class="n">cols</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">flat_list</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">if</span> <span class="n">flat_list</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Data type not understood&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">,</span> <span class="n">flat_list</span>

    <span class="k">def</span> <span class="nf">_setitem</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Helper to set value at location given by key.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy import Matrix, I, zeros, ones</span>
<span class="sd">        &gt;&gt;&gt; m = Matrix(((1, 2+I), (3, 4)))</span>
<span class="sd">        &gt;&gt;&gt; m</span>
<span class="sd">        Matrix([</span>
<span class="sd">        [1, 2 + I],</span>
<span class="sd">        [3,     4]])</span>
<span class="sd">        &gt;&gt;&gt; m[1, 0] = 9</span>
<span class="sd">        &gt;&gt;&gt; m</span>
<span class="sd">        Matrix([</span>
<span class="sd">        [1, 2 + I],</span>
<span class="sd">        [9,     4]])</span>
<span class="sd">        &gt;&gt;&gt; m[1, 0] = [[0, 1]]</span>

<span class="sd">        To replace row r you assign to position r*m where m</span>
<span class="sd">        is the number of columns:</span>

<span class="sd">        &gt;&gt;&gt; M = zeros(4)</span>
<span class="sd">        &gt;&gt;&gt; m = M.cols</span>
<span class="sd">        &gt;&gt;&gt; M[3*m] = ones(1, m)*2; M</span>
<span class="sd">        Matrix([</span>
<span class="sd">        [0, 0, 0, 0],</span>
<span class="sd">        [0, 0, 0, 0],</span>
<span class="sd">        [0, 0, 0, 0],</span>
<span class="sd">        [2, 2, 2, 2]])</span>

<span class="sd">        And to replace column c you can assign to position c:</span>

<span class="sd">        &gt;&gt;&gt; M[2] = ones(m, 1)*4; M</span>
<span class="sd">        Matrix([</span>
<span class="sd">        [0, 0, 4, 0],</span>
<span class="sd">        [0, 0, 4, 0],</span>
<span class="sd">        [0, 0, 4, 0],</span>
<span class="sd">        [2, 2, 4, 2]])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">.dense</span> <span class="kn">import</span> <span class="n">Matrix</span>

        <span class="n">is_slice</span> <span class="o">=</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">slice</span><span class="p">)</span>
        <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">key2ij</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="n">is_mat</span> <span class="o">=</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">MatrixBase</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">slice</span> <span class="ow">or</span> <span class="nb">type</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">slice</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">is_mat</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">copyin_matrix</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
                <span class="k">return</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">Expr</span><span class="p">)</span> <span class="ow">and</span> <span class="n">is_sequence</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">copyin_list</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
                <span class="k">return</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;unexpected value: </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">value</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">is_mat</span> <span class="ow">and</span>
                <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">Basic</span><span class="p">)</span> <span class="ow">and</span> <span class="n">is_sequence</span><span class="p">(</span><span class="n">value</span><span class="p">)):</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">Matrix</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
                <span class="n">is_mat</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="k">if</span> <span class="n">is_mat</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">is_slice</span><span class="p">:</span>
                    <span class="n">key</span> <span class="o">=</span> <span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="o">*</span><span class="nb">divmod</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">)),</span>
                           <span class="nb">slice</span><span class="p">(</span><span class="o">*</span><span class="nb">divmod</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">)))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">key</span> <span class="o">=</span> <span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="n">value</span><span class="o">.</span><span class="n">rows</span><span class="p">),</span>
                           <span class="nb">slice</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">j</span> <span class="o">+</span> <span class="n">value</span><span class="o">.</span><span class="n">cols</span><span class="p">))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">copyin_matrix</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sympify</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
            <span class="k">return</span>

    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_new</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mat</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">trace</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_square</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">NonSquareMatrixError</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_eval_trace</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">inv</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_square</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">NonSquareMatrixError</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">method</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;method&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">method</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_eval_inverse</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

<div class="viewcode-block" id="MatrixBase.inv_mod"><a class="viewcode-back" href="../../../modules/matrices/matrices.html#sympy.matrices.immutable.MatrixBase.inv_mod">[docs]</a>    <span class="k">def</span> <span class="nf">inv_mod</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">):</span>
        <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">        Returns the inverse of the matrix `K` (mod `m`), if it exists.</span>

<span class="sd">        Method to find the matrix inverse of `K` (mod `m`) implemented in this function:</span>

<span class="sd">        * Compute `\mathrm{adj}(K) = \mathrm{cof}(K)^t`, the adjoint matrix of `K`.</span>

<span class="sd">        * Compute `r = 1/\mathrm{det}(K) \pmod m`.</span>

<span class="sd">        * `K^{-1} = r\cdot \mathrm{adj}(K) \pmod m`.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy import Matrix</span>
<span class="sd">        &gt;&gt;&gt; A = Matrix(2, 2, [1, 2, 3, 4])</span>
<span class="sd">        &gt;&gt;&gt; A.inv_mod(5)</span>
<span class="sd">        Matrix([</span>
<span class="sd">        [3, 1],</span>
<span class="sd">        [4, 2]])</span>
<span class="sd">        &gt;&gt;&gt; A.inv_mod(3)</span>
<span class="sd">        Matrix([</span>
<span class="sd">        [1, 1],</span>
<span class="sd">        [0, 1]])</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">sympy.ntheory</span> <span class="kn">import</span> <span class="n">totient</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_square</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">NonSquareMatrixError</span><span class="p">()</span>
        <span class="n">N</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span>
        <span class="n">phi</span> <span class="o">=</span> <span class="n">totient</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
        <span class="n">det_K</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">det</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">gcd</span><span class="p">(</span><span class="n">det_K</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Matrix is not invertible (mod </span><span class="si">%d</span><span class="s1">)&#39;</span> <span class="o">%</span> <span class="n">m</span><span class="p">)</span>
        <span class="n">det_inv</span> <span class="o">=</span> <span class="nb">pow</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">det_K</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">phi</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">m</span><span class="p">))</span>
        <span class="n">K_adj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cofactorMatrix</span><span class="p">()</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
        <span class="n">K_inv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="p">[</span><span class="n">det_inv</span><span class="o">*</span><span class="n">K_adj</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">%</span> <span class="n">m</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">)</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">)])</span>
        <span class="k">return</span> <span class="n">K_inv</span></div>

    <span class="k">def</span> <span class="nf">transpose</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_eval_transpose</span><span class="p">()</span>

    <span class="n">T</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">transpose</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="s2">&quot;Matrix transposition.&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">conjugate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_eval_conjugate</span><span class="p">()</span>

    <span class="n">C</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">conjugate</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="s2">&quot;By-element conjugation.&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="MatrixBase.adjoint"><a class="viewcode-back" href="../../../modules/matrices/matrices.html#sympy.matrices.immutable.MatrixBase.adjoint">[docs]</a>    <span class="k">def</span> <span class="nf">adjoint</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Conjugate transpose or Hermitian conjugation.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">C</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">H</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return Hermite conjugate.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy import Matrix, I</span>
<span class="sd">        &gt;&gt;&gt; m = Matrix((0, 1 + I, 2, 3))</span>
<span class="sd">        &gt;&gt;&gt; m</span>
<span class="sd">        Matrix([</span>
<span class="sd">        [    0],</span>
<span class="sd">        [1 + I],</span>
<span class="sd">        [    2],</span>
<span class="sd">        [    3]])</span>
<span class="sd">        &gt;&gt;&gt; m.H</span>
<span class="sd">        Matrix([[0, 1 - I, 2, 3]])</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        conjugate: By-element conjugation</span>
<span class="sd">        D: Dirac conjugation</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">C</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">D</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return Dirac conjugate (if self.rows == 4).</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy import Matrix, I, eye</span>
<span class="sd">        &gt;&gt;&gt; m = Matrix((0, 1 + I, 2, 3))</span>
<span class="sd">        &gt;&gt;&gt; m.D</span>
<span class="sd">        Matrix([[0, 1 - I, -2, -3]])</span>
<span class="sd">        &gt;&gt;&gt; m = (eye(4) + I*eye(4))</span>
<span class="sd">        &gt;&gt;&gt; m[0, 3] = 2</span>
<span class="sd">        &gt;&gt;&gt; m.D</span>
<span class="sd">        Matrix([</span>
<span class="sd">        [1 - I,     0,      0,      0],</span>
<span class="sd">        [    0, 1 - I,      0,      0],</span>
<span class="sd">        [    0,     0, -1 + I,      0],</span>
<span class="sd">        [    2,     0,      0, -1 + I]])</span>

<span class="sd">        If the matrix does not have 4 rows an AttributeError will be raised</span>
<span class="sd">        because this property is only defined for matrices with 4 rows.</span>

<span class="sd">        &gt;&gt;&gt; Matrix(eye(2)).D</span>
<span class="sd">        Traceback (most recent call last):</span>
<span class="sd">        ...</span>
<span class="sd">        AttributeError: Matrix has no attribute D.</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        conjugate: By-element conjugation</span>
<span class="sd">        H: Hermite conjugation</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">sympy.physics.matrices</span> <span class="kn">import</span> <span class="n">mgamma</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">rows</span> <span class="o">!=</span> <span class="mi">4</span><span class="p">:</span>
            <span class="c1"># In Python 3.2, properties can only return an AttributeError</span>
            <span class="c1"># so we can&#39;t raise a ShapeError -- see commit which added the</span>
            <span class="c1"># first line of this inline comment. Also, there is no need</span>
            <span class="c1"># for a message since MatrixBase will raise the AttributeError</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">H</span><span class="o">*</span><span class="n">mgamma</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__array__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">.dense</span> <span class="kn">import</span> <span class="n">matrix2numpy</span>
        <span class="k">return</span> <span class="n">matrix2numpy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the number of elements of self.</span>

<span class="sd">        Implemented mainly so bool(Matrix()) == False.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">cols</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">shape</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The shape (dimensions) of the matrix as the 2-tuple (rows, cols).</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.matrices import zeros</span>
<span class="sd">        &gt;&gt;&gt; M = zeros(2, 3)</span>
<span class="sd">        &gt;&gt;&gt; M.shape</span>
<span class="sd">        (2, 3)</span>
<span class="sd">        &gt;&gt;&gt; M.rows</span>
<span class="sd">        2</span>
<span class="sd">        &gt;&gt;&gt; M.cols</span>
<span class="sd">        3</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__sub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span> <span class="o">+</span> <span class="p">(</span><span class="o">-</span><span class="n">a</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__rsub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="o">-</span><span class="bp">self</span><span class="p">)</span> <span class="o">+</span> <span class="n">a</span>

    <span class="k">def</span> <span class="nf">__mul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return self*other where other is either a scalar or a matrix</span>
<span class="sd">        of compatible dimensions.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.matrices import Matrix</span>
<span class="sd">        &gt;&gt;&gt; A = Matrix([[1, 2, 3], [4, 5, 6]])</span>
<span class="sd">        &gt;&gt;&gt; 2*A == A*2 == Matrix([[2, 4, 6], [8, 10, 12]])</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; B = Matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]])</span>
<span class="sd">        &gt;&gt;&gt; A*B</span>
<span class="sd">        Matrix([</span>
<span class="sd">        [30, 36, 42],</span>
<span class="sd">        [66, 81, 96]])</span>
<span class="sd">        &gt;&gt;&gt; B*A</span>
<span class="sd">        Traceback (most recent call last):</span>
<span class="sd">        ...</span>
<span class="sd">        ShapeError: Matrices size mismatch.</span>
<span class="sd">        &gt;&gt;&gt;</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        matrix_multiply_elementwise</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="s1">&#39;is_Matrix&#39;</span><span class="p">,</span> <span class="bp">False</span><span class="p">):</span>
            <span class="n">A</span> <span class="o">=</span> <span class="bp">self</span>
            <span class="n">B</span> <span class="o">=</span> <span class="n">other</span>
            <span class="k">if</span> <span class="n">A</span><span class="o">.</span><span class="n">cols</span> <span class="o">!=</span> <span class="n">B</span><span class="o">.</span><span class="n">rows</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">ShapeError</span><span class="p">(</span><span class="s2">&quot;Matrices size mismatch.&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">A</span><span class="o">.</span><span class="n">cols</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">classof</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span><span class="o">.</span><span class="n">_new</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">rows</span><span class="p">,</span> <span class="n">B</span><span class="o">.</span><span class="n">cols</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">:</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">blst</span> <span class="o">=</span> <span class="n">B</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
            <span class="n">alst</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">classof</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span><span class="o">.</span><span class="n">_new</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">rows</span><span class="p">,</span> <span class="n">B</span><span class="o">.</span><span class="n">cols</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">:</span>
                <span class="nb">reduce</span><span class="p">(</span><span class="k">lambda</span> <span class="n">k</span><span class="p">,</span> <span class="n">l</span><span class="p">:</span> <span class="n">k</span> <span class="o">+</span> <span class="n">l</span><span class="p">,</span>
                    <span class="p">[</span><span class="n">a_ik</span> <span class="o">*</span> <span class="n">b_kj</span> <span class="k">for</span> <span class="n">a_ik</span><span class="p">,</span> <span class="n">b_kj</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">alst</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">blst</span><span class="p">[</span><span class="n">j</span><span class="p">])]))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_new</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">,</span>
                <span class="p">[</span><span class="n">i</span><span class="o">*</span><span class="n">other</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mat</span><span class="p">])</span>

    <span class="n">__matmul__</span> <span class="o">=</span> <span class="n">__mul__</span>

    <span class="k">def</span> <span class="nf">__rmul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="s1">&#39;is_Matrix&#39;</span><span class="p">,</span> <span class="bp">False</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_new</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_new</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">,</span> <span class="p">[</span><span class="n">a</span><span class="o">*</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mat</span><span class="p">])</span>

    <span class="n">__rmatmul__</span> <span class="o">=</span> <span class="n">__rmul__</span>

    <span class="k">def</span> <span class="nf">__pow__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">sympy.matrices</span> <span class="kn">import</span> <span class="n">eye</span><span class="p">,</span> <span class="n">diag</span><span class="p">,</span> <span class="n">MutableMatrix</span>
        <span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">binomial</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_square</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">NonSquareMatrixError</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="n">Integer</span><span class="p">):</span>
            <span class="n">n</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">num</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">inv</span><span class="p">()</span><span class="o">**-</span><span class="n">n</span>   <span class="c1"># A**-2 = (A**-1)**2</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">eye</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">)</span>
            <span class="n">s</span> <span class="o">=</span> <span class="bp">self</span>
            <span class="k">while</span> <span class="n">n</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">n</span> <span class="o">%</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="n">a</span> <span class="o">*=</span> <span class="n">s</span>
                    <span class="n">n</span> <span class="o">-=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">n</span><span class="p">:</span>
                    <span class="k">break</span>
                <span class="n">s</span> <span class="o">*=</span> <span class="n">s</span>
                <span class="n">n</span> <span class="o">//=</span> <span class="mi">2</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_new</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="p">(</span><span class="n">Expr</span><span class="p">,</span> <span class="nb">float</span><span class="p">)):</span>

            <span class="k">def</span> <span class="nf">jordan_cell_power</span><span class="p">(</span><span class="n">jc</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
                <span class="n">N</span> <span class="o">=</span> <span class="n">jc</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">l</span> <span class="o">=</span> <span class="n">jc</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
                        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="o">-</span><span class="n">i</span><span class="p">):</span>
                                <span class="n">bn</span> <span class="o">=</span> <span class="n">binomial</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
                                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">bn</span><span class="p">,</span> <span class="n">binomial</span><span class="p">):</span>
                                        <span class="n">bn</span> <span class="o">=</span> <span class="n">bn</span><span class="o">.</span><span class="n">_eval_expand_func</span><span class="p">()</span>
                                <span class="n">jc</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="o">+</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">l</span><span class="o">**</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="n">i</span><span class="p">)</span><span class="o">*</span><span class="n">bn</span>

            <span class="n">P</span><span class="p">,</span> <span class="n">jordan_cells</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">jordan_cells</span><span class="p">()</span>
            <span class="c1"># Make sure jordan_cells matrices are mutable:</span>
            <span class="n">jordan_cells</span> <span class="o">=</span> <span class="p">[</span><span class="n">MutableMatrix</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">jordan_cells</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">jordan_cells</span><span class="p">:</span>
                <span class="n">jordan_cell_power</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">num</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_new</span><span class="p">(</span><span class="n">P</span><span class="o">*</span><span class="n">diag</span><span class="p">(</span><span class="o">*</span><span class="n">jordan_cells</span><span class="p">)</span><span class="o">*</span><span class="n">P</span><span class="o">.</span><span class="n">inv</span><span class="p">())</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;Only SymPy expressions or int objects are supported as exponent for matrices&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return self + other, raising ShapeError if shapes don&#39;t match.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="s1">&#39;is_Matrix&#39;</span><span class="p">,</span> <span class="bp">False</span><span class="p">):</span>
            <span class="n">A</span> <span class="o">=</span> <span class="bp">self</span>
            <span class="n">B</span> <span class="o">=</span> <span class="n">other</span>
            <span class="k">if</span> <span class="n">A</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">B</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">ShapeError</span><span class="p">(</span><span class="s2">&quot;Matrix size mismatch.&quot;</span><span class="p">)</span>
            <span class="n">alst</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
            <span class="n">blst</span> <span class="o">=</span> <span class="n">B</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="p">[</span><span class="n">S</span><span class="o">.</span><span class="n">Zero</span><span class="p">]</span><span class="o">*</span><span class="n">A</span><span class="o">.</span><span class="n">rows</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                <span class="n">ret</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="n">k</span> <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">alst</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">blst</span><span class="p">[</span><span class="n">i</span><span class="p">])]</span>
            <span class="n">rv</span> <span class="o">=</span> <span class="n">classof</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span><span class="o">.</span><span class="n">_new</span><span class="p">(</span><span class="n">ret</span><span class="p">)</span>
            <span class="k">if</span> <span class="mi">0</span> <span class="ow">in</span> <span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
                <span class="n">rv</span> <span class="o">=</span> <span class="n">rv</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">*</span><span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">rv</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;cannot add matrix and </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">__radd__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span> <span class="o">+</span> <span class="n">other</span>

    <span class="k">def</span> <span class="nf">__div__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">*</span><span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">One</span> <span class="o">/</span> <span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__truediv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__div__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__neg__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">*</span><span class="bp">self</span>

<div class="viewcode-block" id="MatrixBase.multiply"><a class="viewcode-back" href="../../../modules/matrices/matrices.html#sympy.matrices.immutable.MatrixBase.multiply">[docs]</a>    <span class="k">def</span> <span class="nf">multiply</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns self*b</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        dot</span>
<span class="sd">        cross</span>
<span class="sd">        multiply_elementwise</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">*</span><span class="n">b</span></div>

<div class="viewcode-block" id="MatrixBase.add"><a class="viewcode-back" href="../../../modules/matrices/matrices.html#sympy.matrices.immutable.MatrixBase.add">[docs]</a>    <span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return self + b &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span> <span class="o">+</span> <span class="n">b</span></div>

<div class="viewcode-block" id="MatrixBase.table"><a class="viewcode-back" href="../../../modules/matrices/matrices.html#sympy.matrices.immutable.MatrixBase.table">[docs]</a>    <span class="k">def</span> <span class="nf">table</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">printer</span><span class="p">,</span> <span class="n">rowstart</span><span class="o">=</span><span class="s1">&#39;[&#39;</span><span class="p">,</span> <span class="n">rowend</span><span class="o">=</span><span class="s1">&#39;]&#39;</span><span class="p">,</span> <span class="n">rowsep</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span>
              <span class="n">colsep</span><span class="o">=</span><span class="s1">&#39;, &#39;</span><span class="p">,</span> <span class="n">align</span><span class="o">=</span><span class="s1">&#39;right&#39;</span><span class="p">):</span>
        <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">        String form of Matrix as a table.</span>

<span class="sd">        ``printer`` is the printer to use for on the elements (generally</span>
<span class="sd">        something like StrPrinter())</span>

<span class="sd">        ``rowstart`` is the string used to start each row (by default &#39;[&#39;).</span>

<span class="sd">        ``rowend`` is the string used to end each row (by default &#39;]&#39;).</span>

<span class="sd">        ``rowsep`` is the string used to separate rows (by default a newline).</span>

<span class="sd">        ``colsep`` is the string used to separate columns (by default &#39;, &#39;).</span>

<span class="sd">        ``align`` defines how the elements are aligned. Must be one of &#39;left&#39;,</span>
<span class="sd">        &#39;right&#39;, or &#39;center&#39;.  You can also use &#39;&lt;&#39;, &#39;&gt;&#39;, and &#39;^&#39; to mean the</span>
<span class="sd">        same thing, respectively.</span>

<span class="sd">        This is used by the string printer for Matrix.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy import Matrix</span>
<span class="sd">        &gt;&gt;&gt; from sympy.printing.str import StrPrinter</span>
<span class="sd">        &gt;&gt;&gt; M = Matrix([[1, 2], [-33, 4]])</span>
<span class="sd">        &gt;&gt;&gt; printer = StrPrinter()</span>
<span class="sd">        &gt;&gt;&gt; M.table(printer)</span>
<span class="sd">        &#39;[  1, 2]\n[-33, 4]&#39;</span>
<span class="sd">        &gt;&gt;&gt; print(M.table(printer))</span>
<span class="sd">        [  1, 2]</span>
<span class="sd">        [-33, 4]</span>
<span class="sd">        &gt;&gt;&gt; print(M.table(printer, rowsep=&#39;,\n&#39;))</span>
<span class="sd">        [  1, 2],</span>
<span class="sd">        [-33, 4]</span>
<span class="sd">        &gt;&gt;&gt; print(&#39;[%s]&#39; % M.table(printer, rowsep=&#39;,\n&#39;))</span>
<span class="sd">        [[  1, 2],</span>
<span class="sd">        [-33, 4]]</span>
<span class="sd">        &gt;&gt;&gt; print(M.table(printer, colsep=&#39; &#39;))</span>
<span class="sd">        [  1 2]</span>
<span class="sd">        [-33 4]</span>
<span class="sd">        &gt;&gt;&gt; print(M.table(printer, align=&#39;center&#39;))</span>
<span class="sd">        [ 1 , 2]</span>
<span class="sd">        [-33, 4]</span>
<span class="sd">        &gt;&gt;&gt; print(M.table(printer, rowstart=&#39;{&#39;, rowend=&#39;}&#39;))</span>
<span class="sd">        {  1, 2}</span>
<span class="sd">        {-33, 4}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Handle zero dimensions:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">rows</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="s1">&#39;[]&#39;</span>
        <span class="c1"># Build table of string representations of the elements</span>
        <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># Track per-column max lengths for pretty alignment</span>
        <span class="n">maxlen</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="p">):</span>
            <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">):</span>
                <span class="n">s</span> <span class="o">=</span> <span class="n">printer</span><span class="o">.</span><span class="n">_print</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">])</span>
                <span class="n">res</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
                <span class="n">maxlen</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">),</span> <span class="n">maxlen</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
        <span class="c1"># Patch strings together</span>
        <span class="n">align</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;left&#39;</span><span class="p">:</span> <span class="s1">&#39;ljust&#39;</span><span class="p">,</span>
            <span class="s1">&#39;right&#39;</span><span class="p">:</span> <span class="s1">&#39;rjust&#39;</span><span class="p">,</span>
            <span class="s1">&#39;center&#39;</span><span class="p">:</span> <span class="s1">&#39;center&#39;</span><span class="p">,</span>
            <span class="s1">&#39;&lt;&#39;</span><span class="p">:</span> <span class="s1">&#39;ljust&#39;</span><span class="p">,</span>
            <span class="s1">&#39;&gt;&#39;</span><span class="p">:</span> <span class="s1">&#39;rjust&#39;</span><span class="p">,</span>
            <span class="s1">&#39;^&#39;</span><span class="p">:</span> <span class="s1">&#39;center&#39;</span><span class="p">,</span>
            <span class="p">}[</span><span class="n">align</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">res</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">elem</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">row</span><span class="p">):</span>
                <span class="n">row</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">elem</span><span class="p">,</span> <span class="n">align</span><span class="p">)(</span><span class="n">maxlen</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
            <span class="n">res</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">rowstart</span> <span class="o">+</span> <span class="n">colsep</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">row</span><span class="p">)</span> <span class="o">+</span> <span class="n">rowend</span>
        <span class="k">return</span> <span class="n">rowsep</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">res</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_format_str</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">printer</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">printer</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">sympy.printing.str</span> <span class="kn">import</span> <span class="n">StrPrinter</span>
            <span class="n">printer</span> <span class="o">=</span> <span class="n">StrPrinter</span><span class="p">()</span>
        <span class="c1"># Handle zero dimensions:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">rows</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="s1">&#39;Matrix(</span><span class="si">%s</span><span class="s1">, </span><span class="si">%s</span><span class="s1">, [])&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">rows</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;Matrix([</span><span class="si">%s</span><span class="s2">])&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">table</span><span class="p">(</span><span class="n">printer</span><span class="p">,</span> <span class="n">rowsep</span><span class="o">=</span><span class="s1">&#39;,</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="s2">&quot;Matrix([</span><span class="se">\n</span><span class="si">%s</span><span class="s2">])&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">table</span><span class="p">(</span><span class="n">printer</span><span class="p">,</span> <span class="n">rowsep</span><span class="o">=</span><span class="s1">&#39;,</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">rows</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="s1">&#39;Matrix(</span><span class="si">%s</span><span class="s1">, </span><span class="si">%s</span><span class="s1">, [])&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">)</span>
        <span class="k">return</span> <span class="s2">&quot;Matrix(</span><span class="si">%s</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">sstr</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

<div class="viewcode-block" id="MatrixBase.cholesky"><a class="viewcode-back" href="../../../modules/matrices/matrices.html#sympy.matrices.immutable.MatrixBase.cholesky">[docs]</a>    <span class="k">def</span> <span class="nf">cholesky</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the Cholesky decomposition L of a matrix A</span>
<span class="sd">        such that L * L.T = A</span>

<span class="sd">        A must be a square, symmetric, positive-definite</span>
<span class="sd">        and non-singular matrix.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.matrices import Matrix</span>
<span class="sd">        &gt;&gt;&gt; A = Matrix(((25, 15, -5), (15, 18, 0), (-5, 0, 11)))</span>
<span class="sd">        &gt;&gt;&gt; A.cholesky()</span>
<span class="sd">        Matrix([</span>
<span class="sd">        [ 5, 0, 0],</span>
<span class="sd">        [ 3, 3, 0],</span>
<span class="sd">        [-1, 1, 3]])</span>
<span class="sd">        &gt;&gt;&gt; A.cholesky() * A.cholesky().T</span>
<span class="sd">        Matrix([</span>
<span class="sd">        [25, 15, -5],</span>
<span class="sd">        [15, 18,  0],</span>
<span class="sd">        [-5,  0, 11]])</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        LDLdecomposition</span>
<span class="sd">        LUdecomposition</span>
<span class="sd">        QRdecomposition</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_square</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">NonSquareMatrixError</span><span class="p">(</span><span class="s2">&quot;Matrix must be square.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_symmetric</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Matrix must be symmetric.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cholesky</span><span class="p">()</span></div>

<div class="viewcode-block" id="MatrixBase.LDLdecomposition"><a class="viewcode-back" href="../../../modules/matrices/matrices.html#sympy.matrices.immutable.MatrixBase.LDLdecomposition">[docs]</a>    <span class="k">def</span> <span class="nf">LDLdecomposition</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the LDL Decomposition (L, D) of matrix A,</span>
<span class="sd">        such that L * D * L.T == A</span>
<span class="sd">        This method eliminates the use of square root.</span>
<span class="sd">        Further this ensures that all the diagonal entries of L are 1.</span>
<span class="sd">        A must be a square, symmetric, positive-definite</span>
<span class="sd">        and non-singular matrix.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.matrices import Matrix, eye</span>
<span class="sd">        &gt;&gt;&gt; A = Matrix(((25, 15, -5), (15, 18, 0), (-5, 0, 11)))</span>
<span class="sd">        &gt;&gt;&gt; L, D = A.LDLdecomposition()</span>
<span class="sd">        &gt;&gt;&gt; L</span>
<span class="sd">        Matrix([</span>
<span class="sd">        [   1,   0, 0],</span>
<span class="sd">        [ 3/5,   1, 0],</span>
<span class="sd">        [-1/5, 1/3, 1]])</span>
<span class="sd">        &gt;&gt;&gt; D</span>
<span class="sd">        Matrix([</span>
<span class="sd">        [25, 0, 0],</span>
<span class="sd">        [ 0, 9, 0],</span>
<span class="sd">        [ 0, 0, 9]])</span>
<span class="sd">        &gt;&gt;&gt; L * D * L.T * A.inv() == eye(A.rows)</span>
<span class="sd">        True</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        cholesky</span>
<span class="sd">        LUdecomposition</span>
<span class="sd">        QRdecomposition</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_square</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">NonSquareMatrixError</span><span class="p">(</span><span class="s2">&quot;Matrix must be square.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_symmetric</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Matrix must be symmetric.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_LDLdecomposition</span><span class="p">()</span></div>

<div class="viewcode-block" id="MatrixBase.lower_triangular_solve"><a class="viewcode-back" href="../../../modules/matrices/matrices.html#sympy.matrices.immutable.MatrixBase.lower_triangular_solve">[docs]</a>    <span class="k">def</span> <span class="nf">lower_triangular_solve</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rhs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Solves Ax = B, where A is a lower triangular matrix.</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        upper_triangular_solve</span>
<span class="sd">        gauss_jordan_solve</span>
<span class="sd">        cholesky_solve</span>
<span class="sd">        diagonal_solve</span>
<span class="sd">        LDLsolve</span>
<span class="sd">        LUsolve</span>
<span class="sd">        QRsolve</span>
<span class="sd">        pinv_solve</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_square</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">NonSquareMatrixError</span><span class="p">(</span><span class="s2">&quot;Matrix must be square.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">rhs</span><span class="o">.</span><span class="n">rows</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ShapeError</span><span class="p">(</span><span class="s2">&quot;Matrices size mismatch.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_lower</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Matrix must be lower triangular.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lower_triangular_solve</span><span class="p">(</span><span class="n">rhs</span><span class="p">)</span></div>

<div class="viewcode-block" id="MatrixBase.upper_triangular_solve"><a class="viewcode-back" href="../../../modules/matrices/matrices.html#sympy.matrices.immutable.MatrixBase.upper_triangular_solve">[docs]</a>    <span class="k">def</span> <span class="nf">upper_triangular_solve</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rhs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Solves Ax = B, where A is an upper triangular matrix.</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        lower_triangular_solve</span>
<span class="sd">        gauss_jordan_solve</span>
<span class="sd">        cholesky_solve</span>
<span class="sd">        diagonal_solve</span>
<span class="sd">        LDLsolve</span>
<span class="sd">        LUsolve</span>
<span class="sd">        QRsolve</span>
<span class="sd">        pinv_solve</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_square</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">NonSquareMatrixError</span><span class="p">(</span><span class="s2">&quot;Matrix must be square.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">rhs</span><span class="o">.</span><span class="n">rows</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Matrix size mismatch.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_upper</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Matrix is not upper triangular.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_upper_triangular_solve</span><span class="p">(</span><span class="n">rhs</span><span class="p">)</span></div>

<div class="viewcode-block" id="MatrixBase.cholesky_solve"><a class="viewcode-back" href="../../../modules/matrices/matrices.html#sympy.matrices.immutable.MatrixBase.cholesky_solve">[docs]</a>    <span class="k">def</span> <span class="nf">cholesky_solve</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rhs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Solves Ax = B using Cholesky decomposition,</span>
<span class="sd">        for a general square non-singular matrix.</span>
<span class="sd">        For a non-square matrix with rows &gt; cols,</span>
<span class="sd">        the least squares solution is returned.</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        lower_triangular_solve</span>
<span class="sd">        upper_triangular_solve</span>
<span class="sd">        gauss_jordan_solve</span>
<span class="sd">        diagonal_solve</span>
<span class="sd">        LDLsolve</span>
<span class="sd">        LUsolve</span>
<span class="sd">        QRsolve</span>
<span class="sd">        pinv_solve</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_symmetric</span><span class="p">():</span>
            <span class="n">L</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cholesky</span><span class="p">()</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">rows</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">:</span>
            <span class="n">L</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">T</span><span class="o">*</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">_cholesky</span><span class="p">()</span>
            <span class="n">rhs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">T</span><span class="o">*</span><span class="n">rhs</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;Under-determined System. &#39;</span>
                                      <span class="s1">&#39;Try M.gauss_jordan_solve(rhs)&#39;</span><span class="p">)</span>
        <span class="n">Y</span> <span class="o">=</span> <span class="n">L</span><span class="o">.</span><span class="n">_lower_triangular_solve</span><span class="p">(</span><span class="n">rhs</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">L</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">_upper_triangular_solve</span><span class="p">(</span><span class="n">Y</span><span class="p">)</span></div>

<div class="viewcode-block" id="MatrixBase.diagonal_solve"><a class="viewcode-back" href="../../../modules/matrices/matrices.html#sympy.matrices.immutable.MatrixBase.diagonal_solve">[docs]</a>    <span class="k">def</span> <span class="nf">diagonal_solve</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rhs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Solves Ax = B efficiently, where A is a diagonal Matrix,</span>
<span class="sd">        with non-zero diagonal entries.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.matrices import Matrix, eye</span>
<span class="sd">        &gt;&gt;&gt; A = eye(2)*2</span>
<span class="sd">        &gt;&gt;&gt; B = Matrix([[1, 2], [3, 4]])</span>
<span class="sd">        &gt;&gt;&gt; A.diagonal_solve(B) == B/2</span>
<span class="sd">        True</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        lower_triangular_solve</span>
<span class="sd">        upper_triangular_solve</span>
<span class="sd">        gauss_jordan_solve</span>
<span class="sd">        cholesky_solve</span>
<span class="sd">        LDLsolve</span>
<span class="sd">        LUsolve</span>
<span class="sd">        QRsolve</span>
<span class="sd">        pinv_solve</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_diagonal</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Matrix should be diagonal&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">rhs</span><span class="o">.</span><span class="n">rows</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Size mis-match&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_diagonal_solve</span><span class="p">(</span><span class="n">rhs</span><span class="p">)</span></div>

<div class="viewcode-block" id="MatrixBase.LDLsolve"><a class="viewcode-back" href="../../../modules/matrices/matrices.html#sympy.matrices.immutable.MatrixBase.LDLsolve">[docs]</a>    <span class="k">def</span> <span class="nf">LDLsolve</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rhs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Solves Ax = B using LDL decomposition,</span>
<span class="sd">        for a general square and non-singular matrix.</span>

<span class="sd">        For a non-square matrix with rows &gt; cols,</span>
<span class="sd">        the least squares solution is returned.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.matrices import Matrix, eye</span>
<span class="sd">        &gt;&gt;&gt; A = eye(2)*2</span>
<span class="sd">        &gt;&gt;&gt; B = Matrix([[1, 2], [3, 4]])</span>
<span class="sd">        &gt;&gt;&gt; A.LDLsolve(B) == B/2</span>
<span class="sd">        True</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        LDLdecomposition</span>
<span class="sd">        lower_triangular_solve</span>
<span class="sd">        upper_triangular_solve</span>
<span class="sd">        gauss_jordan_solve</span>
<span class="sd">        cholesky_solve</span>
<span class="sd">        diagonal_solve</span>
<span class="sd">        LUsolve</span>
<span class="sd">        QRsolve</span>
<span class="sd">        pinv_solve</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_symmetric</span><span class="p">():</span>
            <span class="n">L</span><span class="p">,</span> <span class="n">D</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">LDLdecomposition</span><span class="p">()</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">rows</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">:</span>
            <span class="n">L</span><span class="p">,</span> <span class="n">D</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">T</span><span class="o">*</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">LDLdecomposition</span><span class="p">()</span>
            <span class="n">rhs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">T</span><span class="o">*</span><span class="n">rhs</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;Under-determined System. &#39;</span>
                                      <span class="s1">&#39;Try M.gauss_jordan_solve(rhs)&#39;</span><span class="p">)</span>
        <span class="n">Y</span> <span class="o">=</span> <span class="n">L</span><span class="o">.</span><span class="n">_lower_triangular_solve</span><span class="p">(</span><span class="n">rhs</span><span class="p">)</span>
        <span class="n">Z</span> <span class="o">=</span> <span class="n">D</span><span class="o">.</span><span class="n">_diagonal_solve</span><span class="p">(</span><span class="n">Y</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">L</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">_upper_triangular_solve</span><span class="p">(</span><span class="n">Z</span><span class="p">)</span></div>

<div class="viewcode-block" id="MatrixBase.solve_least_squares"><a class="viewcode-back" href="../../../modules/matrices/matrices.html#sympy.matrices.immutable.MatrixBase.solve_least_squares">[docs]</a>    <span class="k">def</span> <span class="nf">solve_least_squares</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rhs</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;CH&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the least-square fit to the data.</span>

<span class="sd">        By default the cholesky_solve routine is used (method=&#39;CH&#39;); other</span>
<span class="sd">        methods of matrix inversion can be used. To find out which are</span>
<span class="sd">        available, see the docstring of the .inv() method.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.matrices import Matrix, ones</span>
<span class="sd">        &gt;&gt;&gt; A = Matrix([1, 2, 3])</span>
<span class="sd">        &gt;&gt;&gt; B = Matrix([2, 3, 4])</span>
<span class="sd">        &gt;&gt;&gt; S = Matrix(A.row_join(B))</span>
<span class="sd">        &gt;&gt;&gt; S</span>
<span class="sd">        Matrix([</span>
<span class="sd">        [1, 2],</span>
<span class="sd">        [2, 3],</span>
<span class="sd">        [3, 4]])</span>

<span class="sd">        If each line of S represent coefficients of Ax + By</span>
<span class="sd">        and x and y are [2, 3] then S*xy is:</span>

<span class="sd">        &gt;&gt;&gt; r = S*Matrix([2, 3]); r</span>
<span class="sd">        Matrix([</span>
<span class="sd">        [ 8],</span>
<span class="sd">        [13],</span>
<span class="sd">        [18]])</span>

<span class="sd">        But let&#39;s add 1 to the middle value and then solve for the</span>
<span class="sd">        least-squares value of xy:</span>

<span class="sd">        &gt;&gt;&gt; xy = S.solve_least_squares(Matrix([8, 14, 18])); xy</span>
<span class="sd">        Matrix([</span>
<span class="sd">        [ 5/3],</span>
<span class="sd">        [10/3]])</span>

<span class="sd">        The error is given by S*xy - r:</span>

<span class="sd">        &gt;&gt;&gt; S*xy - r</span>
<span class="sd">        Matrix([</span>
<span class="sd">        [1/3],</span>
<span class="sd">        [1/3],</span>
<span class="sd">        [1/3]])</span>
<span class="sd">        &gt;&gt;&gt; _.norm().n(2)</span>
<span class="sd">        0.58</span>

<span class="sd">        If a different xy is used, the norm will be higher:</span>

<span class="sd">        &gt;&gt;&gt; xy += ones(2, 1)/10</span>
<span class="sd">        &gt;&gt;&gt; (S*xy - r).norm().n(2)</span>
<span class="sd">        1.5</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;CH&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">cholesky_solve</span><span class="p">(</span><span class="n">rhs</span><span class="p">)</span>
        <span class="n">t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">T</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">t</span><span class="o">*</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">)</span><span class="o">*</span><span class="n">t</span><span class="o">*</span><span class="n">rhs</span></div>

<div class="viewcode-block" id="MatrixBase.solve"><a class="viewcode-back" href="../../../modules/matrices/matrices.html#sympy.matrices.immutable.MatrixBase.solve">[docs]</a>    <span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rhs</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;GE&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return solution to self*soln = rhs using given inversion method.</span>

<span class="sd">        For a list of possible inversion methods, see the .inv() docstring.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_square</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">rows</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Under-determined system. &#39;</span>
                                 <span class="s1">&#39;Try M.gauss_jordan_solve(rhs)&#39;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">rows</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;For over-determined system, M, having &#39;</span>
                    <span class="s1">&#39;more rows than columns, try M.solve_least_squares(rhs).&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">)</span><span class="o">*</span><span class="n">rhs</span></div>

    <span class="k">def</span> <span class="nf">__mathml__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">mml</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="p">):</span>
            <span class="n">mml</span> <span class="o">+=</span> <span class="s2">&quot;&lt;matrixrow&gt;&quot;</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">):</span>
                <span class="n">mml</span> <span class="o">+=</span> <span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">__mathml__</span><span class="p">()</span>
            <span class="n">mml</span> <span class="o">+=</span> <span class="s2">&quot;&lt;/matrixrow&gt;&quot;</span>
        <span class="k">return</span> <span class="s2">&quot;&lt;matrix&gt;&quot;</span> <span class="o">+</span> <span class="n">mml</span> <span class="o">+</span> <span class="s2">&quot;&lt;/matrix&gt;&quot;</span>

<div class="viewcode-block" id="MatrixBase.extract"><a class="viewcode-back" href="../../../modules/matrices/matrices.html#sympy.matrices.immutable.MatrixBase.extract">[docs]</a>    <span class="k">def</span> <span class="nf">extract</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rowsList</span><span class="p">,</span> <span class="n">colsList</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a submatrix by specifying a list of rows and columns.</span>
<span class="sd">        Negative indices can be given. All indices must be in the range</span>
<span class="sd">        -n &lt;= i &lt; n where n is the number of rows or columns.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy import Matrix</span>
<span class="sd">        &gt;&gt;&gt; m = Matrix(4, 3, range(12))</span>
<span class="sd">        &gt;&gt;&gt; m</span>
<span class="sd">        Matrix([</span>
<span class="sd">        [0,  1,  2],</span>
<span class="sd">        [3,  4,  5],</span>
<span class="sd">        [6,  7,  8],</span>
<span class="sd">        [9, 10, 11]])</span>
<span class="sd">        &gt;&gt;&gt; m.extract([0, 1, 3], [0, 1])</span>
<span class="sd">        Matrix([</span>
<span class="sd">        [0,  1],</span>
<span class="sd">        [3,  4],</span>
<span class="sd">        [9, 10]])</span>

<span class="sd">        Rows or columns can be repeated:</span>

<span class="sd">        &gt;&gt;&gt; m.extract([0, 0, 1], [-1])</span>
<span class="sd">        Matrix([</span>
<span class="sd">        [2],</span>
<span class="sd">        [2],</span>
<span class="sd">        [5]])</span>

<span class="sd">        Every other row can be taken by using range to provide the indices:</span>

<span class="sd">        &gt;&gt;&gt; m.extract(range(0, m.rows, 2), [-1])</span>
<span class="sd">        Matrix([</span>
<span class="sd">        [2],</span>
<span class="sd">        [8]])</span>

<span class="sd">        RowsList or colsList can also be a list of booleans, in which case</span>
<span class="sd">        the rows or columns corresponding to the True values will be selected:</span>

<span class="sd">        &gt;&gt;&gt; m.extract([0, 1, 2, 3], [True, False, True])</span>
<span class="sd">        Matrix([</span>
<span class="sd">        [0,  2],</span>
<span class="sd">        [3,  5],</span>
<span class="sd">        [6,  8],</span>
<span class="sd">        [9, 11]])</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">cols</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span>
        <span class="n">flat_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mat</span>
        <span class="k">if</span> <span class="n">rowsList</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">rowsList</span><span class="p">):</span>
            <span class="n">rowsList</span> <span class="o">=</span> <span class="p">[</span><span class="n">index</span> <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">item</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">rowsList</span><span class="p">)</span> <span class="k">if</span> <span class="n">item</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">colsList</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">colsList</span><span class="p">):</span>
            <span class="n">colsList</span> <span class="o">=</span> <span class="p">[</span><span class="n">index</span> <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">item</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">colsList</span><span class="p">)</span> <span class="k">if</span> <span class="n">item</span><span class="p">]</span>

        <span class="n">rowsList</span> <span class="o">=</span> <span class="p">[</span><span class="n">a2idx</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">rowsList</span><span class="p">]</span>
        <span class="n">colsList</span> <span class="o">=</span> <span class="p">[</span><span class="n">a2idx</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">colsList</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_new</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">rowsList</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">colsList</span><span class="p">),</span>
                <span class="k">lambda</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">:</span> <span class="n">flat_list</span><span class="p">[</span><span class="n">rowsList</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">cols</span> <span class="o">+</span> <span class="n">colsList</span><span class="p">[</span><span class="n">j</span><span class="p">]])</span></div>

<div class="viewcode-block" id="MatrixBase.key2bounds"><a class="viewcode-back" href="../../../modules/matrices/matrices.html#sympy.matrices.immutable.MatrixBase.key2bounds">[docs]</a>    <span class="k">def</span> <span class="nf">key2bounds</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">keys</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Converts a key with potentially mixed types of keys (integer and slice)</span>
<span class="sd">        into a tuple of ranges and raises an error if any index is out of self&#39;s</span>
<span class="sd">        range.</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        key2ij</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">islice</span><span class="p">,</span> <span class="n">jslice</span> <span class="o">=</span> <span class="p">[</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="nb">slice</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">islice</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="p">:</span>
                <span class="n">rlo</span> <span class="o">=</span> <span class="n">rhi</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">rlo</span><span class="p">,</span> <span class="n">rhi</span> <span class="o">=</span> <span class="n">keys</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">indices</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="p">)[:</span><span class="mi">2</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">rlo</span> <span class="o">=</span> <span class="n">a2idx</span><span class="p">(</span><span class="n">keys</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="p">)</span>
            <span class="n">rhi</span> <span class="o">=</span> <span class="n">rlo</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">jslice</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">:</span>
                <span class="n">clo</span> <span class="o">=</span> <span class="n">chi</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">clo</span><span class="p">,</span> <span class="n">chi</span> <span class="o">=</span> <span class="n">keys</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">indices</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">)[:</span><span class="mi">2</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">clo</span> <span class="o">=</span> <span class="n">a2idx</span><span class="p">(</span><span class="n">keys</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">)</span>
            <span class="n">chi</span> <span class="o">=</span> <span class="n">clo</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">rlo</span><span class="p">,</span> <span class="n">rhi</span><span class="p">,</span> <span class="n">clo</span><span class="p">,</span> <span class="n">chi</span></div>

<div class="viewcode-block" id="MatrixBase.key2ij"><a class="viewcode-back" href="../../../modules/matrices/matrices.html#sympy.matrices.immutable.MatrixBase.key2ij">[docs]</a>    <span class="k">def</span> <span class="nf">key2ij</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Converts key into canonical form, converting integers or indexable</span>
<span class="sd">        items into valid integers for self&#39;s range or returning slices</span>
<span class="sd">        unchanged.</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        key2bounds</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">is_sequence</span><span class="p">(</span><span class="n">key</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;key must be a sequence of length 2&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">a2idx</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span> <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="nb">slice</span><span class="p">)</span> <span class="k">else</span> <span class="n">i</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">)]</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">key</span><span class="o">.</span><span class="n">indices</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">))[:</span><span class="mi">2</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">divmod</span><span class="p">(</span><span class="n">a2idx</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)),</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">)</span></div>

<div class="viewcode-block" id="MatrixBase.evalf"><a class="viewcode-back" href="../../../modules/matrices/matrices.html#sympy.matrices.immutable.MatrixBase.evalf">[docs]</a>    <span class="k">def</span> <span class="nf">evalf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prec</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Apply evalf() to each element of self.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">applyfunc</span><span class="p">(</span><span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="n">i</span><span class="o">.</span><span class="n">evalf</span><span class="p">(</span><span class="n">prec</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">))</span></div>

    <span class="n">n</span> <span class="o">=</span> <span class="n">evalf</span>

<div class="viewcode-block" id="MatrixBase.atoms"><a class="viewcode-back" href="../../../modules/matrices/matrices.html#sympy.matrices.immutable.MatrixBase.atoms">[docs]</a>    <span class="k">def</span> <span class="nf">atoms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">types</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the atoms that form the current object.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.abc import x, y</span>
<span class="sd">        &gt;&gt;&gt; from sympy.matrices import Matrix</span>
<span class="sd">        &gt;&gt;&gt; Matrix([[x]])</span>
<span class="sd">        Matrix([[x]])</span>
<span class="sd">        &gt;&gt;&gt; _.atoms()</span>
<span class="sd">        set([x])</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">types</span><span class="p">:</span>
            <span class="n">types</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span>
                <span class="p">[</span><span class="n">t</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="nb">type</span><span class="p">)</span> <span class="k">else</span> <span class="nb">type</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">types</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">types</span> <span class="o">=</span> <span class="p">(</span><span class="n">Atom</span><span class="p">,)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="n">result</span><span class="o">.</span><span class="n">update</span><span class="p">(</span> <span class="n">i</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="o">*</span><span class="n">types</span><span class="p">)</span> <span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">free_symbols</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the free symbols within the matrix.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.abc import x</span>
<span class="sd">        &gt;&gt;&gt; from sympy.matrices import Matrix</span>
<span class="sd">        &gt;&gt;&gt; Matrix([[x], [1]]).free_symbols</span>
<span class="sd">        set([x])</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="nb">set</span><span class="p">()</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">i</span><span class="o">.</span><span class="n">free_symbols</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">])</span>

<div class="viewcode-block" id="MatrixBase.subs"><a class="viewcode-back" href="../../../modules/matrices/matrices.html#sympy.matrices.immutable.MatrixBase.subs">[docs]</a>    <span class="k">def</span> <span class="nf">subs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>  <span class="c1"># should mirror core.basic.subs</span>
        <span class="sd">&quot;&quot;&quot;Return a new matrix with subs applied to each entry.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.abc import x, y</span>
<span class="sd">        &gt;&gt;&gt; from sympy.matrices import SparseMatrix, Matrix</span>
<span class="sd">        &gt;&gt;&gt; SparseMatrix(1, 1, [x])</span>
<span class="sd">        Matrix([[x]])</span>
<span class="sd">        &gt;&gt;&gt; _.subs(x, y)</span>
<span class="sd">        Matrix([[y]])</span>
<span class="sd">        &gt;&gt;&gt; Matrix(_).subs(y, x)</span>
<span class="sd">        Matrix([[x]])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">applyfunc</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">))</span></div>

<div class="viewcode-block" id="MatrixBase.xreplace"><a class="viewcode-back" href="../../../modules/matrices/matrices.html#sympy.matrices.immutable.MatrixBase.xreplace">[docs]</a>    <span class="k">def</span> <span class="nf">xreplace</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rule</span><span class="p">):</span>  <span class="c1"># should mirror core.basic.xreplace</span>
        <span class="sd">&quot;&quot;&quot;Return a new matrix with xreplace applied to each entry.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.abc import x, y</span>
<span class="sd">        &gt;&gt;&gt; from sympy.matrices import SparseMatrix, Matrix</span>
<span class="sd">        &gt;&gt;&gt; SparseMatrix(1, 1, [x])</span>
<span class="sd">        Matrix([[x]])</span>
<span class="sd">        &gt;&gt;&gt; _.xreplace({x: y})</span>
<span class="sd">        Matrix([[y]])</span>
<span class="sd">        &gt;&gt;&gt; Matrix(_).xreplace({y: x})</span>
<span class="sd">        Matrix([[x]])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">applyfunc</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">xreplace</span><span class="p">(</span><span class="n">rule</span><span class="p">))</span></div>

<div class="viewcode-block" id="MatrixBase.expand"><a class="viewcode-back" href="../../../modules/matrices/matrices.html#sympy.matrices.immutable.MatrixBase.expand">[docs]</a>    <span class="k">def</span> <span class="nf">expand</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">modulus</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">power_base</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">power_exp</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
            <span class="n">mul</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">log</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">multinomial</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">basic</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="o">**</span><span class="n">hints</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Apply core.function.expand to each entry of the matrix.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.abc import x</span>
<span class="sd">        &gt;&gt;&gt; from sympy.matrices import Matrix</span>
<span class="sd">        &gt;&gt;&gt; Matrix(1, 1, [x*(x+1)])</span>
<span class="sd">        Matrix([[x*(x + 1)]])</span>
<span class="sd">        &gt;&gt;&gt; _.expand()</span>
<span class="sd">        Matrix([[x**2 + x]])</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">applyfunc</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span>
                              <span class="n">deep</span><span class="p">,</span> <span class="n">modulus</span><span class="p">,</span> <span class="n">power_base</span><span class="p">,</span> <span class="n">power_exp</span><span class="p">,</span> <span class="n">mul</span><span class="p">,</span> <span class="n">log</span><span class="p">,</span> <span class="n">multinomial</span><span class="p">,</span> <span class="n">basic</span><span class="p">,</span>
        <span class="o">**</span><span class="n">hints</span><span class="p">))</span></div>

<div class="viewcode-block" id="MatrixBase.simplify"><a class="viewcode-back" href="../../../modules/matrices/matrices.html#sympy.matrices.immutable.MatrixBase.simplify">[docs]</a>    <span class="k">def</span> <span class="nf">simplify</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ratio</span><span class="o">=</span><span class="mf">1.7</span><span class="p">,</span> <span class="n">measure</span><span class="o">=</span><span class="n">count_ops</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Apply simplify to each element of the matrix.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.abc import x, y</span>
<span class="sd">        &gt;&gt;&gt; from sympy import sin, cos</span>
<span class="sd">        &gt;&gt;&gt; from sympy.matrices import SparseMatrix</span>
<span class="sd">        &gt;&gt;&gt; SparseMatrix(1, 1, [x*sin(y)**2 + x*cos(y)**2])</span>
<span class="sd">        Matrix([[x*sin(y)**2 + x*cos(y)**2]])</span>
<span class="sd">        &gt;&gt;&gt; _.simplify()</span>
<span class="sd">        Matrix([[x]])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">applyfunc</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">simplify</span><span class="p">(</span><span class="n">ratio</span><span class="p">,</span> <span class="n">measure</span><span class="p">))</span></div>
    <span class="n">_eval_simplify</span> <span class="o">=</span> <span class="n">simplify</span>

<div class="viewcode-block" id="MatrixBase.refine"><a class="viewcode-back" href="../../../modules/matrices/matrices.html#sympy.matrices.immutable.MatrixBase.refine">[docs]</a>    <span class="k">def</span> <span class="nf">refine</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">assumptions</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Apply refine to each element of the matrix.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy import Symbol, Matrix, Abs, sqrt, Q</span>
<span class="sd">        &gt;&gt;&gt; x = Symbol(&#39;x&#39;)</span>
<span class="sd">        &gt;&gt;&gt; Matrix([[Abs(x)**2, sqrt(x**2)],[sqrt(x**2), Abs(x)**2]])</span>
<span class="sd">        Matrix([</span>
<span class="sd">        [ Abs(x)**2, sqrt(x**2)],</span>
<span class="sd">        [sqrt(x**2),  Abs(x)**2]])</span>
<span class="sd">        &gt;&gt;&gt; _.refine(Q.real(x))</span>
<span class="sd">        Matrix([</span>
<span class="sd">        [  x**2, Abs(x)],</span>
<span class="sd">        [Abs(x),   x**2]])</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">applyfunc</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">refine</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">assumptions</span><span class="p">))</span></div>

    <span class="k">def</span> <span class="nf">doit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_new</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">,</span> <span class="p">[</span><span class="n">i</span><span class="o">.</span><span class="n">doit</span><span class="p">()</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mat</span><span class="p">])</span>

<div class="viewcode-block" id="MatrixBase.print_nonzero"><a class="viewcode-back" href="../../../modules/matrices/matrices.html#sympy.matrices.immutable.MatrixBase.print_nonzero">[docs]</a>    <span class="k">def</span> <span class="nf">print_nonzero</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">symb</span><span class="o">=</span><span class="s2">&quot;X&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Shows location of non-zero entries for fast shape lookup.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.matrices import Matrix, eye</span>
<span class="sd">        &gt;&gt;&gt; m = Matrix(2, 3, lambda i, j: i*3+j)</span>
<span class="sd">        &gt;&gt;&gt; m</span>
<span class="sd">        Matrix([</span>
<span class="sd">        [0, 1, 2],</span>
<span class="sd">        [3, 4, 5]])</span>
<span class="sd">        &gt;&gt;&gt; m.print_nonzero()</span>
<span class="sd">        [ XX]</span>
<span class="sd">        [XXX]</span>
<span class="sd">        &gt;&gt;&gt; m = eye(4)</span>
<span class="sd">        &gt;&gt;&gt; m.print_nonzero(&quot;x&quot;)</span>
<span class="sd">        [x   ]</span>
<span class="sd">        [ x  ]</span>
<span class="sd">        [  x ]</span>
<span class="sd">        [   x]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">s</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="p">):</span>
            <span class="n">line</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">):</span>
                <span class="k">if</span> <span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">line</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">line</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">symb</span><span class="p">))</span>
            <span class="n">s</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;[</span><span class="si">%s</span><span class="s2">]&quot;</span> <span class="o">%</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">line</span><span class="p">))</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">s</span><span class="p">))</span></div>

<div class="viewcode-block" id="MatrixBase.LUsolve"><a class="viewcode-back" href="../../../modules/matrices/matrices.html#sympy.matrices.immutable.MatrixBase.LUsolve">[docs]</a>    <span class="k">def</span> <span class="nf">LUsolve</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rhs</span><span class="p">,</span> <span class="n">iszerofunc</span><span class="o">=</span><span class="n">_iszero</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Solve the linear system Ax = rhs for x where A = self.</span>

<span class="sd">        This is for symbolic matrices, for real or complex ones use</span>
<span class="sd">        mpmath.lu_solve or mpmath.qr_solve.</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        lower_triangular_solve</span>
<span class="sd">        upper_triangular_solve</span>
<span class="sd">        gauss_jordan_solve</span>
<span class="sd">        cholesky_solve</span>
<span class="sd">        diagonal_solve</span>
<span class="sd">        LDLsolve</span>
<span class="sd">        QRsolve</span>
<span class="sd">        pinv_solve</span>
<span class="sd">        LUdecomposition</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">rhs</span><span class="o">.</span><span class="n">rows</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ShapeError</span><span class="p">(</span><span class="s2">&quot;`self` and `rhs` must have the same number of rows.&quot;</span><span class="p">)</span>

        <span class="n">A</span><span class="p">,</span> <span class="n">perm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">LUdecomposition_Simple</span><span class="p">(</span><span class="n">iszerofunc</span><span class="o">=</span><span class="n">_iszero</span><span class="p">)</span>
        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rows</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">rhs</span><span class="o">.</span><span class="n">permuteFwd</span><span class="p">(</span><span class="n">perm</span><span class="p">)</span><span class="o">.</span><span class="n">as_mutable</span><span class="p">()</span>
        <span class="c1"># forward substitution, all diag entries are scaled to 1</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
                <span class="n">scale</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>
                <span class="n">b</span><span class="o">.</span><span class="n">zip_row_op</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">x</span> <span class="o">-</span> <span class="n">y</span><span class="o">*</span><span class="n">scale</span><span class="p">)</span>
        <span class="c1"># backward substitution</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
                <span class="n">scale</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>
                <span class="n">b</span><span class="o">.</span><span class="n">zip_row_op</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">x</span> <span class="o">-</span> <span class="n">y</span><span class="o">*</span><span class="n">scale</span><span class="p">)</span>
            <span class="n">scale</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span>
            <span class="n">b</span><span class="o">.</span><span class="n">row_op</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">_</span><span class="p">:</span> <span class="n">x</span><span class="o">/</span><span class="n">scale</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">rhs</span><span class="o">.</span><span class="n">__class__</span><span class="p">(</span><span class="n">b</span><span class="p">)</span></div>

<div class="viewcode-block" id="MatrixBase.LUdecomposition"><a class="viewcode-back" href="../../../modules/matrices/matrices.html#sympy.matrices.immutable.MatrixBase.LUdecomposition">[docs]</a>    <span class="k">def</span> <span class="nf">LUdecomposition</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">iszerofunc</span><span class="o">=</span><span class="n">_iszero</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the decomposition LU and the row swaps p.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy import Matrix</span>
<span class="sd">        &gt;&gt;&gt; a = Matrix([[4, 3], [6, 3]])</span>
<span class="sd">        &gt;&gt;&gt; L, U, _ = a.LUdecomposition()</span>
<span class="sd">        &gt;&gt;&gt; L</span>
<span class="sd">        Matrix([</span>
<span class="sd">        [  1, 0],</span>
<span class="sd">        [3/2, 1]])</span>
<span class="sd">        &gt;&gt;&gt; U</span>
<span class="sd">        Matrix([</span>
<span class="sd">        [4,    3],</span>
<span class="sd">        [0, -3/2]])</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        cholesky</span>
<span class="sd">        LDLdecomposition</span>
<span class="sd">        QRdecomposition</span>
<span class="sd">        LUdecomposition_Simple</span>
<span class="sd">        LUdecompositionFF</span>
<span class="sd">        LUsolve</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">combined</span><span class="p">,</span> <span class="n">p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">LUdecomposition_Simple</span><span class="p">(</span><span class="n">iszerofunc</span><span class="o">=</span><span class="n">_iszero</span><span class="p">)</span>
        <span class="n">L</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="p">)</span>
        <span class="n">U</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="n">j</span><span class="p">:</span>
                    <span class="n">L</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">combined</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">j</span><span class="p">:</span>
                        <span class="n">L</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
                    <span class="n">U</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">combined</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">L</span><span class="p">,</span> <span class="n">U</span><span class="p">,</span> <span class="n">p</span></div>

<div class="viewcode-block" id="MatrixBase.LUdecomposition_Simple"><a class="viewcode-back" href="../../../modules/matrices/matrices.html#sympy.matrices.immutable.MatrixBase.LUdecomposition_Simple">[docs]</a>    <span class="k">def</span> <span class="nf">LUdecomposition_Simple</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">iszerofunc</span><span class="o">=</span><span class="n">_iszero</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns A comprised of L, U (L&#39;s diag entries are 1) and</span>
<span class="sd">        p which is the list of the row swaps (in order).</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        LUdecomposition</span>
<span class="sd">        LUdecompositionFF</span>
<span class="sd">        LUsolve</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_square</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">NonSquareMatrixError</span><span class="p">(</span><span class="s2">&quot;A Matrix must be square to apply LUdecomposition_Simple().&quot;</span><span class="p">)</span>
        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rows</span>
        <span class="n">A</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_mutable</span><span class="p">()</span>
        <span class="n">p</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># factorization</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">j</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
                    <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">-</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span><span class="o">*</span><span class="n">A</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>
            <span class="n">pivot</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">j</span><span class="p">):</span>
                    <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">-</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span><span class="o">*</span><span class="n">A</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>
                <span class="c1"># find the first non-zero pivot, includes any expression</span>
                <span class="k">if</span> <span class="n">pivot</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">iszerofunc</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]):</span>
                    <span class="n">pivot</span> <span class="o">=</span> <span class="n">i</span>
            <span class="k">if</span> <span class="n">pivot</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># this result is based on iszerofunc&#39;s analysis of the possible pivots, so even though</span>
                <span class="c1"># the element may not be strictly zero, the supplied iszerofunc&#39;s evaluation gave True</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;No nonzero pivot found; inversion failed.&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">pivot</span> <span class="o">!=</span> <span class="n">j</span><span class="p">:</span>  <span class="c1"># row must be swapped</span>
                <span class="n">A</span><span class="o">.</span><span class="n">row_swap</span><span class="p">(</span><span class="n">pivot</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>
                <span class="n">p</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">pivot</span><span class="p">,</span> <span class="n">j</span><span class="p">])</span>
            <span class="n">scale</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
                <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span><span class="o">*</span><span class="n">scale</span>
        <span class="k">return</span> <span class="n">A</span><span class="p">,</span> <span class="n">p</span></div>

<div class="viewcode-block" id="MatrixBase.LUdecompositionFF"><a class="viewcode-back" href="../../../modules/matrices/matrices.html#sympy.matrices.immutable.MatrixBase.LUdecompositionFF">[docs]</a>    <span class="k">def</span> <span class="nf">LUdecompositionFF</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compute a fraction-free LU decomposition.</span>

<span class="sd">        Returns 4 matrices P, L, D, U such that PA = L D**-1 U.</span>
<span class="sd">        If the elements of the matrix belong to some integral domain I, then all</span>
<span class="sd">        elements of L, D and U are guaranteed to belong to I.</span>

<span class="sd">        **Reference**</span>
<span class="sd">            - W. Zhou &amp; D.J. Jeffrey, &quot;Fraction-free matrix factors: new forms</span>
<span class="sd">              for LU and QR factors&quot;. Frontiers in Computer Science in China,</span>
<span class="sd">              Vol 2, no. 1, pp. 67-80, 2008.</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        LUdecomposition</span>
<span class="sd">        LUdecomposition_Simple</span>
<span class="sd">        LUsolve</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">sympy.matrices</span> <span class="kn">import</span> <span class="n">SparseMatrix</span>
        <span class="n">zeros</span> <span class="o">=</span> <span class="n">SparseMatrix</span><span class="o">.</span><span class="n">zeros</span>
        <span class="n">eye</span> <span class="o">=</span> <span class="n">SparseMatrix</span><span class="o">.</span><span class="n">eye</span>

        <span class="n">n</span><span class="p">,</span> <span class="n">m</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span>
        <span class="n">U</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">P</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_mutable</span><span class="p">(),</span> <span class="n">eye</span><span class="p">(</span><span class="n">n</span><span class="p">),</span> <span class="n">eye</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
        <span class="n">DD</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
        <span class="n">oldpivot</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">U</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">kpivot</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">U</span><span class="p">[</span><span class="n">kpivot</span><span class="p">,</span> <span class="n">k</span><span class="p">]:</span>
                        <span class="k">break</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Matrix is not full rank&quot;</span><span class="p">)</span>
                <span class="n">U</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">k</span><span class="p">:],</span> <span class="n">U</span><span class="p">[</span><span class="n">kpivot</span><span class="p">,</span> <span class="n">k</span><span class="p">:]</span> <span class="o">=</span> <span class="n">U</span><span class="p">[</span><span class="n">kpivot</span><span class="p">,</span> <span class="n">k</span><span class="p">:],</span> <span class="n">U</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">k</span><span class="p">:]</span>
                <span class="n">L</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="p">:</span><span class="n">k</span><span class="p">],</span> <span class="n">L</span><span class="p">[</span><span class="n">kpivot</span><span class="p">,</span> <span class="p">:</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">L</span><span class="p">[</span><span class="n">kpivot</span><span class="p">,</span> <span class="p">:</span><span class="n">k</span><span class="p">],</span> <span class="n">L</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="p">:</span><span class="n">k</span><span class="p">]</span>
                <span class="n">P</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="p">:],</span> <span class="n">P</span><span class="p">[</span><span class="n">kpivot</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">P</span><span class="p">[</span><span class="n">kpivot</span><span class="p">,</span> <span class="p">:],</span> <span class="n">P</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="p">:]</span>
            <span class="n">L</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">Ukk</span> <span class="o">=</span> <span class="n">U</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span>
            <span class="n">DD</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">oldpivot</span><span class="o">*</span><span class="n">Ukk</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
                <span class="n">L</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">Uik</span> <span class="o">=</span> <span class="n">U</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">m</span><span class="p">):</span>
                    <span class="n">U</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">Ukk</span><span class="o">*</span><span class="n">U</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">-</span> <span class="n">U</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span><span class="o">*</span><span class="n">Uik</span><span class="p">)</span> <span class="o">/</span> <span class="n">oldpivot</span>
                <span class="n">U</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">oldpivot</span> <span class="o">=</span> <span class="n">Ukk</span>
        <span class="n">DD</span><span class="p">[</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">oldpivot</span>
        <span class="k">return</span> <span class="n">P</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">DD</span><span class="p">,</span> <span class="n">U</span></div>

<div class="viewcode-block" id="MatrixBase.cofactorMatrix"><a class="viewcode-back" href="../../../modules/matrices/matrices.html#sympy.matrices.immutable.MatrixBase.cofactorMatrix">[docs]</a>    <span class="k">def</span> <span class="nf">cofactorMatrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;berkowitz&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a matrix containing the cofactor of each element.</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        cofactor</span>
<span class="sd">        minorEntry</span>
<span class="sd">        minorMatrix</span>
<span class="sd">        adjugate</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_new</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">cofactor</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">method</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">out</span></div>

<div class="viewcode-block" id="MatrixBase.minorEntry"><a class="viewcode-back" href="../../../modules/matrices/matrices.html#sympy.matrices.immutable.MatrixBase.minorEntry">[docs]</a>    <span class="k">def</span> <span class="nf">minorEntry</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;berkowitz&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate the minor of an element.</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        minorMatrix</span>
<span class="sd">        cofactor</span>
<span class="sd">        cofactorMatrix</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">rows</span> <span class="ow">or</span> <span class="ow">not</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;`i` and `j` must satisfy 0 &lt;= i &lt; `self.rows` &quot;</span> <span class="o">+</span>
                <span class="s2">&quot;(</span><span class="si">%d</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">rows</span> <span class="o">+</span> <span class="s2">&quot;and 0 &lt;= j &lt; `self.cols` (</span><span class="si">%d</span><span class="s2">).&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">minorMatrix</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span><span class="o">.</span><span class="n">det</span><span class="p">(</span><span class="n">method</span><span class="p">)</span></div>

<div class="viewcode-block" id="MatrixBase.minorMatrix"><a class="viewcode-back" href="../../../modules/matrices/matrices.html#sympy.matrices.immutable.MatrixBase.minorMatrix">[docs]</a>    <span class="k">def</span> <span class="nf">minorMatrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Creates the minor matrix of a given element.</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        minorEntry</span>
<span class="sd">        cofactor</span>
<span class="sd">        cofactorMatrix</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">rows</span> <span class="ow">or</span> <span class="ow">not</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;`i` and `j` must satisfy 0 &lt;= i &lt; `self.rows` &quot;</span> <span class="o">+</span>
                <span class="s2">&quot;(</span><span class="si">%d</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">rows</span> <span class="o">+</span> <span class="s2">&quot;and 0 &lt;= j &lt; `self.cols` (</span><span class="si">%d</span><span class="s2">).&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">)</span>
        <span class="n">M</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_mutable</span><span class="p">()</span>
        <span class="n">M</span><span class="o">.</span><span class="n">row_del</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="n">M</span><span class="o">.</span><span class="n">col_del</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_new</span><span class="p">(</span><span class="n">M</span><span class="p">)</span></div>

<div class="viewcode-block" id="MatrixBase.cofactor"><a class="viewcode-back" href="../../../modules/matrices/matrices.html#sympy.matrices.immutable.MatrixBase.cofactor">[docs]</a>    <span class="k">def</span> <span class="nf">cofactor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;berkowitz&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate the cofactor of an element.</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        cofactorMatrix</span>
<span class="sd">        minorEntry</span>
<span class="sd">        minorMatrix</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="n">j</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">minorEntry</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">method</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">minorEntry</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">method</span><span class="p">)</span></div>

<div class="viewcode-block" id="MatrixBase.jacobian"><a class="viewcode-back" href="../../../modules/matrices/matrices.html#sympy.matrices.immutable.MatrixBase.jacobian">[docs]</a>    <span class="k">def</span> <span class="nf">jacobian</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculates the Jacobian matrix (derivative of a vectorial function).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ==========</span>

<span class="sd">        self : vector of expressions representing functions f_i(x_1, ..., x_n).</span>
<span class="sd">        X : set of x_i&#39;s in order, it can be a list or a Matrix</span>

<span class="sd">        Both self and X can be a row or a column matrix in any order</span>
<span class="sd">        (i.e., jacobian() should always work).</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy import sin, cos, Matrix</span>
<span class="sd">        &gt;&gt;&gt; from sympy.abc import rho, phi</span>
<span class="sd">        &gt;&gt;&gt; X = Matrix([rho*cos(phi), rho*sin(phi), rho**2])</span>
<span class="sd">        &gt;&gt;&gt; Y = Matrix([rho, phi])</span>
<span class="sd">        &gt;&gt;&gt; X.jacobian(Y)</span>
<span class="sd">        Matrix([</span>
<span class="sd">        [cos(phi), -rho*sin(phi)],</span>
<span class="sd">        [sin(phi),  rho*cos(phi)],</span>
<span class="sd">        [   2*rho,             0]])</span>
<span class="sd">        &gt;&gt;&gt; X = Matrix([rho*cos(phi), rho*sin(phi)])</span>
<span class="sd">        &gt;&gt;&gt; X.jacobian(Y)</span>
<span class="sd">        Matrix([</span>
<span class="sd">        [cos(phi), -rho*sin(phi)],</span>
<span class="sd">        [sin(phi),  rho*cos(phi)]])</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        hessian</span>
<span class="sd">        wronskian</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">MatrixBase</span><span class="p">):</span>
            <span class="n">X</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_new</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        <span class="c1"># Both X and self can be a row or a column matrix, so we need to make</span>
        <span class="c1"># sure all valid combinations work, but everything else fails:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">m</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">m</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;self must be a row or a column matrix&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;X must be a row or a column matrix&quot;</span><span class="p">)</span>

        <span class="c1"># m is the number of functions and n is the number of variables</span>
        <span class="c1"># computing the Jacobian is now easy:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_new</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">:</span> <span class="bp">self</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span></div>

<div class="viewcode-block" id="MatrixBase.QRdecomposition"><a class="viewcode-back" href="../../../modules/matrices/matrices.html#sympy.matrices.immutable.MatrixBase.QRdecomposition">[docs]</a>    <span class="k">def</span> <span class="nf">QRdecomposition</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return Q, R where A = Q*R, Q is orthogonal and R is upper triangular.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        This is the example from wikipedia:</span>

<span class="sd">        &gt;&gt;&gt; from sympy import Matrix</span>
<span class="sd">        &gt;&gt;&gt; A = Matrix([[12, -51, 4], [6, 167, -68], [-4, 24, -41]])</span>
<span class="sd">        &gt;&gt;&gt; Q, R = A.QRdecomposition()</span>
<span class="sd">        &gt;&gt;&gt; Q</span>
<span class="sd">        Matrix([</span>
<span class="sd">        [ 6/7, -69/175, -58/175],</span>
<span class="sd">        [ 3/7, 158/175,   6/175],</span>
<span class="sd">        [-2/7,    6/35,  -33/35]])</span>
<span class="sd">        &gt;&gt;&gt; R</span>
<span class="sd">        Matrix([</span>
<span class="sd">        [14,  21, -14],</span>
<span class="sd">        [ 0, 175, -70],</span>
<span class="sd">        [ 0,   0,  35]])</span>
<span class="sd">        &gt;&gt;&gt; A == Q*R</span>
<span class="sd">        True</span>

<span class="sd">        QR factorization of an identity matrix:</span>

<span class="sd">        &gt;&gt;&gt; A = Matrix([[1, 0, 0], [0, 1, 0], [0, 0, 1]])</span>
<span class="sd">        &gt;&gt;&gt; Q, R = A.QRdecomposition()</span>
<span class="sd">        &gt;&gt;&gt; Q</span>
<span class="sd">        Matrix([</span>
<span class="sd">        [1, 0, 0],</span>
<span class="sd">        [0, 1, 0],</span>
<span class="sd">        [0, 0, 1]])</span>
<span class="sd">        &gt;&gt;&gt; R</span>
<span class="sd">        Matrix([</span>
<span class="sd">        [1, 0, 0],</span>
<span class="sd">        [0, 1, 0],</span>
<span class="sd">        [0, 0, 1]])</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        cholesky</span>
<span class="sd">        LDLdecomposition</span>
<span class="sd">        LUdecomposition</span>
<span class="sd">        QRsolve</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">cls</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span>
        <span class="n">mat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_mutable</span><span class="p">()</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">mat</span><span class="o">.</span><span class="n">rows</span> <span class="o">&gt;=</span> <span class="n">mat</span><span class="o">.</span><span class="n">cols</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">MatrixError</span><span class="p">(</span>
                <span class="s2">&quot;The number of rows must be greater than columns&quot;</span><span class="p">)</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">mat</span><span class="o">.</span><span class="n">rows</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">mat</span><span class="o">.</span><span class="n">cols</span>
        <span class="n">rank</span> <span class="o">=</span> <span class="n">n</span>
        <span class="n">row_reduced</span> <span class="o">=</span> <span class="n">mat</span><span class="o">.</span><span class="n">rref</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">row_reduced</span><span class="o">.</span><span class="n">rows</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">row_reduced</span><span class="o">.</span><span class="n">row</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">.</span><span class="n">norm</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">rank</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">rank</span> <span class="o">==</span> <span class="n">mat</span><span class="o">.</span><span class="n">cols</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">MatrixError</span><span class="p">(</span><span class="s2">&quot;The rank of the matrix must match the columns&quot;</span><span class="p">)</span>
        <span class="n">Q</span><span class="p">,</span> <span class="n">R</span> <span class="o">=</span> <span class="n">mat</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">),</span> <span class="n">mat</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>      <span class="c1"># for each column vector</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="n">mat</span><span class="p">[:,</span> <span class="n">j</span><span class="p">]</span>     <span class="c1"># take original v</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">j</span><span class="p">):</span>
                <span class="c1"># subtract the project of mat on new vector</span>
                <span class="n">tmp</span> <span class="o">-=</span> <span class="n">Q</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">mat</span><span class="p">[:,</span> <span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Q</span><span class="p">[:,</span> <span class="n">i</span><span class="p">])</span>
                <span class="n">tmp</span><span class="o">.</span><span class="n">expand</span><span class="p">()</span>
            <span class="c1"># normalize it</span>
            <span class="n">R</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">.</span><span class="n">norm</span><span class="p">()</span>
            <span class="n">Q</span><span class="p">[:,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span> <span class="o">/</span> <span class="n">R</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">Q</span><span class="p">[:,</span> <span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">norm</span><span class="p">()</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                    <span class="s2">&quot;Could not normalize the vector </span><span class="si">%d</span><span class="s2">.&quot;</span> <span class="o">%</span> <span class="n">j</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">j</span><span class="p">):</span>
                <span class="n">R</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">Q</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">mat</span><span class="p">[:,</span> <span class="n">j</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">cls</span><span class="p">(</span><span class="n">Q</span><span class="p">),</span> <span class="n">cls</span><span class="p">(</span><span class="n">R</span><span class="p">)</span></div>

<div class="viewcode-block" id="MatrixBase.QRsolve"><a class="viewcode-back" href="../../../modules/matrices/matrices.html#sympy.matrices.immutable.MatrixBase.QRsolve">[docs]</a>    <span class="k">def</span> <span class="nf">QRsolve</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Solve the linear system &#39;Ax = b&#39;.</span>

<span class="sd">        &#39;self&#39; is the matrix &#39;A&#39;, the method argument is the vector</span>
<span class="sd">        &#39;b&#39;.  The method returns the solution vector &#39;x&#39;.  If &#39;b&#39; is a</span>
<span class="sd">        matrix, the system is solved for each column of &#39;b&#39; and the</span>
<span class="sd">        return value is a matrix of the same shape as &#39;b&#39;.</span>

<span class="sd">        This method is slower (approximately by a factor of 2) but</span>
<span class="sd">        more stable for floating-point arithmetic than the LUsolve method.</span>
<span class="sd">        However, LUsolve usually uses an exact arithmetic, so you don&#39;t need</span>
<span class="sd">        to use QRsolve.</span>

<span class="sd">        This is mainly for educational purposes and symbolic matrices, for real</span>
<span class="sd">        (or complex) matrices use mpmath.qr_solve.</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        lower_triangular_solve</span>
<span class="sd">        upper_triangular_solve</span>
<span class="sd">        gauss_jordan_solve</span>
<span class="sd">        cholesky_solve</span>
<span class="sd">        diagonal_solve</span>
<span class="sd">        LDLsolve</span>
<span class="sd">        LUsolve</span>
<span class="sd">        pinv_solve</span>
<span class="sd">        QRdecomposition</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">Q</span><span class="p">,</span> <span class="n">R</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_mutable</span><span class="p">()</span><span class="o">.</span><span class="n">QRdecomposition</span><span class="p">()</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">Q</span><span class="o">.</span><span class="n">T</span><span class="o">*</span><span class="n">b</span>

        <span class="c1"># back substitution to solve R*x = y:</span>
        <span class="c1"># We build up the result &quot;backwards&quot; in the vector &#39;x&#39; and reverse it</span>
        <span class="c1"># only in the end.</span>
        <span class="n">x</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">rows</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="p">:]</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
                <span class="n">tmp</span> <span class="o">-=</span> <span class="n">R</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">k</span><span class="p">]</span>
            <span class="n">x</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tmp</span> <span class="o">/</span> <span class="n">R</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">j</span><span class="p">])</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_new</span><span class="p">([</span><span class="n">row</span><span class="o">.</span><span class="n">_mat</span> <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="n">x</span><span class="p">)])</span></div>

<div class="viewcode-block" id="MatrixBase.cross"><a class="viewcode-back" href="../../../modules/matrices/matrices.html#sympy.matrices.immutable.MatrixBase.cross">[docs]</a>    <span class="k">def</span> <span class="nf">cross</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the cross product of `self` and `b` relaxing the condition</span>
<span class="sd">        of compatible dimensions: if each has 3 elements, a matrix of the</span>
<span class="sd">        same type and shape as `self` will be returned. If `b` has the same</span>
<span class="sd">        shape as `self` then common identities for the cross product (like</span>
<span class="sd">        `a x b = - b x a`) will hold.</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        dot</span>
<span class="sd">        multiply</span>
<span class="sd">        multiply_elementwise</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_sequence</span><span class="p">(</span><span class="n">b</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;`b` must be an ordered iterable or Matrix, not </span><span class="si">%s</span><span class="s2">.&quot;</span> <span class="o">%</span>
                <span class="nb">type</span><span class="p">(</span><span class="n">b</span><span class="p">))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rows</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span> <span class="o">==</span> <span class="n">b</span><span class="o">.</span><span class="n">rows</span> <span class="o">*</span> <span class="n">b</span><span class="o">.</span><span class="n">cols</span> <span class="o">==</span> <span class="mi">3</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">ShapeError</span><span class="p">(</span><span class="s2">&quot;Dimensions incorrect for cross product.&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_new</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">,</span> <span class="p">(</span>
                <span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">b</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span>
                <span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">b</span><span class="p">[</span><span class="mi">2</span><span class="p">]),</span>
                <span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">])))</span></div>

<div class="viewcode-block" id="MatrixBase.dot"><a class="viewcode-back" href="../../../modules/matrices/matrices.html#sympy.matrices.immutable.MatrixBase.dot">[docs]</a>    <span class="k">def</span> <span class="nf">dot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the dot product of Matrix self and b relaxing the condition</span>
<span class="sd">        of compatible dimensions: if either the number of rows or columns are</span>
<span class="sd">        the same as the length of b then the dot product is returned. If self</span>
<span class="sd">        is a row or column vector, a scalar is returned. Otherwise, a list</span>
<span class="sd">        of results is returned (and in that case the number of columns in self</span>
<span class="sd">        must match the length of b).</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy import Matrix</span>
<span class="sd">        &gt;&gt;&gt; M = Matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]])</span>
<span class="sd">        &gt;&gt;&gt; v = [1, 1, 1]</span>
<span class="sd">        &gt;&gt;&gt; M.row(0).dot(v)</span>
<span class="sd">        6</span>
<span class="sd">        &gt;&gt;&gt; M.col(0).dot(v)</span>
<span class="sd">        12</span>
<span class="sd">        &gt;&gt;&gt; M.dot(v)</span>
<span class="sd">        [6, 15, 24]</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        cross</span>
<span class="sd">        multiply</span>
<span class="sd">        multiply_elementwise</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">.dense</span> <span class="kn">import</span> <span class="n">Matrix</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">MatrixBase</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">is_sequence</span><span class="p">(</span><span class="n">b</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">ShapeError</span><span class="p">(</span><span class="s2">&quot;Dimensions incorrect for dot product.&quot;</span><span class="p">)</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Matrix</span><span class="p">(</span><span class="n">b</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;`b` must be an ordered iterable or Matrix, not </span><span class="si">%s</span><span class="s2">.&quot;</span> <span class="o">%</span>
                <span class="nb">type</span><span class="p">(</span><span class="n">b</span><span class="p">))</span>

        <span class="n">mat</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">if</span> <span class="n">mat</span><span class="o">.</span><span class="n">cols</span> <span class="o">==</span> <span class="n">b</span><span class="o">.</span><span class="n">rows</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">b</span><span class="o">.</span><span class="n">cols</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">mat</span> <span class="o">=</span> <span class="n">mat</span><span class="o">.</span><span class="n">T</span>
                <span class="n">b</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">T</span>
            <span class="n">prod</span> <span class="o">=</span> <span class="n">flatten</span><span class="p">((</span><span class="n">mat</span><span class="o">*</span><span class="n">b</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">prod</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">prod</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">prod</span>
        <span class="k">if</span> <span class="n">mat</span><span class="o">.</span><span class="n">cols</span> <span class="o">==</span> <span class="n">b</span><span class="o">.</span><span class="n">cols</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">mat</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">mat</span><span class="o">.</span><span class="n">rows</span> <span class="o">==</span> <span class="n">b</span><span class="o">.</span><span class="n">rows</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">mat</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ShapeError</span><span class="p">(</span><span class="s2">&quot;Dimensions incorrect for dot product.&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="MatrixBase.multiply_elementwise"><a class="viewcode-back" href="../../../modules/matrices/matrices.html#sympy.matrices.immutable.MatrixBase.multiply_elementwise">[docs]</a>    <span class="k">def</span> <span class="nf">multiply_elementwise</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the Hadamard product (elementwise product) of A and B</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.matrices import Matrix</span>
<span class="sd">        &gt;&gt;&gt; A = Matrix([[0, 1, 2], [3, 4, 5]])</span>
<span class="sd">        &gt;&gt;&gt; B = Matrix([[1, 10, 100], [100, 10, 1]])</span>
<span class="sd">        &gt;&gt;&gt; A.multiply_elementwise(B)</span>
<span class="sd">        Matrix([</span>
<span class="sd">        [  0, 10, 200],</span>
<span class="sd">        [300, 40,   5]])</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        cross</span>
<span class="sd">        dot</span>
<span class="sd">        multiply</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">sympy.matrices</span> <span class="kn">import</span> <span class="n">matrix_multiply_elementwise</span>

        <span class="k">return</span> <span class="n">matrix_multiply_elementwise</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span></div>

<div class="viewcode-block" id="MatrixBase.values"><a class="viewcode-back" href="../../../modules/matrices/matrices.html#sympy.matrices.immutable.MatrixBase.values">[docs]</a>    <span class="k">def</span> <span class="nf">values</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return non-zero values of self.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">flatten</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">i</span><span class="o">.</span><span class="n">is_zero</span><span class="p">]</span></div>

<div class="viewcode-block" id="MatrixBase.norm"><a class="viewcode-back" href="../../../modules/matrices/matrices.html#sympy.matrices.immutable.MatrixBase.norm">[docs]</a>    <span class="k">def</span> <span class="nf">norm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">ord</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the Norm of a Matrix or Vector.</span>
<span class="sd">        In the simplest case this is the geometric size of the vector</span>
<span class="sd">        Other norms can be specified by the ord parameter</span>


<span class="sd">        =====  ============================  ==========================</span>
<span class="sd">        ord    norm for matrices             norm for vectors</span>
<span class="sd">        =====  ============================  ==========================</span>
<span class="sd">        None   Frobenius norm                2-norm</span>
<span class="sd">        &#39;fro&#39;  Frobenius norm                - does not exist</span>
<span class="sd">        inf    --                            max(abs(x))</span>
<span class="sd">        -inf   --                            min(abs(x))</span>
<span class="sd">        1      --                            as below</span>
<span class="sd">        -1     --                            as below</span>
<span class="sd">        2      2-norm (largest sing. value)  as below</span>
<span class="sd">        -2     smallest singular value       as below</span>
<span class="sd">        other  - does not exist              sum(abs(x)**ord)**(1./ord)</span>
<span class="sd">        =====  ============================  ==========================</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy import Matrix, Symbol, trigsimp, cos, sin, oo</span>
<span class="sd">        &gt;&gt;&gt; x = Symbol(&#39;x&#39;, real=True)</span>
<span class="sd">        &gt;&gt;&gt; v = Matrix([cos(x), sin(x)])</span>
<span class="sd">        &gt;&gt;&gt; trigsimp( v.norm() )</span>
<span class="sd">        1</span>
<span class="sd">        &gt;&gt;&gt; v.norm(10)</span>
<span class="sd">        (sin(x)**10 + cos(x)**10)**(1/10)</span>
<span class="sd">        &gt;&gt;&gt; A = Matrix([[1, 1], [1, 1]])</span>
<span class="sd">        &gt;&gt;&gt; A.norm(2)# Spectral norm (max of |Ax|/|x| under 2-vector-norm)</span>
<span class="sd">        2</span>
<span class="sd">        &gt;&gt;&gt; A.norm(-2) # Inverse spectral norm (smallest singular value)</span>
<span class="sd">        0</span>
<span class="sd">        &gt;&gt;&gt; A.norm() # Frobenius Norm</span>
<span class="sd">        2</span>
<span class="sd">        &gt;&gt;&gt; Matrix([1, -2]).norm(oo)</span>
<span class="sd">        2</span>
<span class="sd">        &gt;&gt;&gt; Matrix([-1, 2]).norm(-oo)</span>
<span class="sd">        1</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        normalized</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Row or Column Vector Norms</span>
        <span class="n">vals</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">())</span> <span class="ow">or</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">rows</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">ord</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">or</span> <span class="nb">ord</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>  <span class="c1"># Common case sqrt(&lt;x, x&gt;)</span>
                <span class="k">return</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">Add</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">vals</span><span class="p">)))</span>

            <span class="k">elif</span> <span class="nb">ord</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># sum(abs(x))</span>
                <span class="k">return</span> <span class="n">Add</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">vals</span><span class="p">))</span>

            <span class="k">elif</span> <span class="nb">ord</span> <span class="o">==</span> <span class="n">S</span><span class="o">.</span><span class="n">Infinity</span><span class="p">:</span>  <span class="c1"># max(abs(x))</span>
                <span class="k">return</span> <span class="n">Max</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="nb">abs</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">vals</span><span class="p">])</span>

            <span class="k">elif</span> <span class="nb">ord</span> <span class="o">==</span> <span class="n">S</span><span class="o">.</span><span class="n">NegativeInfinity</span><span class="p">:</span>  <span class="c1"># min(abs(x))</span>
                <span class="k">return</span> <span class="n">Min</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="nb">abs</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">vals</span><span class="p">])</span>

            <span class="c1"># Otherwise generalize the 2-norm, Sum(x_i**ord)**(1/ord)</span>
            <span class="c1"># Note that while useful this is not mathematically a norm</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">Pow</span><span class="p">(</span><span class="n">Add</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">**</span><span class="nb">ord</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">vals</span><span class="p">)),</span> <span class="n">S</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="nb">ord</span><span class="p">)</span>
            <span class="k">except</span> <span class="p">(</span><span class="ne">NotImplementedError</span><span class="p">,</span> <span class="ne">TypeError</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Expected order to be Number, Symbol, oo&quot;</span><span class="p">)</span>

        <span class="c1"># Matrix Norms</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">ord</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>  <span class="c1"># Spectral Norm</span>
                <span class="c1"># Maximum singular value</span>
                <span class="k">return</span> <span class="n">Max</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">singular_values</span><span class="p">())</span>

            <span class="k">elif</span> <span class="nb">ord</span> <span class="o">==</span> <span class="o">-</span><span class="mi">2</span><span class="p">:</span>
                <span class="c1"># Minimum singular value</span>
                <span class="k">return</span> <span class="n">Min</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">singular_values</span><span class="p">())</span>

            <span class="k">elif</span> <span class="p">(</span><span class="nb">ord</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">ord</span><span class="p">,</span> <span class="n">string_types</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">ord</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span>
                    <span class="p">[</span><span class="s1">&#39;f&#39;</span><span class="p">,</span> <span class="s1">&#39;fro&#39;</span><span class="p">,</span> <span class="s1">&#39;frobenius&#39;</span><span class="p">,</span> <span class="s1">&#39;vector&#39;</span><span class="p">]):</span>
                <span class="c1"># Reshape as vector and send back to norm function</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">vec</span><span class="p">()</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="nb">ord</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Matrix Norms under development&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="MatrixBase.normalized"><a class="viewcode-back" href="../../../modules/matrices/matrices.html#sympy.matrices.immutable.MatrixBase.normalized">[docs]</a>    <span class="k">def</span> <span class="nf">normalized</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the normalized version of ``self``.</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        norm</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">rows</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ShapeError</span><span class="p">(</span><span class="s2">&quot;A Matrix must be a vector to normalize.&quot;</span><span class="p">)</span>
        <span class="n">norm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">norm</span><span class="p">()</span>
        <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">applyfunc</span><span class="p">(</span><span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="n">i</span> <span class="o">/</span> <span class="n">norm</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">out</span></div>

<div class="viewcode-block" id="MatrixBase.project"><a class="viewcode-back" href="../../../modules/matrices/matrices.html#sympy.matrices.immutable.MatrixBase.project">[docs]</a>    <span class="k">def</span> <span class="nf">project</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the projection of ``self`` onto the line containing ``v``.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy import Matrix, S, sqrt</span>
<span class="sd">        &gt;&gt;&gt; V = Matrix([sqrt(3)/2, S.Half])</span>
<span class="sd">        &gt;&gt;&gt; x = Matrix([[1, 0]])</span>
<span class="sd">        &gt;&gt;&gt; V.project(x)</span>
<span class="sd">        Matrix([[sqrt(3)/2, 0]])</span>
<span class="sd">        &gt;&gt;&gt; V.project(-x)</span>
<span class="sd">        Matrix([[sqrt(3)/2, 0]])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">v</span><span class="o">*</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">/</span> <span class="n">v</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">v</span><span class="p">))</span></div>

<div class="viewcode-block" id="MatrixBase.permuteBkwd"><a class="viewcode-back" href="../../../modules/matrices/matrices.html#sympy.matrices.immutable.MatrixBase.permuteBkwd">[docs]</a>    <span class="k">def</span> <span class="nf">permuteBkwd</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">perm</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Permute the rows of the matrix with the given permutation in reverse.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.matrices import eye</span>
<span class="sd">        &gt;&gt;&gt; M = eye(3)</span>
<span class="sd">        &gt;&gt;&gt; M.permuteBkwd([[0, 1], [0, 2]])</span>
<span class="sd">        Matrix([</span>
<span class="sd">        [0, 1, 0],</span>
<span class="sd">        [0, 0, 1],</span>
<span class="sd">        [1, 0, 0]])</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        permuteFwd</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">copy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">perm</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">copy</span><span class="o">.</span><span class="n">row_swap</span><span class="p">(</span><span class="n">perm</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">perm</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">copy</span></div>

<div class="viewcode-block" id="MatrixBase.permuteFwd"><a class="viewcode-back" href="../../../modules/matrices/matrices.html#sympy.matrices.immutable.MatrixBase.permuteFwd">[docs]</a>    <span class="k">def</span> <span class="nf">permuteFwd</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">perm</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Permute the rows of the matrix with the given permutation.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.matrices import eye</span>
<span class="sd">        &gt;&gt;&gt; M = eye(3)</span>
<span class="sd">        &gt;&gt;&gt; M.permuteFwd([[0, 1], [0, 2]])</span>
<span class="sd">        Matrix([</span>
<span class="sd">        [0, 0, 1],</span>
<span class="sd">        [1, 0, 0],</span>
<span class="sd">        [0, 1, 0]])</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        permuteBkwd</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">copy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">perm</span><span class="p">)):</span>
            <span class="n">copy</span><span class="o">.</span><span class="n">row_swap</span><span class="p">(</span><span class="n">perm</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">perm</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">copy</span></div>

<div class="viewcode-block" id="MatrixBase.exp"><a class="viewcode-back" href="../../../modules/matrices/matrices.html#sympy.matrices.immutable.MatrixBase.exp">[docs]</a>    <span class="k">def</span> <span class="nf">exp</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the exponentiation of a square matrix.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_square</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">NonSquareMatrixError</span><span class="p">(</span>
                <span class="s2">&quot;Exponentiation is valid only for square matrices&quot;</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">P</span><span class="p">,</span> <span class="n">cells</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">jordan_cells</span><span class="p">()</span>
        <span class="k">except</span> <span class="n">MatrixError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Exponentiation is implemented only for matrices for which the Jordan normal form can be computed&quot;</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">_jblock_exponential</span><span class="p">(</span><span class="n">b</span><span class="p">):</span>
            <span class="c1"># This function computes the matrix exponential for one single Jordan block</span>
            <span class="n">nr</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">rows</span>
            <span class="n">l</span> <span class="o">=</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">nr</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">res</span> <span class="o">=</span> <span class="n">exp</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">eye</span>
                <span class="c1"># extract the diagonal part</span>
                <span class="n">d</span> <span class="o">=</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">eye</span><span class="p">(</span><span class="n">nr</span><span class="p">)</span>
                <span class="c1">#and the nilpotent part</span>
                <span class="n">n</span> <span class="o">=</span> <span class="n">b</span><span class="o">-</span><span class="n">d</span>
                <span class="c1"># compute its exponential</span>
                <span class="n">nex</span> <span class="o">=</span> <span class="n">eye</span><span class="p">(</span><span class="n">nr</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nr</span><span class="p">):</span>
                    <span class="n">nex</span> <span class="o">=</span> <span class="n">nex</span><span class="o">+</span><span class="n">n</span><span class="o">**</span><span class="n">i</span><span class="o">/</span><span class="n">factorial</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                <span class="c1"># combine the two parts</span>
                <span class="n">res</span> <span class="o">=</span> <span class="n">exp</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span><span class="o">*</span><span class="n">nex</span>
            <span class="k">return</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>

        <span class="n">blocks</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">_jblock_exponential</span><span class="p">,</span> <span class="n">cells</span><span class="p">))</span>
        <span class="kn">from</span> <span class="nn">sympy.matrices</span> <span class="kn">import</span> <span class="n">diag</span>
        <span class="n">eJ</span> <span class="o">=</span> <span class="n">diag</span><span class="p">(</span><span class="o">*</span> <span class="n">blocks</span><span class="p">)</span>
        <span class="c1"># n = self.rows</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">P</span><span class="o">*</span><span class="n">eJ</span><span class="o">*</span><span class="n">P</span><span class="o">.</span><span class="n">inv</span><span class="p">()</span>
        <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)(</span><span class="n">ret</span><span class="p">)</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_square</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Checks if a matrix is square.</span>

<span class="sd">        A matrix is square if the number of rows equals the number of columns.</span>
<span class="sd">        The empty matrix is square by definition, since the number of rows and</span>
<span class="sd">        the number of columns are both zero.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy import Matrix</span>
<span class="sd">        &gt;&gt;&gt; a = Matrix([[1, 2, 3], [4, 5, 6]])</span>
<span class="sd">        &gt;&gt;&gt; b = Matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]])</span>
<span class="sd">        &gt;&gt;&gt; c = Matrix([])</span>
<span class="sd">        &gt;&gt;&gt; a.is_square</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; b.is_square</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; c.is_square</span>
<span class="sd">        True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">rows</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_zero</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Checks if a matrix is a zero matrix.</span>

<span class="sd">        A matrix is zero if every element is zero.  A matrix need not be square</span>
<span class="sd">        to be considered zero.  The empty matrix is zero by the principle of</span>
<span class="sd">        vacuous truth.  For a matrix that may or may not be zero (e.g.</span>
<span class="sd">        contains a symbol), this will be None</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy import Matrix, zeros</span>
<span class="sd">        &gt;&gt;&gt; from sympy.abc import x</span>
<span class="sd">        &gt;&gt;&gt; a = Matrix([[0, 0], [0, 0]])</span>
<span class="sd">        &gt;&gt;&gt; b = zeros(3, 4)</span>
<span class="sd">        &gt;&gt;&gt; c = Matrix([[0, 1], [0, 0]])</span>
<span class="sd">        &gt;&gt;&gt; d = Matrix([])</span>
<span class="sd">        &gt;&gt;&gt; e = Matrix([[x, 0], [0, 0]])</span>
<span class="sd">        &gt;&gt;&gt; a.is_zero</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; b.is_zero</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; c.is_zero</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; d.is_zero</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; e.is_zero</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">is_zero</span> <span class="o">==</span> <span class="bp">False</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">False</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">is_zero</span> <span class="o">==</span> <span class="bp">None</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">None</span>
        <span class="k">return</span> <span class="bp">True</span>

<div class="viewcode-block" id="MatrixBase.is_nilpotent"><a class="viewcode-back" href="../../../modules/matrices/matrices.html#sympy.matrices.immutable.MatrixBase.is_nilpotent">[docs]</a>    <span class="k">def</span> <span class="nf">is_nilpotent</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Checks if a matrix is nilpotent.</span>

<span class="sd">        A matrix B is nilpotent if for some integer k, B**k is</span>
<span class="sd">        a zero matrix.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy import Matrix</span>
<span class="sd">        &gt;&gt;&gt; a = Matrix([[0, 0, 0], [1, 0, 0], [1, 1, 0]])</span>
<span class="sd">        &gt;&gt;&gt; a.is_nilpotent()</span>
<span class="sd">        True</span>

<span class="sd">        &gt;&gt;&gt; a = Matrix([[1, 0, 1], [1, 0, 0], [1, 1, 0]])</span>
<span class="sd">        &gt;&gt;&gt; a.is_nilpotent()</span>
<span class="sd">        False</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">True</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_square</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">NonSquareMatrixError</span><span class="p">(</span>
                <span class="s2">&quot;Nilpotency is valid only for square matrices&quot;</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">Dummy</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">charpoly</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">x</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">True</span>
        <span class="k">return</span> <span class="bp">False</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_upper</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Check if matrix is an upper triangular matrix. True can be returned</span>
<span class="sd">        even if the matrix is not square.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy import Matrix</span>
<span class="sd">        &gt;&gt;&gt; m = Matrix(2, 2, [1, 0, 0, 1])</span>
<span class="sd">        &gt;&gt;&gt; m</span>
<span class="sd">        Matrix([</span>
<span class="sd">        [1, 0],</span>
<span class="sd">        [0, 1]])</span>
<span class="sd">        &gt;&gt;&gt; m.is_upper</span>
<span class="sd">        True</span>

<span class="sd">        &gt;&gt;&gt; m = Matrix(4, 3, [5, 1, 9, 0, 4 , 6, 0, 0, 5, 0, 0, 0])</span>
<span class="sd">        &gt;&gt;&gt; m</span>
<span class="sd">        Matrix([</span>
<span class="sd">        [5, 1, 9],</span>
<span class="sd">        [0, 4, 6],</span>
<span class="sd">        [0, 0, 5],</span>
<span class="sd">        [0, 0, 0]])</span>
<span class="sd">        &gt;&gt;&gt; m.is_upper</span>
<span class="sd">        True</span>

<span class="sd">        &gt;&gt;&gt; m = Matrix(2, 3, [4, 2, 5, 6, 1, 1])</span>
<span class="sd">        &gt;&gt;&gt; m</span>
<span class="sd">        Matrix([</span>
<span class="sd">        [4, 2, 5],</span>
<span class="sd">        [6, 1, 1]])</span>
<span class="sd">        &gt;&gt;&gt; m.is_upper</span>
<span class="sd">        False</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        is_lower</span>
<span class="sd">        is_diagonal</span>
<span class="sd">        is_upper_hessenberg</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">all</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">is_zero</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_lower</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Check if matrix is a lower triangular matrix. True can be returned</span>
<span class="sd">        even if the matrix is not square.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy import Matrix</span>
<span class="sd">        &gt;&gt;&gt; m = Matrix(2, 2, [1, 0, 0, 1])</span>
<span class="sd">        &gt;&gt;&gt; m</span>
<span class="sd">        Matrix([</span>
<span class="sd">        [1, 0],</span>
<span class="sd">        [0, 1]])</span>
<span class="sd">        &gt;&gt;&gt; m.is_lower</span>
<span class="sd">        True</span>

<span class="sd">        &gt;&gt;&gt; m = Matrix(4, 3, [0, 0, 0, 2, 0, 0, 1, 4 , 0, 6, 6, 5])</span>
<span class="sd">        &gt;&gt;&gt; m</span>
<span class="sd">        Matrix([</span>
<span class="sd">        [0, 0, 0],</span>
<span class="sd">        [2, 0, 0],</span>
<span class="sd">        [1, 4, 0],</span>
<span class="sd">        [6, 6, 5]])</span>
<span class="sd">        &gt;&gt;&gt; m.is_lower</span>
<span class="sd">        True</span>

<span class="sd">        &gt;&gt;&gt; from sympy.abc import x, y</span>
<span class="sd">        &gt;&gt;&gt; m = Matrix(2, 2, [x**2 + y, y**2 + x, 0, x + y])</span>
<span class="sd">        &gt;&gt;&gt; m</span>
<span class="sd">        Matrix([</span>
<span class="sd">        [x**2 + y, x + y**2],</span>
<span class="sd">        [       0,    x + y]])</span>
<span class="sd">        &gt;&gt;&gt; m.is_lower</span>
<span class="sd">        False</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        is_upper</span>
<span class="sd">        is_diagonal</span>
<span class="sd">        is_lower_hessenberg</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">all</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">is_zero</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_hermitian</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Checks if the matrix is Hermitian.</span>

<span class="sd">        In a Hermitian matrix element i,j is the complex conjugate of</span>
<span class="sd">        element j,i.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.matrices import Matrix</span>
<span class="sd">        &gt;&gt;&gt; from sympy import I</span>
<span class="sd">        &gt;&gt;&gt; from sympy.abc import x</span>
<span class="sd">        &gt;&gt;&gt; a = Matrix([[1, I], [-I, 1]])</span>
<span class="sd">        &gt;&gt;&gt; a</span>
<span class="sd">        Matrix([</span>
<span class="sd">        [ 1, I],</span>
<span class="sd">        [-I, 1]])</span>
<span class="sd">        &gt;&gt;&gt; a.is_hermitian</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; a[0, 0] = 2*I</span>
<span class="sd">        &gt;&gt;&gt; a.is_hermitian</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; a[0, 0] = x</span>
<span class="sd">        &gt;&gt;&gt; a.is_hermitian</span>
<span class="sd">        &gt;&gt;&gt; a[0, 1] = a[1, 0]*I</span>
<span class="sd">        &gt;&gt;&gt; a.is_hermitian</span>
<span class="sd">        False</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span> <span class="nf">cond</span><span class="p">():</span>
            <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_square</span>
            <span class="k">yield</span> <span class="n">fuzzy_and</span><span class="p">(</span>
                    <span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">is_real</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="p">))</span>
            <span class="k">yield</span> <span class="n">fuzzy_and</span><span class="p">(</span>
                    <span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">conjugate</span><span class="p">())</span><span class="o">.</span><span class="n">is_zero</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">fuzzy_and</span><span class="p">(</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">cond</span><span class="p">())</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_upper_hessenberg</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Checks if the matrix is the upper-Hessenberg form.</span>

<span class="sd">        The upper hessenberg matrix has zero entries</span>
<span class="sd">        below the first subdiagonal.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.matrices import Matrix</span>
<span class="sd">        &gt;&gt;&gt; a = Matrix([[1, 4, 2, 3], [3, 4, 1, 7], [0, 2, 3, 4], [0, 0, 1, 3]])</span>
<span class="sd">        &gt;&gt;&gt; a</span>
<span class="sd">        Matrix([</span>
<span class="sd">        [1, 4, 2, 3],</span>
<span class="sd">        [3, 4, 1, 7],</span>
<span class="sd">        [0, 2, 3, 4],</span>
<span class="sd">        [0, 0, 1, 3]])</span>
<span class="sd">        &gt;&gt;&gt; a.is_upper_hessenberg</span>
<span class="sd">        True</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        is_lower_hessenberg</span>
<span class="sd">        is_upper</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">all</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">is_zero</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_lower_hessenberg</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">r&quot;&quot;&quot;Checks if the matrix is in the lower-Hessenberg form.</span>

<span class="sd">        The lower hessenberg matrix has zero entries</span>
<span class="sd">        above the first superdiagonal.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.matrices import Matrix</span>
<span class="sd">        &gt;&gt;&gt; a = Matrix([[1, 2, 0, 0], [5, 2, 3, 0], [3, 4, 3, 7], [5, 6, 1, 1]])</span>
<span class="sd">        &gt;&gt;&gt; a</span>
<span class="sd">        Matrix([</span>
<span class="sd">        [1, 2, 0, 0],</span>
<span class="sd">        [5, 2, 3, 0],</span>
<span class="sd">        [3, 4, 3, 7],</span>
<span class="sd">        [5, 6, 1, 1]])</span>
<span class="sd">        &gt;&gt;&gt; a.is_lower_hessenberg</span>
<span class="sd">        True</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        is_upper_hessenberg</span>
<span class="sd">        is_lower</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">all</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">is_zero</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">))</span>

<div class="viewcode-block" id="MatrixBase.is_symbolic"><a class="viewcode-back" href="../../../modules/matrices/matrices.html#sympy.matrices.immutable.MatrixBase.is_symbolic">[docs]</a>    <span class="k">def</span> <span class="nf">is_symbolic</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Checks if any elements contain Symbols.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.matrices import Matrix</span>
<span class="sd">        &gt;&gt;&gt; from sympy.abc import x, y</span>
<span class="sd">        &gt;&gt;&gt; M = Matrix([[x, y], [1, 0]])</span>
<span class="sd">        &gt;&gt;&gt; M.is_symbolic()</span>
<span class="sd">        True</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">any</span><span class="p">(</span><span class="n">element</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">Symbol</span><span class="p">)</span> <span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">())</span></div>

<div class="viewcode-block" id="MatrixBase.is_symmetric"><a class="viewcode-back" href="../../../modules/matrices/matrices.html#sympy.matrices.immutable.MatrixBase.is_symmetric">[docs]</a>    <span class="k">def</span> <span class="nf">is_symmetric</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">simplify</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Check if matrix is symmetric matrix,</span>
<span class="sd">        that is square matrix and is equal to its transpose.</span>

<span class="sd">        By default, simplifications occur before testing symmetry.</span>
<span class="sd">        They can be skipped using &#39;simplify=False&#39;; while speeding things a bit,</span>
<span class="sd">        this may however induce false negatives.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy import Matrix</span>
<span class="sd">        &gt;&gt;&gt; m = Matrix(2, 2, [0, 1, 1, 2])</span>
<span class="sd">        &gt;&gt;&gt; m</span>
<span class="sd">        Matrix([</span>
<span class="sd">        [0, 1],</span>
<span class="sd">        [1, 2]])</span>
<span class="sd">        &gt;&gt;&gt; m.is_symmetric()</span>
<span class="sd">        True</span>

<span class="sd">        &gt;&gt;&gt; m = Matrix(2, 2, [0, 1, 2, 0])</span>
<span class="sd">        &gt;&gt;&gt; m</span>
<span class="sd">        Matrix([</span>
<span class="sd">        [0, 1],</span>
<span class="sd">        [2, 0]])</span>
<span class="sd">        &gt;&gt;&gt; m.is_symmetric()</span>
<span class="sd">        False</span>

<span class="sd">        &gt;&gt;&gt; m = Matrix(2, 3, [0, 0, 0, 0, 0, 0])</span>
<span class="sd">        &gt;&gt;&gt; m</span>
<span class="sd">        Matrix([</span>
<span class="sd">        [0, 0, 0],</span>
<span class="sd">        [0, 0, 0]])</span>
<span class="sd">        &gt;&gt;&gt; m.is_symmetric()</span>
<span class="sd">        False</span>

<span class="sd">        &gt;&gt;&gt; from sympy.abc import x, y</span>
<span class="sd">        &gt;&gt;&gt; m = Matrix(3, 3, [1, x**2 + 2*x + 1, y, (x + 1)**2 , 2, 0, y, 0, 3])</span>
<span class="sd">        &gt;&gt;&gt; m</span>
<span class="sd">        Matrix([</span>
<span class="sd">        [         1, x**2 + 2*x + 1, y],</span>
<span class="sd">        [(x + 1)**2,              2, 0],</span>
<span class="sd">        [         y,              0, 3]])</span>
<span class="sd">        &gt;&gt;&gt; m.is_symmetric()</span>
<span class="sd">        True</span>

<span class="sd">        If the matrix is already simplified, you may speed-up is_symmetric()</span>
<span class="sd">        test by using &#39;simplify=False&#39;.</span>

<span class="sd">        &gt;&gt;&gt; m.is_symmetric(simplify=False)</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; m1 = m.expand()</span>
<span class="sd">        &gt;&gt;&gt; m1.is_symmetric(simplify=False)</span>
<span class="sd">        True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_square</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span>
        <span class="k">if</span> <span class="n">simplify</span><span class="p">:</span>
            <span class="n">delta</span> <span class="o">=</span> <span class="bp">self</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
            <span class="n">delta</span><span class="o">.</span><span class="n">simplify</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">delta</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span></div>

<div class="viewcode-block" id="MatrixBase.is_anti_symmetric"><a class="viewcode-back" href="../../../modules/matrices/matrices.html#sympy.matrices.immutable.MatrixBase.is_anti_symmetric">[docs]</a>    <span class="k">def</span> <span class="nf">is_anti_symmetric</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">simplify</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Check if matrix M is an antisymmetric matrix,</span>
<span class="sd">        that is, M is a square matrix with all M[i, j] == -M[j, i].</span>

<span class="sd">        When ``simplify=True`` (default), the sum M[i, j] + M[j, i] is</span>
<span class="sd">        simplified before testing to see if it is zero. By default,</span>
<span class="sd">        the SymPy simplify function is used. To use a custom function</span>
<span class="sd">        set simplify to a function that accepts a single argument which</span>
<span class="sd">        returns a simplified expression. To skip simplification, set</span>
<span class="sd">        simplify to False but note that although this will be faster,</span>
<span class="sd">        it may induce false negatives.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy import Matrix, symbols</span>
<span class="sd">        &gt;&gt;&gt; m = Matrix(2, 2, [0, 1, -1, 0])</span>
<span class="sd">        &gt;&gt;&gt; m</span>
<span class="sd">        Matrix([</span>
<span class="sd">        [ 0, 1],</span>
<span class="sd">        [-1, 0]])</span>
<span class="sd">        &gt;&gt;&gt; m.is_anti_symmetric()</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; x, y = symbols(&#39;x y&#39;)</span>
<span class="sd">        &gt;&gt;&gt; m = Matrix(2, 3, [0, 0, x, -y, 0, 0])</span>
<span class="sd">        &gt;&gt;&gt; m</span>
<span class="sd">        Matrix([</span>
<span class="sd">        [ 0, 0, x],</span>
<span class="sd">        [-y, 0, 0]])</span>
<span class="sd">        &gt;&gt;&gt; m.is_anti_symmetric()</span>
<span class="sd">        False</span>

<span class="sd">        &gt;&gt;&gt; from sympy.abc import x, y</span>
<span class="sd">        &gt;&gt;&gt; m = Matrix(3, 3, [0, x**2 + 2*x + 1, y,</span>
<span class="sd">        ...                   -(x + 1)**2 , 0, x*y,</span>
<span class="sd">        ...                   -y, -x*y, 0])</span>

<span class="sd">        Simplification of matrix elements is done by default so even</span>
<span class="sd">        though two elements which should be equal and opposite wouldn&#39;t</span>
<span class="sd">        pass an equality test, the matrix is still reported as</span>
<span class="sd">        anti-symmetric:</span>

<span class="sd">        &gt;&gt;&gt; m[0, 1] == -m[1, 0]</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; m.is_anti_symmetric()</span>
<span class="sd">        True</span>

<span class="sd">        If &#39;simplify=False&#39; is used for the case when a Matrix is already</span>
<span class="sd">        simplified, this will speed things up. Here, we see that without</span>
<span class="sd">        simplification the matrix does not appear anti-symmetric:</span>

<span class="sd">        &gt;&gt;&gt; m.is_anti_symmetric(simplify=False)</span>
<span class="sd">        False</span>

<span class="sd">        But if the matrix were already expanded, then it would appear</span>
<span class="sd">        anti-symmetric and simplification in the is_anti_symmetric routine</span>
<span class="sd">        is not needed:</span>

<span class="sd">        &gt;&gt;&gt; m = m.expand()</span>
<span class="sd">        &gt;&gt;&gt; m.is_anti_symmetric(simplify=False)</span>
<span class="sd">        True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># accept custom simplification</span>
        <span class="n">simpfunc</span> <span class="o">=</span> <span class="n">simplify</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">simplify</span><span class="p">,</span> <span class="n">FunctionType</span><span class="p">)</span> <span class="k">else</span> \
            <span class="n">_simplify</span> <span class="k">if</span> <span class="n">simplify</span> <span class="k">else</span> <span class="bp">False</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_square</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span>
        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rows</span>
        <span class="k">if</span> <span class="n">simplify</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
                <span class="c1"># diagonal</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">simpfunc</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">])</span><span class="o">.</span><span class="n">is_zero</span><span class="p">:</span>
                    <span class="k">return</span> <span class="bp">False</span>
                <span class="c1"># others</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
                    <span class="n">diff</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">simpfunc</span><span class="p">(</span><span class="n">diff</span><span class="p">)</span><span class="o">.</span><span class="n">is_zero</span><span class="p">:</span>
                        <span class="k">return</span> <span class="bp">False</span>
            <span class="k">return</span> <span class="bp">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">!=</span> <span class="o">-</span><span class="bp">self</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">]:</span>
                        <span class="k">return</span> <span class="bp">False</span>
            <span class="k">return</span> <span class="bp">True</span></div>

<div class="viewcode-block" id="MatrixBase.is_diagonal"><a class="viewcode-back" href="../../../modules/matrices/matrices.html#sympy.matrices.immutable.MatrixBase.is_diagonal">[docs]</a>    <span class="k">def</span> <span class="nf">is_diagonal</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Check if matrix is diagonal,</span>
<span class="sd">        that is matrix in which the entries outside the main diagonal are all zero.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy import Matrix, diag</span>
<span class="sd">        &gt;&gt;&gt; m = Matrix(2, 2, [1, 0, 0, 2])</span>
<span class="sd">        &gt;&gt;&gt; m</span>
<span class="sd">        Matrix([</span>
<span class="sd">        [1, 0],</span>
<span class="sd">        [0, 2]])</span>
<span class="sd">        &gt;&gt;&gt; m.is_diagonal()</span>
<span class="sd">        True</span>

<span class="sd">        &gt;&gt;&gt; m = Matrix(2, 2, [1, 1, 0, 2])</span>
<span class="sd">        &gt;&gt;&gt; m</span>
<span class="sd">        Matrix([</span>
<span class="sd">        [1, 1],</span>
<span class="sd">        [0, 2]])</span>
<span class="sd">        &gt;&gt;&gt; m.is_diagonal()</span>
<span class="sd">        False</span>

<span class="sd">        &gt;&gt;&gt; m = diag(1, 2, 3)</span>
<span class="sd">        &gt;&gt;&gt; m</span>
<span class="sd">        Matrix([</span>
<span class="sd">        [1, 0, 0],</span>
<span class="sd">        [0, 2, 0],</span>
<span class="sd">        [0, 0, 3]])</span>
<span class="sd">        &gt;&gt;&gt; m.is_diagonal()</span>
<span class="sd">        True</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        is_lower</span>
<span class="sd">        is_upper</span>
<span class="sd">        is_diagonalizable</span>
<span class="sd">        diagonalize</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">j</span> <span class="ow">and</span> <span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]:</span>
                    <span class="k">return</span> <span class="bp">False</span>
        <span class="k">return</span> <span class="bp">True</span></div>

<div class="viewcode-block" id="MatrixBase.det"><a class="viewcode-back" href="../../../modules/matrices/matrices.html#sympy.matrices.immutable.MatrixBase.det">[docs]</a>    <span class="k">def</span> <span class="nf">det</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;bareis&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Computes the matrix determinant using the method &quot;method&quot;.</span>

<span class="sd">        Possible values for &quot;method&quot;:</span>
<span class="sd">          bareis ... det_bareis</span>
<span class="sd">          berkowitz ... berkowitz_det</span>
<span class="sd">          det_LU ... det_LU_decomposition</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        det_bareis</span>
<span class="sd">        berkowitz_det</span>
<span class="sd">        det_LU</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># if methods were made internal and all determinant calculations</span>
        <span class="c1"># passed through here, then these lines could be factored out of</span>
        <span class="c1"># the method routines</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_square</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">NonSquareMatrixError</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span>
        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;bareis&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">det_bareis</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;berkowitz&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">berkowitz_det</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;det_LU&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">det_LU_decomposition</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Determinant method &#39;</span><span class="si">%s</span><span class="s2">&#39; unrecognized&quot;</span> <span class="o">%</span> <span class="n">method</span><span class="p">)</span></div>

<div class="viewcode-block" id="MatrixBase.det_bareis"><a class="viewcode-back" href="../../../modules/matrices/matrices.html#sympy.matrices.immutable.MatrixBase.det_bareis">[docs]</a>    <span class="k">def</span> <span class="nf">det_bareis</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compute matrix determinant using Bareis&#39; fraction-free</span>
<span class="sd">        algorithm which is an extension of the well known Gaussian</span>
<span class="sd">        elimination method. This approach is best suited for dense</span>
<span class="sd">        symbolic matrices and will result in a determinant with</span>
<span class="sd">        minimal number of fractions. It means that less term</span>
<span class="sd">        rewriting is needed on resulting formulae.</span>

<span class="sd">        TODO: Implement algorithm for sparse matrices (SFF),</span>
<span class="sd">        http://www.eecis.udel.edu/~saunders/papers/sffge/it5.ps.</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        det</span>
<span class="sd">        berkowitz_det</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_square</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">NonSquareMatrixError</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span>

        <span class="n">M</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span><span class="o">.</span><span class="n">as_mutable</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">rows</span>

        <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">det</span> <span class="o">=</span> <span class="n">M</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">det</span> <span class="o">=</span> <span class="n">M</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">M</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">M</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">M</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">det</span> <span class="o">=</span> <span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">M</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">M</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">M</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">M</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">M</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">M</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">M</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">M</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span> <span class="o">-</span> \
                  <span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">M</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">M</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">M</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">M</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">M</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">M</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">M</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">M</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">sign</span> <span class="o">=</span> <span class="mi">1</span>  <span class="c1"># track current sign in case of column swap</span>

            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
                <span class="c1"># look for a pivot in the current column</span>
                <span class="c1"># and assume det == 0 if none is found</span>
                <span class="k">if</span> <span class="n">M</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
                        <span class="k">if</span> <span class="n">M</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">k</span><span class="p">]:</span>
                            <span class="n">M</span><span class="o">.</span><span class="n">row_swap</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
                            <span class="n">sign</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span>
                            <span class="k">break</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">return</span> <span class="n">S</span><span class="o">.</span><span class="n">Zero</span>

                <span class="c1"># proceed with Bareis&#39; fraction-free (FF)</span>
                <span class="c1"># form of Gaussian elimination algorithm</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
                        <span class="n">D</span> <span class="o">=</span> <span class="n">M</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span><span class="o">*</span><span class="n">M</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">-</span> <span class="n">M</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span><span class="o">*</span><span class="n">M</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>

                        <span class="k">if</span> <span class="n">k</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="n">D</span> <span class="o">/=</span> <span class="n">M</span><span class="p">[</span><span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>

                        <span class="k">if</span> <span class="n">D</span><span class="o">.</span><span class="n">is_Atom</span><span class="p">:</span>
                            <span class="n">M</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">D</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">M</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">cancel</span><span class="p">(</span><span class="n">D</span><span class="p">)</span>

            <span class="n">det</span> <span class="o">=</span> <span class="n">sign</span><span class="o">*</span><span class="n">M</span><span class="p">[</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">det</span><span class="o">.</span><span class="n">expand</span><span class="p">()</span></div>

<div class="viewcode-block" id="MatrixBase.det_LU_decomposition"><a class="viewcode-back" href="../../../modules/matrices/matrices.html#sympy.matrices.immutable.MatrixBase.det_LU_decomposition">[docs]</a>    <span class="k">def</span> <span class="nf">det_LU_decomposition</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compute matrix determinant using LU decomposition</span>

<span class="sd">        Note that this method fails if the LU decomposition itself</span>
<span class="sd">        fails. In particular, if the matrix has no inverse this method</span>
<span class="sd">        will fail.</span>

<span class="sd">        TODO: Implement algorithm for sparse matrices (SFF),</span>
<span class="sd">        http://www.eecis.udel.edu/~saunders/papers/sffge/it5.ps.</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        det</span>
<span class="sd">        det_bareis</span>
<span class="sd">        berkowitz_det</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_square</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">NonSquareMatrixError</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span>

        <span class="n">M</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">rows</span>
        <span class="n">p</span><span class="p">,</span> <span class="n">prod</span> <span class="o">=</span> <span class="p">[],</span> <span class="mi">1</span>
        <span class="n">l</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">p</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">LUdecomposition</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">prod</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>

        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="n">prod</span> <span class="o">=</span> <span class="n">prod</span><span class="o">*</span><span class="n">u</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span><span class="o">*</span><span class="n">l</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">prod</span><span class="o">.</span><span class="n">expand</span><span class="p">()</span></div>

<div class="viewcode-block" id="MatrixBase.adjugate"><a class="viewcode-back" href="../../../modules/matrices/matrices.html#sympy.matrices.immutable.MatrixBase.adjugate">[docs]</a>    <span class="k">def</span> <span class="nf">adjugate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;berkowitz&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the adjugate matrix.</span>

<span class="sd">        Adjugate matrix is the transpose of the cofactor matrix.</span>

<span class="sd">        http://en.wikipedia.org/wiki/Adjugate</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        cofactorMatrix</span>
<span class="sd">        transpose</span>
<span class="sd">        berkowitz</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">cofactorMatrix</span><span class="p">(</span><span class="n">method</span><span class="p">)</span><span class="o">.</span><span class="n">T</span></div>

<div class="viewcode-block" id="MatrixBase.inverse_LU"><a class="viewcode-back" href="../../../modules/matrices/matrices.html#sympy.matrices.immutable.MatrixBase.inverse_LU">[docs]</a>    <span class="k">def</span> <span class="nf">inverse_LU</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">iszerofunc</span><span class="o">=</span><span class="n">_iszero</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculates the inverse using LU decomposition.</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        inv</span>
<span class="sd">        inverse_GE</span>
<span class="sd">        inverse_ADJ</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_square</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">NonSquareMatrixError</span><span class="p">()</span>

        <span class="n">ok</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rref</span><span class="p">(</span><span class="n">simplify</span><span class="o">=</span><span class="bp">True</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">iszerofunc</span><span class="p">(</span><span class="n">ok</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">j</span><span class="p">])</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ok</span><span class="o">.</span><span class="n">rows</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Matrix det == 0; not invertible.&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">LUsolve</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="p">),</span> <span class="n">iszerofunc</span><span class="o">=</span><span class="n">_iszero</span><span class="p">)</span></div>

<div class="viewcode-block" id="MatrixBase.inverse_GE"><a class="viewcode-back" href="../../../modules/matrices/matrices.html#sympy.matrices.immutable.MatrixBase.inverse_GE">[docs]</a>    <span class="k">def</span> <span class="nf">inverse_GE</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">iszerofunc</span><span class="o">=</span><span class="n">_iszero</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculates the inverse using Gaussian elimination.</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        inv</span>
<span class="sd">        inverse_LU</span>
<span class="sd">        inverse_ADJ</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">.dense</span> <span class="kn">import</span> <span class="n">Matrix</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_square</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">NonSquareMatrixError</span><span class="p">(</span><span class="s2">&quot;A Matrix must be square to invert.&quot;</span><span class="p">)</span>

        <span class="n">big</span> <span class="o">=</span> <span class="n">Matrix</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">as_mutable</span><span class="p">(),</span> <span class="n">Matrix</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="p">))</span>
        <span class="n">red</span> <span class="o">=</span> <span class="n">big</span><span class="o">.</span><span class="n">rref</span><span class="p">(</span><span class="n">iszerofunc</span><span class="o">=</span><span class="n">iszerofunc</span><span class="p">,</span> <span class="n">simplify</span><span class="o">=</span><span class="bp">True</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">iszerofunc</span><span class="p">(</span><span class="n">red</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">j</span><span class="p">])</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">red</span><span class="o">.</span><span class="n">rows</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Matrix det == 0; not invertible.&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_new</span><span class="p">(</span><span class="n">red</span><span class="p">[:,</span> <span class="n">big</span><span class="o">.</span><span class="n">rows</span><span class="p">:])</span></div>

<div class="viewcode-block" id="MatrixBase.inverse_ADJ"><a class="viewcode-back" href="../../../modules/matrices/matrices.html#sympy.matrices.immutable.MatrixBase.inverse_ADJ">[docs]</a>    <span class="k">def</span> <span class="nf">inverse_ADJ</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">iszerofunc</span><span class="o">=</span><span class="n">_iszero</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculates the inverse using the adjugate matrix and a determinant.</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        inv</span>
<span class="sd">        inverse_LU</span>
<span class="sd">        inverse_GE</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_square</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">NonSquareMatrixError</span><span class="p">(</span><span class="s2">&quot;A Matrix must be square to invert.&quot;</span><span class="p">)</span>

        <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">berkowitz_det</span><span class="p">()</span>
        <span class="n">zero</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">zero</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="c1"># if equals() can&#39;t decide, will rref be able to?</span>
            <span class="n">ok</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rref</span><span class="p">(</span><span class="n">simplify</span><span class="o">=</span><span class="bp">True</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">zero</span> <span class="o">=</span> <span class="nb">any</span><span class="p">(</span><span class="n">iszerofunc</span><span class="p">(</span><span class="n">ok</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">j</span><span class="p">])</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ok</span><span class="o">.</span><span class="n">rows</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">zero</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Matrix det == 0; not invertible.&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">adjugate</span><span class="p">()</span> <span class="o">/</span> <span class="n">d</span></div>

<div class="viewcode-block" id="MatrixBase.rref"><a class="viewcode-back" href="../../../modules/matrices/matrices.html#sympy.matrices.immutable.MatrixBase.rref">[docs]</a>    <span class="k">def</span> <span class="nf">rref</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">iszerofunc</span><span class="o">=</span><span class="n">_iszero</span><span class="p">,</span> <span class="n">simplify</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return reduced row-echelon form of matrix and indices of pivot vars.</span>

<span class="sd">        To simplify elements before finding nonzero pivots set simplify=True</span>
<span class="sd">        (to use the default SymPy simplify function) or pass a custom</span>
<span class="sd">        simplify function.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy import Matrix</span>
<span class="sd">        &gt;&gt;&gt; from sympy.abc import x</span>
<span class="sd">        &gt;&gt;&gt; m = Matrix([[1, 2], [x, 1 - 1/x]])</span>
<span class="sd">        &gt;&gt;&gt; m.rref()</span>
<span class="sd">        (Matrix([</span>
<span class="sd">        [1, 0],</span>
<span class="sd">        [0, 1]]), [0, 1])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">simpfunc</span> <span class="o">=</span> <span class="n">simplify</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span>
            <span class="n">simplify</span><span class="p">,</span> <span class="n">FunctionType</span><span class="p">)</span> <span class="k">else</span> <span class="n">_simplify</span>
        <span class="c1"># pivot: index of next row to contain a pivot</span>
        <span class="n">pivot</span><span class="p">,</span> <span class="n">r</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_mutable</span><span class="p">()</span>
        <span class="c1"># pivotlist: indices of pivot variables (non-free)</span>
        <span class="n">pivotlist</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">cols</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">pivot</span> <span class="o">==</span> <span class="n">r</span><span class="o">.</span><span class="n">rows</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="k">if</span> <span class="n">simplify</span><span class="p">:</span>
                <span class="n">r</span><span class="p">[</span><span class="n">pivot</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">simpfunc</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="n">pivot</span><span class="p">,</span> <span class="n">i</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">iszerofunc</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="n">pivot</span><span class="p">,</span> <span class="n">i</span><span class="p">]):</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">pivot</span><span class="p">,</span> <span class="n">r</span><span class="o">.</span><span class="n">rows</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">simplify</span> <span class="ow">and</span> <span class="n">k</span> <span class="o">&gt;</span> <span class="n">pivot</span><span class="p">:</span>
                        <span class="n">r</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">simpfunc</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">i</span><span class="p">])</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">iszerofunc</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">i</span><span class="p">]):</span>
                        <span class="n">r</span><span class="o">.</span><span class="n">row_swap</span><span class="p">(</span><span class="n">pivot</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
                        <span class="k">break</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">continue</span>
            <span class="n">scale</span> <span class="o">=</span> <span class="n">r</span><span class="p">[</span><span class="n">pivot</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span>
            <span class="n">r</span><span class="o">.</span><span class="n">row_op</span><span class="p">(</span><span class="n">pivot</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">_</span><span class="p">:</span> <span class="n">x</span> <span class="o">/</span> <span class="n">scale</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">rows</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">j</span> <span class="o">==</span> <span class="n">pivot</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="n">scale</span> <span class="o">=</span> <span class="n">r</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span>
                <span class="n">r</span><span class="o">.</span><span class="n">zip_row_op</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">pivot</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">x</span> <span class="o">-</span> <span class="n">scale</span><span class="o">*</span><span class="n">y</span><span class="p">)</span>
            <span class="n">pivotlist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="n">pivot</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_new</span><span class="p">(</span><span class="n">r</span><span class="p">),</span> <span class="n">pivotlist</span></div>

<div class="viewcode-block" id="MatrixBase.rank"><a class="viewcode-back" href="../../../modules/matrices/matrices.html#sympy.matrices.immutable.MatrixBase.rank">[docs]</a>    <span class="k">def</span> <span class="nf">rank</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">iszerofunc</span><span class="o">=</span><span class="n">_iszero</span><span class="p">,</span> <span class="n">simplify</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the rank of a matrix</span>

<span class="sd">        &gt;&gt;&gt; from sympy import Matrix</span>
<span class="sd">        &gt;&gt;&gt; from sympy.abc import x</span>
<span class="sd">        &gt;&gt;&gt; m = Matrix([[1, 2], [x, 1 - 1/x]])</span>
<span class="sd">        &gt;&gt;&gt; m.rank()</span>
<span class="sd">        2</span>
<span class="sd">        &gt;&gt;&gt; n = Matrix(3, 3, range(1, 10))</span>
<span class="sd">        &gt;&gt;&gt; n.rank()</span>
<span class="sd">        2</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">row_reduced</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rref</span><span class="p">(</span><span class="n">iszerofunc</span><span class="o">=</span><span class="n">iszerofunc</span><span class="p">,</span> <span class="n">simplify</span><span class="o">=</span><span class="n">simplify</span><span class="p">)</span>
        <span class="n">rank</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">row_reduced</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">rank</span></div>

<div class="viewcode-block" id="MatrixBase.nullspace"><a class="viewcode-back" href="../../../modules/matrices/matrices.html#sympy.matrices.immutable.MatrixBase.nullspace">[docs]</a>    <span class="k">def</span> <span class="nf">nullspace</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">simplify</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns list of vectors (Matrix objects) that span nullspace of self</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.matrices import Matrix</span>
<span class="sd">        &gt;&gt;&gt; m = Matrix(3, 3, [1, 3, 0, -2, -6, 0, 3, 9, 6])</span>
<span class="sd">        &gt;&gt;&gt; m</span>
<span class="sd">        Matrix([</span>
<span class="sd">        [ 1,  3, 0],</span>
<span class="sd">        [-2, -6, 0],</span>
<span class="sd">        [ 3,  9, 6]])</span>
<span class="sd">        &gt;&gt;&gt; m.nullspace()</span>
<span class="sd">        [Matrix([</span>
<span class="sd">        [-3],</span>
<span class="sd">        [ 1],</span>
<span class="sd">        [ 0]])]</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        columnspace</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">sympy.matrices</span> <span class="kn">import</span> <span class="n">zeros</span>

        <span class="n">simpfunc</span> <span class="o">=</span> <span class="n">simplify</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span>
            <span class="n">simplify</span><span class="p">,</span> <span class="n">FunctionType</span><span class="p">)</span> <span class="k">else</span> <span class="n">_simplify</span>
        <span class="n">reduced</span><span class="p">,</span> <span class="n">pivots</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rref</span><span class="p">(</span><span class="n">simplify</span><span class="o">=</span><span class="n">simpfunc</span><span class="p">)</span>

        <span class="n">basis</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># create a set of vectors for the basis</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cols</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">pivots</span><span class="p">)):</span>
            <span class="n">basis</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        <span class="c1"># contains the variable index to which the vector corresponds</span>
        <span class="n">basiskey</span><span class="p">,</span> <span class="n">cur</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">basis</span><span class="p">),</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">pivots</span><span class="p">:</span>
                <span class="n">basiskey</span><span class="p">[</span><span class="n">cur</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>
                <span class="n">cur</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">pivots</span><span class="p">:</span>  <span class="c1"># free var, just set vector&#39;s ith place to 1</span>
                <span class="n">basis</span><span class="p">[</span><span class="n">basiskey</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">i</span><span class="p">)][</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>               <span class="c1"># add negative of nonpivot entry to corr vector</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">):</span>
                    <span class="n">line</span> <span class="o">=</span> <span class="n">pivots</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                    <span class="n">v</span> <span class="o">=</span> <span class="n">reduced</span><span class="p">[</span><span class="n">line</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">simplify</span><span class="p">:</span>
                        <span class="n">v</span> <span class="o">=</span> <span class="n">simpfunc</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">v</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">pivots</span><span class="p">:</span>
                            <span class="c1"># XXX: Is this the correct error?</span>
                            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                                <span class="s2">&quot;Could not compute the nullspace of `self`.&quot;</span><span class="p">)</span>
                        <span class="n">basis</span><span class="p">[</span><span class="n">basiskey</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">j</span><span class="p">)][</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">v</span>
        <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_new</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">basis</span><span class="p">]</span></div>

<div class="viewcode-block" id="MatrixBase.columnspace"><a class="viewcode-back" href="../../../modules/matrices/matrices.html#sympy.matrices.immutable.MatrixBase.columnspace">[docs]</a>    <span class="k">def</span> <span class="nf">columnspace</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">simplify</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns list of vectors (Matrix objects) that span columnspace of self</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.matrices import Matrix</span>
<span class="sd">        &gt;&gt;&gt; m = Matrix(3, 3, [1, 3, 0, -2, -6, 0, 3, 9, 6])</span>
<span class="sd">        &gt;&gt;&gt; m</span>
<span class="sd">        Matrix([</span>
<span class="sd">        [ 1,  3, 0],</span>
<span class="sd">        [-2, -6, 0],</span>
<span class="sd">        [ 3,  9, 6]])</span>
<span class="sd">        &gt;&gt;&gt; m.columnspace()</span>
<span class="sd">        [Matrix([</span>
<span class="sd">        [ 1],</span>
<span class="sd">        [-2],</span>
<span class="sd">        [ 3]]), Matrix([</span>
<span class="sd">        [0],</span>
<span class="sd">        [0],</span>
<span class="sd">        [6]])]</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        nullspace</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">simpfunc</span> <span class="o">=</span> <span class="n">simplify</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span>
            <span class="n">simplify</span><span class="p">,</span> <span class="n">FunctionType</span><span class="p">)</span> <span class="k">else</span> <span class="n">_simplify</span>
        <span class="n">reduced</span><span class="p">,</span> <span class="n">pivots</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rref</span><span class="p">(</span><span class="n">simplify</span><span class="o">=</span><span class="n">simpfunc</span><span class="p">)</span>

        <span class="n">basis</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># create a set of vectors for the basis</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">pivots</span><span class="p">:</span>
                <span class="n">basis</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">col</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
        <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_new</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">basis</span><span class="p">]</span></div>

<div class="viewcode-block" id="MatrixBase.berkowitz"><a class="viewcode-back" href="../../../modules/matrices/matrices.html#sympy.matrices.immutable.MatrixBase.berkowitz">[docs]</a>    <span class="k">def</span> <span class="nf">berkowitz</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The Berkowitz algorithm.</span>

<span class="sd">           Given N x N matrix with symbolic content, compute efficiently</span>
<span class="sd">           coefficients of characteristic polynomials of &#39;self&#39; and all</span>
<span class="sd">           its square sub-matrices composed by removing both i-th row</span>
<span class="sd">           and column, without division in the ground domain.</span>

<span class="sd">           This method is particularly useful for computing determinant,</span>
<span class="sd">           principal minors and characteristic polynomial, when &#39;self&#39;</span>
<span class="sd">           has complicated coefficients e.g. polynomials. Semi-direct</span>
<span class="sd">           usage of this algorithm is also important in computing</span>
<span class="sd">           efficiently sub-resultant PRS.</span>

<span class="sd">           Assuming that M is a square matrix of dimension N x N and</span>
<span class="sd">           I is N x N identity matrix,  then the following following</span>
<span class="sd">           definition of characteristic polynomial is begin used:</span>

<span class="sd">                          charpoly(M) = det(t*I - M)</span>

<span class="sd">           As a consequence, all polynomials generated by Berkowitz</span>
<span class="sd">           algorithm are monic.</span>

<span class="sd">           &gt;&gt;&gt; from sympy import Matrix</span>
<span class="sd">           &gt;&gt;&gt; from sympy.abc import x, y, z</span>

<span class="sd">           &gt;&gt;&gt; M = Matrix([[x, y, z], [1, 0, 0], [y, z, x]])</span>

<span class="sd">           &gt;&gt;&gt; p, q, r, s = M.berkowitz()</span>

<span class="sd">           &gt;&gt;&gt; p # 0 x 0 M&#39;s sub-matrix</span>
<span class="sd">           (1,)</span>

<span class="sd">           &gt;&gt;&gt; q # 1 x 1 M&#39;s sub-matrix</span>
<span class="sd">           (1, -x)</span>

<span class="sd">           &gt;&gt;&gt; r # 2 x 2 M&#39;s sub-matrix</span>
<span class="sd">           (1, -x, -y)</span>

<span class="sd">           &gt;&gt;&gt; s # 3 x 3 M&#39;s sub-matrix</span>
<span class="sd">           (1, -2*x, x**2 - y*z - y, x*y - z**2)</span>

<span class="sd">           For more information on the implemented algorithm refer to:</span>

<span class="sd">           [1] S.J. Berkowitz, On computing the determinant in small</span>
<span class="sd">               parallel time using a small number of processors, ACM,</span>
<span class="sd">               Information Processing Letters 18, 1984, pp. 147-150</span>

<span class="sd">           [2] M. Keber, Division-Free computation of sub-resultants</span>
<span class="sd">               using Bezout matrices, Tech. Report MPI-I-2006-1-006,</span>
<span class="sd">               Saarbrucken, 2006</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        berkowitz_det</span>
<span class="sd">        berkowitz_minors</span>
<span class="sd">        berkowitz_charpoly</span>
<span class="sd">        berkowitz_eigenvals</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">sympy.matrices</span> <span class="kn">import</span> <span class="n">zeros</span>
        <span class="n">berk</span> <span class="o">=</span> <span class="p">((</span><span class="mi">1</span><span class="p">,),)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">berk</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_square</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">NonSquareMatrixError</span><span class="p">()</span>

        <span class="n">A</span><span class="p">,</span> <span class="n">N</span> <span class="o">=</span> <span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">rows</span>
        <span class="n">transforms</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">N</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">T</span><span class="p">,</span> <span class="n">k</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">),</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span>

            <span class="n">R</span><span class="p">,</span> <span class="n">C</span> <span class="o">=</span> <span class="o">-</span><span class="n">A</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="p">:</span><span class="n">k</span><span class="p">],</span> <span class="n">A</span><span class="p">[:</span><span class="n">k</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span>
            <span class="n">A</span><span class="p">,</span> <span class="n">a</span> <span class="o">=</span> <span class="n">A</span><span class="p">[:</span><span class="n">k</span><span class="p">,</span> <span class="p">:</span><span class="n">k</span><span class="p">],</span> <span class="o">-</span><span class="n">A</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span>

            <span class="n">items</span> <span class="o">=</span> <span class="p">[</span><span class="n">C</span><span class="p">]</span>

            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">2</span><span class="p">):</span>
                <span class="n">items</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">A</span><span class="o">*</span><span class="n">items</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">B</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">items</span><span class="p">):</span>
                <span class="n">items</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">R</span><span class="o">*</span><span class="n">B</span><span class="p">)[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>

            <span class="n">items</span> <span class="o">=</span> <span class="p">[</span><span class="n">S</span><span class="o">.</span><span class="n">One</span><span class="p">,</span> <span class="n">a</span><span class="p">]</span> <span class="o">+</span> <span class="n">items</span>

            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
                <span class="n">T</span><span class="p">[</span><span class="n">i</span><span class="p">:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">items</span><span class="p">[:</span><span class="n">n</span> <span class="o">-</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>

            <span class="n">transforms</span><span class="p">[</span><span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">T</span>

        <span class="n">polys</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_new</span><span class="p">([</span><span class="n">S</span><span class="o">.</span><span class="n">One</span><span class="p">,</span> <span class="o">-</span><span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])]</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">T</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">transforms</span><span class="p">):</span>
            <span class="n">polys</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">T</span><span class="o">*</span><span class="n">polys</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">berk</span> <span class="o">+</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="n">polys</span><span class="p">))</span></div>


<div class="viewcode-block" id="MatrixBase.berkowitz_det"><a class="viewcode-back" href="../../../modules/matrices/matrices.html#sympy.matrices.immutable.MatrixBase.berkowitz_det">[docs]</a>    <span class="k">def</span> <span class="nf">berkowitz_det</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Computes determinant using Berkowitz method.</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        det</span>
<span class="sd">        berkowitz</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_square</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">NonSquareMatrixError</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span>
        <span class="n">poly</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">berkowitz</span><span class="p">()[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">sign</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">poly</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">sign</span><span class="o">*</span><span class="n">poly</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span></div>

<div class="viewcode-block" id="MatrixBase.berkowitz_minors"><a class="viewcode-back" href="../../../modules/matrices/matrices.html#sympy.matrices.immutable.MatrixBase.berkowitz_minors">[docs]</a>    <span class="k">def</span> <span class="nf">berkowitz_minors</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Computes principal minors using Berkowitz method.</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        berkowitz</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sign</span><span class="p">,</span> <span class="n">minors</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span><span class="p">,</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">poly</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">berkowitz</span><span class="p">():</span>
            <span class="n">minors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sign</span><span class="o">*</span><span class="n">poly</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">sign</span> <span class="o">=</span> <span class="o">-</span><span class="n">sign</span>

        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">minors</span><span class="p">)</span></div>

<div class="viewcode-block" id="MatrixBase.berkowitz_charpoly"><a class="viewcode-back" href="../../../modules/matrices/matrices.html#sympy.matrices.immutable.MatrixBase.berkowitz_charpoly">[docs]</a>    <span class="k">def</span> <span class="nf">berkowitz_charpoly</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="n">Dummy</span><span class="p">(</span><span class="s1">&#39;lambda&#39;</span><span class="p">),</span> <span class="n">simplify</span><span class="o">=</span><span class="n">_simplify</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Computes characteristic polynomial minors using Berkowitz method.</span>

<span class="sd">        A PurePoly is returned so using different variables for ``x`` does</span>
<span class="sd">        not affect the comparison or the polynomials:</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy import Matrix</span>
<span class="sd">        &gt;&gt;&gt; from sympy.abc import x, y</span>
<span class="sd">        &gt;&gt;&gt; A = Matrix([[1, 3], [2, 0]])</span>
<span class="sd">        &gt;&gt;&gt; A.berkowitz_charpoly(x) == A.berkowitz_charpoly(y)</span>
<span class="sd">        True</span>

<span class="sd">        Specifying ``x`` is optional; a Dummy with name ``lambda`` is used by</span>
<span class="sd">        default (which looks good when pretty-printed in unicode):</span>

<span class="sd">        &gt;&gt;&gt; A.berkowitz_charpoly().as_expr()</span>
<span class="sd">        _lambda**2 - _lambda - 6</span>

<span class="sd">        No test is done to see that ``x`` doesn&#39;t clash with an existing</span>
<span class="sd">        symbol, so using the default (``lambda``) or your own Dummy symbol is</span>
<span class="sd">        the safest option:</span>

<span class="sd">        &gt;&gt;&gt; A = Matrix([[1, 2], [x, 0]])</span>
<span class="sd">        &gt;&gt;&gt; A.charpoly().as_expr()</span>
<span class="sd">        _lambda**2 - _lambda - 2*x</span>
<span class="sd">        &gt;&gt;&gt; A.charpoly(x).as_expr()</span>
<span class="sd">        x**2 - 3*x</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        berkowitz</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">PurePoly</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">simplify</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">berkowitz</span><span class="p">()[</span><span class="o">-</span><span class="mi">1</span><span class="p">])),</span> <span class="n">x</span><span class="p">)</span></div>

    <span class="n">charpoly</span> <span class="o">=</span> <span class="n">berkowitz_charpoly</span>

<div class="viewcode-block" id="MatrixBase.berkowitz_eigenvals"><a class="viewcode-back" href="../../../modules/matrices/matrices.html#sympy.matrices.immutable.MatrixBase.berkowitz_eigenvals">[docs]</a>    <span class="k">def</span> <span class="nf">berkowitz_eigenvals</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">flags</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Computes eigenvalues of a Matrix using Berkowitz method.</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        berkowitz</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">roots</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">berkowitz_charpoly</span><span class="p">(</span><span class="n">Dummy</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">)),</span> <span class="o">**</span><span class="n">flags</span><span class="p">)</span></div>

<div class="viewcode-block" id="MatrixBase.eigenvals"><a class="viewcode-back" href="../../../modules/matrices/matrices.html#sympy.matrices.immutable.MatrixBase.eigenvals">[docs]</a>    <span class="k">def</span> <span class="nf">eigenvals</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">flags</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return eigen values using the berkowitz_eigenvals routine.</span>

<span class="sd">        Since the roots routine doesn&#39;t always work well with Floats,</span>
<span class="sd">        they will be replaced with Rationals before calling that</span>
<span class="sd">        routine. If this is not desired, set flag ``rational`` to False.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># roots doesn&#39;t like Floats, so replace them with Rationals</span>
        <span class="c1"># unless the nsimplify flag indicates that this has already</span>
        <span class="c1"># been done, e.g. in eigenvects</span>
        <span class="n">mat</span> <span class="o">=</span> <span class="bp">self</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">mat</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="n">flags</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;rational&#39;</span><span class="p">,</span> <span class="bp">True</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">Float</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">mat</span><span class="p">):</span>
                <span class="n">mat</span> <span class="o">=</span> <span class="n">mat</span><span class="o">.</span><span class="n">_new</span><span class="p">(</span><span class="n">mat</span><span class="o">.</span><span class="n">rows</span><span class="p">,</span> <span class="n">mat</span><span class="o">.</span><span class="n">cols</span><span class="p">,</span>
                    <span class="p">[</span><span class="n">nsimplify</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">rational</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">mat</span><span class="p">])</span>

        <span class="n">flags</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;simplify&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>  <span class="c1"># pop unsupported flag</span>
        <span class="k">return</span> <span class="n">mat</span><span class="o">.</span><span class="n">berkowitz_eigenvals</span><span class="p">(</span><span class="o">**</span><span class="n">flags</span><span class="p">)</span></div>

<div class="viewcode-block" id="MatrixBase.eigenvects"><a class="viewcode-back" href="../../../modules/matrices/matrices.html#sympy.matrices.immutable.MatrixBase.eigenvects">[docs]</a>    <span class="k">def</span> <span class="nf">eigenvects</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">flags</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return list of triples (eigenval, multiplicity, basis).</span>

<span class="sd">        The flag ``simplify`` has two effects:</span>
<span class="sd">            1) if bool(simplify) is True, as_content_primitive()</span>
<span class="sd">            will be used to tidy up normalization artifacts;</span>
<span class="sd">            2) if nullspace needs simplification to compute the</span>
<span class="sd">            basis, the simplify flag will be passed on to the</span>
<span class="sd">            nullspace routine which will interpret it there.</span>

<span class="sd">        If the matrix contains any Floats, they will be changed to Rationals</span>
<span class="sd">        for computation purposes, but the answers will be returned after being</span>
<span class="sd">        evaluated with evalf. If it is desired to removed small imaginary</span>
<span class="sd">        portions during the evalf step, pass a value for the ``chop`` flag.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">sympy.matrices</span> <span class="kn">import</span> <span class="n">eye</span>

        <span class="n">simplify</span> <span class="o">=</span> <span class="n">flags</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;simplify&#39;</span><span class="p">,</span> <span class="bp">True</span><span class="p">)</span>
        <span class="n">primitive</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">flags</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;simplify&#39;</span><span class="p">,</span> <span class="bp">False</span><span class="p">))</span>
        <span class="n">chop</span> <span class="o">=</span> <span class="n">flags</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;chop&#39;</span><span class="p">,</span> <span class="bp">False</span><span class="p">)</span>

        <span class="n">flags</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;multiple&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>  <span class="c1"># remove this if it&#39;s there</span>

        <span class="c1"># roots doesn&#39;t like Floats, so replace them with Rationals</span>
        <span class="nb">float</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="n">mat</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">Float</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">):</span>
            <span class="nb">float</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="n">mat</span> <span class="o">=</span> <span class="n">mat</span><span class="o">.</span><span class="n">_new</span><span class="p">(</span><span class="n">mat</span><span class="o">.</span><span class="n">rows</span><span class="p">,</span> <span class="n">mat</span><span class="o">.</span><span class="n">cols</span><span class="p">,</span> <span class="p">[</span><span class="n">nsimplify</span><span class="p">(</span>
                <span class="n">v</span><span class="p">,</span> <span class="n">rational</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">mat</span><span class="p">])</span>
            <span class="n">flags</span><span class="p">[</span><span class="s1">&#39;rational&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">False</span>  <span class="c1"># to tell eigenvals not to do this</span>

        <span class="n">out</span><span class="p">,</span> <span class="n">vlist</span> <span class="o">=</span> <span class="p">[],</span> <span class="n">mat</span><span class="o">.</span><span class="n">eigenvals</span><span class="p">(</span><span class="o">**</span><span class="n">flags</span><span class="p">)</span>
        <span class="n">vlist</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">vlist</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
        <span class="n">vlist</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="n">default_sort_key</span><span class="p">)</span>
        <span class="n">flags</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;rational&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">r</span><span class="p">,</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">vlist</span><span class="p">:</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="n">mat</span><span class="o">.</span><span class="n">as_mutable</span><span class="p">()</span> <span class="o">-</span> <span class="n">eye</span><span class="p">(</span><span class="n">mat</span><span class="o">.</span><span class="n">rows</span><span class="p">)</span><span class="o">*</span><span class="n">r</span>
            <span class="n">basis</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">.</span><span class="n">nullspace</span><span class="p">()</span>
            <span class="c1"># whether tmp.is_symbolic() is True or False, it is possible that</span>
            <span class="c1"># the basis will come back as [] in which case simplification is</span>
            <span class="c1"># necessary.</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">basis</span><span class="p">:</span>
                <span class="c1"># The nullspace routine failed, try it again with simplification</span>
                <span class="n">basis</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">.</span><span class="n">nullspace</span><span class="p">(</span><span class="n">simplify</span><span class="o">=</span><span class="n">simplify</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">basis</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                        <span class="s2">&quot;Can&#39;t evaluate eigenvector for eigenvalue </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">r</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">primitive</span><span class="p">:</span>
                <span class="c1"># the relationship A*e = lambda*e will still hold if we change the</span>
                <span class="c1"># eigenvector; so if simplify is True we tidy up any normalization</span>
                <span class="c1"># artifacts with as_content_primtive (default) and remove any pure Integer</span>
                <span class="c1"># denominators.</span>
                <span class="n">l</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">basis</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                    <span class="n">c</span><span class="p">,</span> <span class="n">p</span> <span class="o">=</span> <span class="n">signsimp</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">.</span><span class="n">as_content_primitive</span><span class="p">()</span>
                    <span class="k">if</span> <span class="n">c</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span><span class="p">:</span>
                        <span class="n">b</span> <span class="o">=</span> <span class="n">c</span><span class="o">*</span><span class="n">p</span>
                        <span class="n">l</span> <span class="o">=</span> <span class="n">ilcm</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">c</span><span class="o">.</span><span class="n">q</span><span class="p">)</span>
                    <span class="n">basis</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">b</span>
                <span class="k">if</span> <span class="n">l</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">basis</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*=</span> <span class="n">l</span>
            <span class="k">if</span> <span class="nb">float</span><span class="p">:</span>
                <span class="n">out</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">r</span><span class="o">.</span><span class="n">evalf</span><span class="p">(</span><span class="n">chop</span><span class="o">=</span><span class="n">chop</span><span class="p">),</span> <span class="n">k</span><span class="p">,</span> <span class="p">[</span>
                           <span class="n">mat</span><span class="o">.</span><span class="n">_new</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">.</span><span class="n">evalf</span><span class="p">(</span><span class="n">chop</span><span class="o">=</span><span class="n">chop</span><span class="p">)</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">basis</span><span class="p">]))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">out</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">r</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="p">[</span><span class="n">mat</span><span class="o">.</span><span class="n">_new</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">basis</span><span class="p">]))</span>
        <span class="k">return</span> <span class="n">out</span></div>

<div class="viewcode-block" id="MatrixBase.left_eigenvects"><a class="viewcode-back" href="../../../modules/matrices/matrices.html#sympy.matrices.immutable.MatrixBase.left_eigenvects">[docs]</a>    <span class="k">def</span> <span class="nf">left_eigenvects</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">flags</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns left eigenvectors and eigenvalues.</span>

<span class="sd">        This function returns the list of triples (eigenval, multiplicity,</span>
<span class="sd">        basis) for the left eigenvectors. Options are the same as for</span>
<span class="sd">        eigenvects(), i.e. the ``**flags`` arguments gets passed directly to</span>
<span class="sd">        eigenvects().</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy import Matrix</span>
<span class="sd">        &gt;&gt;&gt; M = Matrix([[0, 1, 1], [1, 0, 0], [1, 1, 1]])</span>
<span class="sd">        &gt;&gt;&gt; M.eigenvects()</span>
<span class="sd">        [(-1, 1, [Matrix([</span>
<span class="sd">        [-1],</span>
<span class="sd">        [ 1],</span>
<span class="sd">        [ 0]])]), (0, 1, [Matrix([</span>
<span class="sd">        [ 0],</span>
<span class="sd">        [-1],</span>
<span class="sd">        [ 1]])]), (2, 1, [Matrix([</span>
<span class="sd">        [2/3],</span>
<span class="sd">        [1/3],</span>
<span class="sd">        [  1]])])]</span>
<span class="sd">        &gt;&gt;&gt; M.left_eigenvects()</span>
<span class="sd">        [(-1, 1, [Matrix([[-2, 1, 1]])]), (0, 1, [Matrix([[-1, -1, 1]])]), (2,</span>
<span class="sd">        1, [Matrix([[1, 1, 1]])])]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">mat</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="n">left_transpose</span> <span class="o">=</span> <span class="n">mat</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span><span class="o">.</span><span class="n">eigenvects</span><span class="p">(</span><span class="o">**</span><span class="n">flags</span><span class="p">)</span>

        <span class="n">left</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">ev</span><span class="p">,</span> <span class="n">mult</span><span class="p">,</span> <span class="n">ltmp</span><span class="p">)</span> <span class="ow">in</span> <span class="n">left_transpose</span><span class="p">:</span>
            <span class="n">left</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="p">(</span><span class="n">ev</span><span class="p">,</span> <span class="n">mult</span><span class="p">,</span> <span class="p">[</span><span class="n">l</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">ltmp</span><span class="p">])</span> <span class="p">)</span>

        <span class="k">return</span> <span class="n">left</span></div>

<div class="viewcode-block" id="MatrixBase.singular_values"><a class="viewcode-back" href="../../../modules/matrices/matrices.html#sympy.matrices.immutable.MatrixBase.singular_values">[docs]</a>    <span class="k">def</span> <span class="nf">singular_values</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compute the singular values of a Matrix</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy import Matrix, Symbol</span>
<span class="sd">        &gt;&gt;&gt; x = Symbol(&#39;x&#39;, real=True)</span>
<span class="sd">        &gt;&gt;&gt; A = Matrix([[0, 1, 0], [0, x, 0], [-1, 0, 0]])</span>
<span class="sd">        &gt;&gt;&gt; A.singular_values()</span>
<span class="sd">        [sqrt(x**2 + 1), 1, 0]</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        condition_number</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">mat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_mutable</span><span class="p">()</span>
        <span class="c1"># Compute eigenvalues of A.H A</span>
        <span class="n">valmultpairs</span> <span class="o">=</span> <span class="p">(</span><span class="n">mat</span><span class="o">.</span><span class="n">H</span><span class="o">*</span><span class="n">mat</span><span class="p">)</span><span class="o">.</span><span class="n">eigenvals</span><span class="p">()</span>

        <span class="c1"># Expands result from eigenvals into a simple list</span>
        <span class="n">vals</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">valmultpairs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">vals</span> <span class="o">+=</span> <span class="p">[</span><span class="n">sqrt</span><span class="p">(</span><span class="n">k</span><span class="p">)]</span><span class="o">*</span><span class="n">v</span>  <span class="c1"># dangerous! same k in several spots!</span>
        <span class="c1"># sort them in descending order</span>
        <span class="n">vals</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">reverse</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">default_sort_key</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">vals</span></div>

<div class="viewcode-block" id="MatrixBase.condition_number"><a class="viewcode-back" href="../../../modules/matrices/matrices.html#sympy.matrices.immutable.MatrixBase.condition_number">[docs]</a>    <span class="k">def</span> <span class="nf">condition_number</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the condition number of a matrix.</span>

<span class="sd">        This is the maximum singular value divided by the minimum singular value</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy import Matrix, S</span>
<span class="sd">        &gt;&gt;&gt; A = Matrix([[1, 0, 0], [0, 10, 0], [0, 0, S.One/10]])</span>
<span class="sd">        &gt;&gt;&gt; A.condition_number()</span>
<span class="sd">        100</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        singular_values</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">S</span><span class="o">.</span><span class="n">Zero</span>
        <span class="n">singularvalues</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">singular_values</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">Max</span><span class="p">(</span><span class="o">*</span><span class="n">singularvalues</span><span class="p">)</span> <span class="o">/</span> <span class="n">Min</span><span class="p">(</span><span class="o">*</span><span class="n">singularvalues</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">attr</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;diff&#39;</span><span class="p">,</span> <span class="s1">&#39;integrate&#39;</span><span class="p">,</span> <span class="s1">&#39;limit&#39;</span><span class="p">):</span>
            <span class="k">def</span> <span class="nf">doit</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
                <span class="n">item_doit</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">item</span><span class="p">:</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="n">attr</span><span class="p">)(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">applyfunc</span><span class="p">(</span><span class="n">item_doit</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">doit</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span>
                <span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> has no attribute </span><span class="si">%s</span><span class="s2">.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span><span class="p">,</span> <span class="n">attr</span><span class="p">))</span>

<div class="viewcode-block" id="MatrixBase.integrate"><a class="viewcode-back" href="../../../modules/matrices/matrices.html#sympy.matrices.immutable.MatrixBase.integrate">[docs]</a>    <span class="k">def</span> <span class="nf">integrate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Integrate each element of the matrix.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.matrices import Matrix</span>
<span class="sd">        &gt;&gt;&gt; from sympy.abc import x, y</span>
<span class="sd">        &gt;&gt;&gt; M = Matrix([[x, y], [1, 0]])</span>
<span class="sd">        &gt;&gt;&gt; M.integrate((x, ))</span>
<span class="sd">        Matrix([</span>
<span class="sd">        [x**2/2, x*y],</span>
<span class="sd">        [     x,   0]])</span>
<span class="sd">        &gt;&gt;&gt; M.integrate((x, 0, 2))</span>
<span class="sd">        Matrix([</span>
<span class="sd">        [2, 2*y],</span>
<span class="sd">        [2,   0]])</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        limit</span>
<span class="sd">        diff</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_new</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">,</span>
                <span class="k">lambda</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">:</span> <span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">integrate</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">))</span></div>

<div class="viewcode-block" id="MatrixBase.limit"><a class="viewcode-back" href="../../../modules/matrices/matrices.html#sympy.matrices.immutable.MatrixBase.limit">[docs]</a>    <span class="k">def</span> <span class="nf">limit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate the limit of each element in the matrix.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.matrices import Matrix</span>
<span class="sd">        &gt;&gt;&gt; from sympy.abc import x, y</span>
<span class="sd">        &gt;&gt;&gt; M = Matrix([[x, y], [1, 0]])</span>
<span class="sd">        &gt;&gt;&gt; M.limit(x, 2)</span>
<span class="sd">        Matrix([</span>
<span class="sd">        [2, y],</span>
<span class="sd">        [1, 0]])</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        integrate</span>
<span class="sd">        diff</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_new</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">,</span>
                <span class="k">lambda</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">:</span> <span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">limit</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">))</span></div>

<div class="viewcode-block" id="MatrixBase.diff"><a class="viewcode-back" href="../../../modules/matrices/matrices.html#sympy.matrices.immutable.MatrixBase.diff">[docs]</a>    <span class="k">def</span> <span class="nf">diff</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate the derivative of each element in the matrix.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.matrices import Matrix</span>
<span class="sd">        &gt;&gt;&gt; from sympy.abc import x, y</span>
<span class="sd">        &gt;&gt;&gt; M = Matrix([[x, y], [1, 0]])</span>
<span class="sd">        &gt;&gt;&gt; M.diff(x)</span>
<span class="sd">        Matrix([</span>
<span class="sd">        [1, 0],</span>
<span class="sd">        [0, 0]])</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        integrate</span>
<span class="sd">        limit</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_new</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">,</span>
                <span class="k">lambda</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">:</span> <span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">))</span></div>

<div class="viewcode-block" id="MatrixBase.vec"><a class="viewcode-back" href="../../../modules/matrices/matrices.html#sympy.matrices.immutable.MatrixBase.vec">[docs]</a>    <span class="k">def</span> <span class="nf">vec</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the Matrix converted into a one column matrix by stacking columns</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy import Matrix</span>
<span class="sd">        &gt;&gt;&gt; m=Matrix([[1, 3], [2, 4]])</span>
<span class="sd">        &gt;&gt;&gt; m</span>
<span class="sd">        Matrix([</span>
<span class="sd">        [1, 3],</span>
<span class="sd">        [2, 4]])</span>
<span class="sd">        &gt;&gt;&gt; m.vec()</span>
<span class="sd">        Matrix([</span>
<span class="sd">        [1],</span>
<span class="sd">        [2],</span>
<span class="sd">        [3],</span>
<span class="sd">        [4]])</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        vech</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span></div>

<div class="viewcode-block" id="MatrixBase.vech"><a class="viewcode-back" href="../../../modules/matrices/matrices.html#sympy.matrices.immutable.MatrixBase.vech">[docs]</a>    <span class="k">def</span> <span class="nf">vech</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">diagonal</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">check_symmetry</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the unique elements of a symmetric Matrix as a one column matrix</span>
<span class="sd">        by stacking the elements in the lower triangle.</span>

<span class="sd">        Arguments:</span>
<span class="sd">        diagonal -- include the diagonal cells of self or not</span>
<span class="sd">        check_symmetry -- checks symmetry of self but not completely reliably</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy import Matrix</span>
<span class="sd">        &gt;&gt;&gt; m=Matrix([[1, 2], [2, 3]])</span>
<span class="sd">        &gt;&gt;&gt; m</span>
<span class="sd">        Matrix([</span>
<span class="sd">        [1, 2],</span>
<span class="sd">        [2, 3]])</span>
<span class="sd">        &gt;&gt;&gt; m.vech()</span>
<span class="sd">        Matrix([</span>
<span class="sd">        [1],</span>
<span class="sd">        [2],</span>
<span class="sd">        [3]])</span>
<span class="sd">        &gt;&gt;&gt; m.vech(diagonal=False)</span>
<span class="sd">        Matrix([[2]])</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        vec</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">sympy.matrices</span> <span class="kn">import</span> <span class="n">zeros</span>

        <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span>
        <span class="k">if</span> <span class="n">c</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ShapeError</span><span class="p">(</span><span class="s2">&quot;Matrix must be square&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">check_symmetry</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">simplify</span><span class="p">()</span>
            <span class="k">if</span> <span class="bp">self</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transpose</span><span class="p">():</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Matrix appears to be asymmetric; consider check_symmetry=False&quot;</span><span class="p">)</span>
        <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">diagonal</span><span class="p">:</span>
            <span class="n">v</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">c</span><span class="o">*</span><span class="p">(</span><span class="n">c</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">c</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">c</span><span class="p">):</span>
                    <span class="n">v</span><span class="p">[</span><span class="n">count</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>
                    <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">v</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">c</span><span class="o">*</span><span class="p">(</span><span class="n">c</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">c</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">c</span><span class="p">):</span>
                    <span class="n">v</span><span class="p">[</span><span class="n">count</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>
                    <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">v</span></div>

<div class="viewcode-block" id="MatrixBase.get_diag_blocks"><a class="viewcode-back" href="../../../modules/matrices/matrices.html#sympy.matrices.immutable.MatrixBase.get_diag_blocks">[docs]</a>    <span class="k">def</span> <span class="nf">get_diag_blocks</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Obtains the square sub-matrices on the main diagonal of a square matrix.</span>

<span class="sd">        Useful for inverting symbolic matrices or solving systems of</span>
<span class="sd">        linear equations which may be decoupled by having a block diagonal</span>
<span class="sd">        structure.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy import Matrix</span>
<span class="sd">        &gt;&gt;&gt; from sympy.abc import x, y, z</span>
<span class="sd">        &gt;&gt;&gt; A = Matrix([[1, 3, 0, 0], [y, z*z, 0, 0], [0, 0, x, 0], [0, 0, 0, 0]])</span>
<span class="sd">        &gt;&gt;&gt; a1, a2, a3 = A.get_diag_blocks()</span>
<span class="sd">        &gt;&gt;&gt; a1</span>
<span class="sd">        Matrix([</span>
<span class="sd">        [1,    3],</span>
<span class="sd">        [y, z**2]])</span>
<span class="sd">        &gt;&gt;&gt; a2</span>
<span class="sd">        Matrix([[x]])</span>
<span class="sd">        &gt;&gt;&gt; a3</span>
<span class="sd">        Matrix([[0]])</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sub_blocks</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">def</span> <span class="nf">recurse_sub_blocks</span><span class="p">(</span><span class="n">M</span><span class="p">):</span>
            <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">M</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">to_the_right</span> <span class="o">=</span> <span class="n">M</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">:]</span>
                    <span class="n">to_the_bottom</span> <span class="o">=</span> <span class="n">M</span><span class="p">[</span><span class="n">i</span><span class="p">:,</span> <span class="mi">0</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">to_the_right</span> <span class="o">=</span> <span class="n">M</span><span class="p">[:</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">:]</span>
                    <span class="n">to_the_bottom</span> <span class="o">=</span> <span class="n">M</span><span class="p">[</span><span class="n">i</span><span class="p">:,</span> <span class="p">:</span><span class="n">i</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">to_the_right</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">any</span><span class="p">(</span><span class="n">to_the_bottom</span><span class="p">):</span>
                    <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="k">continue</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">sub_blocks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">M</span><span class="p">[:</span><span class="n">i</span><span class="p">,</span> <span class="p">:</span><span class="n">i</span><span class="p">])</span>
                    <span class="k">if</span> <span class="n">M</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">M</span><span class="p">[:</span><span class="n">i</span><span class="p">,</span> <span class="p">:</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
                        <span class="k">return</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">recurse_sub_blocks</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="n">i</span><span class="p">:,</span> <span class="n">i</span><span class="p">:])</span>
                        <span class="k">return</span>
        <span class="n">recurse_sub_blocks</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">sub_blocks</span></div>

<div class="viewcode-block" id="MatrixBase.diagonalize"><a class="viewcode-back" href="../../../modules/matrices/matrices.html#sympy.matrices.immutable.MatrixBase.diagonalize">[docs]</a>    <span class="k">def</span> <span class="nf">diagonalize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reals_only</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">normalize</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return (P, D), where D is diagonal and</span>

<span class="sd">            D = P^-1 * M * P</span>

<span class="sd">        where M is current matrix.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy import Matrix</span>
<span class="sd">        &gt;&gt;&gt; m = Matrix(3, 3, [1, 2, 0, 0, 3, 0, 2, -4, 2])</span>
<span class="sd">        &gt;&gt;&gt; m</span>
<span class="sd">        Matrix([</span>
<span class="sd">        [1,  2, 0],</span>
<span class="sd">        [0,  3, 0],</span>
<span class="sd">        [2, -4, 2]])</span>
<span class="sd">        &gt;&gt;&gt; (P, D) = m.diagonalize()</span>
<span class="sd">        &gt;&gt;&gt; D</span>
<span class="sd">        Matrix([</span>
<span class="sd">        [1, 0, 0],</span>
<span class="sd">        [0, 2, 0],</span>
<span class="sd">        [0, 0, 3]])</span>
<span class="sd">        &gt;&gt;&gt; P</span>
<span class="sd">        Matrix([</span>
<span class="sd">        [-1, 0, -1],</span>
<span class="sd">        [ 0, 0, -1],</span>
<span class="sd">        [ 2, 1,  2]])</span>
<span class="sd">        &gt;&gt;&gt; P.inv() * m * P</span>
<span class="sd">        Matrix([</span>
<span class="sd">        [1, 0, 0],</span>
<span class="sd">        [0, 2, 0],</span>
<span class="sd">        [0, 0, 3]])</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        is_diagonal</span>
<span class="sd">        is_diagonalizable</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">sympy.matrices</span> <span class="kn">import</span> <span class="n">diag</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_square</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">NonSquareMatrixError</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_diagonalizable</span><span class="p">(</span><span class="n">reals_only</span><span class="p">,</span> <span class="bp">False</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_diagonalize_clear_subproducts</span><span class="p">()</span>
            <span class="k">raise</span> <span class="n">MatrixError</span><span class="p">(</span><span class="s2">&quot;Matrix is not diagonalizable&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_eigenvects</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_eigenvects</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eigenvects</span><span class="p">(</span><span class="n">simplify</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">sort</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_eigenvects</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="n">default_sort_key</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_eigenvects</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>
            <span class="n">diagvals</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">P</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_new</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">[])</span>
            <span class="k">for</span> <span class="n">eigenval</span><span class="p">,</span> <span class="n">multiplicity</span><span class="p">,</span> <span class="n">vects</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_eigenvects</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">multiplicity</span><span class="p">):</span>
                    <span class="n">diagvals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">eigenval</span><span class="p">)</span>
                    <span class="n">vec</span> <span class="o">=</span> <span class="n">vects</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">normalize</span><span class="p">:</span>
                        <span class="n">vec</span> <span class="o">=</span> <span class="n">vec</span> <span class="o">/</span> <span class="n">vec</span><span class="o">.</span><span class="n">norm</span><span class="p">()</span>
                    <span class="n">P</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">col_insert</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">cols</span><span class="p">,</span> <span class="n">vec</span><span class="p">)</span>
            <span class="n">D</span> <span class="o">=</span> <span class="n">diag</span><span class="p">(</span><span class="o">*</span><span class="n">diagvals</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_diagonalize_clear_subproducts</span><span class="p">()</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">D</span><span class="p">)</span></div>

<div class="viewcode-block" id="MatrixBase.is_diagonalizable"><a class="viewcode-back" href="../../../modules/matrices/matrices.html#sympy.matrices.immutable.MatrixBase.is_diagonalizable">[docs]</a>    <span class="k">def</span> <span class="nf">is_diagonalizable</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reals_only</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">clear_subproducts</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Check if matrix is diagonalizable.</span>

<span class="sd">        If reals_only==True then check that diagonalized matrix consists of the only not complex values.</span>

<span class="sd">        Some subproducts could be used further in other methods to avoid double calculations,</span>
<span class="sd">        By default (if clear_subproducts==True) they will be deleted.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy import Matrix</span>
<span class="sd">        &gt;&gt;&gt; m = Matrix(3, 3, [1, 2, 0, 0, 3, 0, 2, -4, 2])</span>
<span class="sd">        &gt;&gt;&gt; m</span>
<span class="sd">        Matrix([</span>
<span class="sd">        [1,  2, 0],</span>
<span class="sd">        [0,  3, 0],</span>
<span class="sd">        [2, -4, 2]])</span>
<span class="sd">        &gt;&gt;&gt; m.is_diagonalizable()</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; m = Matrix(2, 2, [0, 1, 0, 0])</span>
<span class="sd">        &gt;&gt;&gt; m</span>
<span class="sd">        Matrix([</span>
<span class="sd">        [0, 1],</span>
<span class="sd">        [0, 0]])</span>
<span class="sd">        &gt;&gt;&gt; m.is_diagonalizable()</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; m = Matrix(2, 2, [0, 1, -1, 0])</span>
<span class="sd">        &gt;&gt;&gt; m</span>
<span class="sd">        Matrix([</span>
<span class="sd">        [ 0, 1],</span>
<span class="sd">        [-1, 0]])</span>
<span class="sd">        &gt;&gt;&gt; m.is_diagonalizable()</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; m.is_diagonalizable(True)</span>
<span class="sd">        False</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        is_diagonal</span>
<span class="sd">        diagonalize</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_square</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span>
        <span class="n">res</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_is_symbolic</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_symbolic</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_is_symmetric</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_symmetric</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_eigenvects</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_eigenvects</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eigenvects</span><span class="p">(</span><span class="n">simplify</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="n">all_iscorrect</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">for</span> <span class="n">eigenval</span><span class="p">,</span> <span class="n">multiplicity</span><span class="p">,</span> <span class="n">vects</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_eigenvects</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">vects</span><span class="p">)</span> <span class="o">!=</span> <span class="n">multiplicity</span><span class="p">:</span>
                <span class="n">all_iscorrect</span> <span class="o">=</span> <span class="bp">False</span>
                <span class="k">break</span>
            <span class="k">elif</span> <span class="n">reals_only</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">eigenval</span><span class="o">.</span><span class="n">is_real</span><span class="p">:</span>
                <span class="n">all_iscorrect</span> <span class="o">=</span> <span class="bp">False</span>
                <span class="k">break</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">all_iscorrect</span>
        <span class="k">if</span> <span class="n">clear_subproducts</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_diagonalize_clear_subproducts</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">res</span></div>

    <span class="k">def</span> <span class="nf">_diagonalize_clear_subproducts</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_symbolic</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_symmetric</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_eigenvects</span>

    <span class="k">def</span> <span class="nf">jordan_cell</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">eigenval</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
        <span class="kn">from</span> <span class="nn">sympy.matrices</span> <span class="kn">import</span> <span class="n">MutableMatrix</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">MutableMatrix</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">out</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">eigenval</span>
            <span class="n">out</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">out</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">eigenval</span>
        <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)(</span><span class="n">out</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_jordan_block_structure</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># To every eigenvalue may belong `i` blocks with size s(i)</span>
        <span class="c1"># and a chain of generalized eigenvectors</span>
        <span class="c1"># which will be determined by the following computations:</span>
        <span class="c1"># for every eigenvalue we will add a dictionary</span>
        <span class="c1"># containing, for all blocks, the blocksizes and the attached chain vectors</span>
        <span class="c1"># that will eventually be used to form the transformation P</span>
        <span class="n">jordan_block_structures</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">_eigenvects</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eigenvects</span><span class="p">()</span>
        <span class="n">ev</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eigenvals</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ev</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;could not compute the eigenvalues&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">eigenval</span><span class="p">,</span> <span class="n">multiplicity</span><span class="p">,</span> <span class="n">vects</span> <span class="ow">in</span> <span class="n">_eigenvects</span><span class="p">:</span>
            <span class="n">l_jordan_chains</span><span class="o">=</span><span class="p">{}</span>
            <span class="n">geometrical</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">vects</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">geometrical</span> <span class="o">==</span> <span class="n">multiplicity</span><span class="p">:</span>
                <span class="c1"># The Jordan chains have all length 1 and consist of only one vector</span>
                <span class="c1"># which is the eigenvector of course</span>
                <span class="n">chains</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">vects</span><span class="p">:</span>
                    <span class="n">chain</span><span class="o">=</span><span class="p">[</span><span class="n">v</span><span class="p">]</span>
                    <span class="n">chains</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">chain</span><span class="p">)</span>
                <span class="n">l_jordan_chains</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">chains</span>
                <span class="n">jordan_block_structures</span><span class="p">[</span><span class="n">eigenval</span><span class="p">]</span> <span class="o">=</span> <span class="n">l_jordan_chains</span>
            <span class="k">elif</span> <span class="n">geometrical</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">MatrixError</span><span class="p">(</span><span class="s2">&quot;Matrix has the eigen vector with geometrical multiplicity equal zero.&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Up to now we know nothing about the sizes of the blocks of our Jordan matrix.</span>
                <span class="c1"># Note that knowledge of algebraic and geometrical multiplicity</span>
                <span class="c1"># will *NOT* be sufficient to determine this structure.</span>
                <span class="c1"># The blocksize `s` could be defined as the minimal `k` where</span>
                <span class="c1"># `kernel(self-lI)^k = kernel(self-lI)^(k+1)`</span>
                <span class="c1"># The extreme case would be that k = (multiplicity-geometrical+1)</span>
                <span class="c1"># but the blocks could be smaller.</span>

                <span class="c1"># Consider for instance the following matrix</span>

                <span class="c1"># [2 1 0 0]</span>
                <span class="c1"># [0 2 1 0]</span>
                <span class="c1"># [0 0 2 0]</span>
                <span class="c1"># [0 0 0 2]</span>

                <span class="c1"># which coincides with it own Jordan canonical form.</span>
                <span class="c1"># It has only one eigenvalue l=2 of (algebraic) multiplicity=4.</span>
                <span class="c1"># It has two eigenvectors, one belonging to the last row (blocksize 1)</span>
                <span class="c1"># and one being the last part of a jordan chain of length 3 (blocksize of the first block).</span>

                <span class="c1"># Note again that it is not not possible to obtain this from the algebraic and geometrical</span>
                <span class="c1"># multiplicity alone. This only gives us an upper limit for the dimension of one of</span>
                <span class="c1"># the subspaces (blocksize of according jordan block) given by</span>
                <span class="c1"># max=(multiplicity-geometrical+1) which is reached for our matrix</span>
                <span class="c1"># but not for</span>

                <span class="c1"># [2 1 0 0]</span>
                <span class="c1"># [0 2 0 0]</span>
                <span class="c1"># [0 0 2 1]</span>
                <span class="c1"># [0 0 0 2]</span>

                <span class="c1"># although multiplicity=4 and geometrical=2 are the same for this matrix.</span>

                <span class="kn">from</span> <span class="nn">sympy.matrices</span> <span class="kn">import</span> <span class="n">MutableMatrix</span>
                <span class="n">I</span> <span class="o">=</span> <span class="n">MutableMatrix</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="p">)</span>
                <span class="n">l</span> <span class="o">=</span> <span class="n">eigenval</span>
                <span class="n">M</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">-</span><span class="n">l</span><span class="o">*</span><span class="n">I</span><span class="p">)</span>

                <span class="c1"># We will store the matrices `(self-l*I)^k` for further computations</span>
                <span class="c1"># for convenience only we store `Ms[0]=(sefl-lI)^0=I`</span>
                <span class="c1"># so the index is the same as the power for all further Ms entries</span>
                <span class="c1"># We also store the vectors that span these kernels (Ns[0] = [])</span>
                <span class="c1"># and also their dimensions `a_s`</span>
                <span class="c1"># this is mainly done for debugging since the number of blocks of a given size</span>
                <span class="c1"># can be computed from the a_s, in order to check our result which is obtained simpler</span>
                <span class="c1"># by counting the number of Jordan chains for `a` given `s`</span>
                <span class="c1"># `a_0` is `dim(Kernel(Ms[0]) = dim (Kernel(I)) = 0` since `I` is regular</span>

                <span class="n">l_jordan_chains</span><span class="o">=</span><span class="p">{}</span>
                <span class="n">Ms</span> <span class="o">=</span> <span class="p">[</span><span class="n">I</span><span class="p">]</span>
                <span class="n">Ns</span> <span class="o">=</span> <span class="p">[[]]</span>
                <span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">smax</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">M_new</span> <span class="o">=</span> <span class="n">Ms</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">M</span>
                <span class="n">Ns_new</span> <span class="o">=</span> <span class="n">M_new</span><span class="o">.</span><span class="n">nullspace</span><span class="p">()</span>
                <span class="n">a_new</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">Ns_new</span><span class="p">)</span>
                <span class="n">Ms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">M_new</span><span class="p">)</span>
                <span class="n">Ns</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Ns_new</span><span class="p">)</span>
                <span class="k">while</span> <span class="n">a_new</span> <span class="o">&gt;</span> <span class="n">a</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>  <span class="c1"># as long as the nullspaces increase compute further powers</span>
                    <span class="n">a</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a_new</span><span class="p">)</span>
                    <span class="n">M_new</span> <span class="o">=</span> <span class="n">Ms</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">M</span>
                    <span class="n">Ns_new</span> <span class="o">=</span> <span class="n">M_new</span><span class="o">.</span><span class="n">nullspace</span><span class="p">()</span>
                    <span class="n">a_new</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">Ns_new</span><span class="p">)</span>
                    <span class="n">Ms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">M_new</span><span class="p">)</span>
                    <span class="n">Ns</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Ns_new</span><span class="p">)</span>
                    <span class="n">smax</span> <span class="o">+=</span> <span class="mi">1</span>

                <span class="c1"># We now have `Ms[-1]=((self-l*I)**s)=Z=0`.</span>
                <span class="c1"># We also know the size of the biggest Jordan block</span>
                <span class="c1"># associated with `l` to be `s`.</span>
                <span class="c1"># Now let us proceed with the computation of the associate part of the transformation matrix `P`.</span>
                <span class="c1"># We already know the kernel (=nullspace)  `K_l` of (self-lI) which consists of the</span>
                <span class="c1"># eigenvectors belonging to eigenvalue `l`.</span>
                <span class="c1"># The dimension of this space is the geometric multiplicity of eigenvalue `l`.</span>
                <span class="c1"># For every eigenvector ev out of `K_l`, there exists a subspace that is</span>
                <span class="c1"># spanned by the Jordan chain of ev. The dimension of this subspace is</span>
                <span class="c1"># represented by the length `s` of the Jordan block.</span>
                <span class="c1"># The chain itself is given by `{e_0,..,e_s-1}` where:</span>
                <span class="c1"># `e_k+1 =(self-lI)e_k (*)`</span>
                <span class="c1"># and</span>
                <span class="c1"># `e_s-1=ev`</span>
                <span class="c1"># So it would be possible to start with the already known `ev` and work backwards until one</span>
                <span class="c1"># reaches `e_0`. Unfortunately this can not be done by simply solving system (*) since its matrix</span>
                <span class="c1"># is singular (by definition of the eigenspaces).</span>
                <span class="c1"># This approach would force us a choose in every step the degree of freedom undetermined</span>
                <span class="c1"># by (*). This is difficult to implement with computer algebra systems and also quite inefficient.</span>
                <span class="c1"># We therefore reformulate the problem in terms of nullspaces.</span>
                <span class="c1"># To do so we start from the other end and choose `e0`&#39;s out of</span>
                <span class="c1"># `E=Kernel(self-lI)^s / Kernel(self-lI)^(s-1)`</span>
                <span class="c1"># Note that `Kernel(self-lI)^s = Kernel(Z) = V` (the whole vector space).</span>
                <span class="c1"># So in the first step `s=smax` this restriction turns out to actually restrict nothing at all</span>
                <span class="c1"># and the only remaining condition is to choose vectors in `Kernel(self-lI)^(s-1)`.</span>
                <span class="c1"># Subsequently we compute `e_1=(self-lI)e_0`, `e_2=(self-lI)*e_1` and so on.</span>
                <span class="c1"># The subspace `E` can have a dimension larger than one.</span>
                <span class="c1"># That means that we have more than one Jordan block of size `s` for the eigenvalue `l`</span>
                <span class="c1"># and as many Jordan chains (this is the case in the second example).</span>
                <span class="c1"># In this case we start as many Jordan chains and have as many blocks of size `s` in the jcf.</span>
                <span class="c1"># We now have all the Jordan blocks of size `s` but there might be others attached to the same</span>
                <span class="c1"># eigenvalue that are smaller.</span>
                <span class="c1"># So we will do the same procedure also for `s-1` and so on until 1 (the lowest possible order</span>
                <span class="c1"># where the Jordan chain is of length 1 and just represented by the eigenvector).</span>

                <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">smax</span><span class="o">+</span><span class="mi">1</span><span class="p">)):</span>
                    <span class="n">S</span> <span class="o">=</span> <span class="n">Ms</span><span class="p">[</span><span class="n">s</span><span class="p">]</span>
                    <span class="c1"># We want the vectors in `Kernel((self-lI)^s)`,</span>
                    <span class="c1"># but without those in `Kernel(self-lI)^s-1`</span>
                    <span class="c1"># so we will add their adjoints as additional equations</span>
                    <span class="c1"># to the system formed by `S` to get the orthogonal</span>
                    <span class="c1"># complement.</span>
                    <span class="c1"># (`S` will no longer be quadratic.)</span>

                    <span class="n">exclude_vectors</span> <span class="o">=</span> <span class="n">Ns</span><span class="p">[</span><span class="n">s</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">a</span><span class="p">[</span><span class="n">s</span><span class="o">-</span><span class="mi">1</span><span class="p">]):</span>
                        <span class="n">S</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">col_join</span><span class="p">((</span><span class="n">exclude_vectors</span><span class="p">[</span><span class="n">k</span><span class="p">])</span><span class="o">.</span><span class="n">adjoint</span><span class="p">())</span>

                    <span class="c1"># We also want to exclude the vectors</span>
                    <span class="c1"># in the chains for the bigger blocks</span>
                    <span class="c1"># that we have already computed (if there are any).</span>
                    <span class="c1"># (That is why we start with the biggest s).</span>

                    <span class="c1"># Since Jordan blocks are not orthogonal in general</span>
                    <span class="c1"># (in the original space), only those chain vectors</span>
                    <span class="c1"># that are on level s (index `s-1` in a chain)</span>
                    <span class="c1"># are added.</span>

                    <span class="k">for</span> <span class="n">chain_list</span> <span class="ow">in</span> <span class="n">l_jordan_chains</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                        <span class="k">for</span> <span class="n">chain</span> <span class="ow">in</span> <span class="n">chain_list</span><span class="p">:</span>
                            <span class="n">S</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">col_join</span><span class="p">(</span><span class="n">chain</span><span class="p">[</span><span class="n">s</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">adjoint</span><span class="p">())</span>

                    <span class="n">e0s</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">nullspace</span><span class="p">()</span>
                    <span class="c1"># Determine the number of chain leaders</span>
                    <span class="c1"># for blocks of size `s`.</span>
                    <span class="n">n_e0</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">e0s</span><span class="p">)</span>
                    <span class="n">s_chains</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="c1"># s_cells=[]</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">n_e0</span><span class="p">):</span>
                        <span class="n">chain</span><span class="o">=</span><span class="p">[</span><span class="n">e0s</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
                        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">s</span><span class="p">):</span>
                            <span class="n">v</span> <span class="o">=</span> <span class="n">M</span><span class="o">*</span><span class="n">chain</span><span class="p">[</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                            <span class="n">chain</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>

                        <span class="c1"># We want the chain leader appear as the last of the block.</span>
                        <span class="n">chain</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>
                        <span class="n">s_chains</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">chain</span><span class="p">)</span>
                    <span class="n">l_jordan_chains</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="n">s_chains</span>
            <span class="n">jordan_block_structures</span><span class="p">[</span><span class="n">eigenval</span><span class="p">]</span> <span class="o">=</span> <span class="n">l_jordan_chains</span>
        <span class="k">return</span> <span class="n">jordan_block_structures</span>

<div class="viewcode-block" id="MatrixBase.jordan_form"><a class="viewcode-back" href="../../../modules/matrices/matrices.html#sympy.matrices.immutable.MatrixBase.jordan_form">[docs]</a>    <span class="k">def</span> <span class="nf">jordan_form</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">calc_transformation</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">r&quot;&quot;&quot;Return Jordan form J of current matrix.</span>

<span class="sd">        Also the transformation P such that</span>

<span class="sd">            `J = P^{-1} \cdot M \cdot P`</span>

<span class="sd">        and the jordan blocks forming J</span>
<span class="sd">        will be calculated.</span>


<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy import Matrix</span>
<span class="sd">        &gt;&gt;&gt; m = Matrix([</span>
<span class="sd">        ...        [ 6,  5, -2, -3],</span>
<span class="sd">        ...        [-3, -1,  3,  3],</span>
<span class="sd">        ...        [ 2,  1, -2, -3],</span>
<span class="sd">        ...        [-1,  1,  5,  5]])</span>
<span class="sd">        &gt;&gt;&gt; P, J = m.jordan_form()</span>
<span class="sd">        &gt;&gt;&gt; J</span>
<span class="sd">        Matrix([</span>
<span class="sd">        [2, 1, 0, 0],</span>
<span class="sd">        [0, 2, 0, 0],</span>
<span class="sd">        [0, 0, 2, 1],</span>
<span class="sd">        [0, 0, 0, 2]])</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        jordan_cells</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">P</span><span class="p">,</span> <span class="n">Jcells</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">jordan_cells</span><span class="p">()</span>
        <span class="kn">from</span> <span class="nn">sympy.matrices</span> <span class="kn">import</span> <span class="n">diag</span>
        <span class="n">J</span> <span class="o">=</span> <span class="n">diag</span><span class="p">(</span><span class="o">*</span><span class="n">Jcells</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">P</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)(</span><span class="n">J</span><span class="p">)</span></div>

<div class="viewcode-block" id="MatrixBase.jordan_cells"><a class="viewcode-back" href="../../../modules/matrices/matrices.html#sympy.matrices.immutable.MatrixBase.jordan_cells">[docs]</a>    <span class="k">def</span> <span class="nf">jordan_cells</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">calc_transformation</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">r&quot;&quot;&quot;Return a list of Jordan cells of current matrix.</span>
<span class="sd">        This list shape Jordan matrix J.</span>

<span class="sd">        If calc_transformation is specified as False, then transformation P such that</span>

<span class="sd">              `J = P^{-1} \cdot M \cdot P`</span>

<span class="sd">        will not be calculated.</span>

<span class="sd">        Notes</span>
<span class="sd">        =====</span>

<span class="sd">        Calculation of transformation P is not implemented yet.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy import Matrix</span>
<span class="sd">        &gt;&gt;&gt; m = Matrix(4, 4, [</span>
<span class="sd">        ...  6,  5, -2, -3,</span>
<span class="sd">        ... -3, -1,  3,  3,</span>
<span class="sd">        ...  2,  1, -2, -3,</span>
<span class="sd">        ... -1,  1,  5,  5])</span>

<span class="sd">        &gt;&gt;&gt; P, Jcells = m.jordan_cells()</span>
<span class="sd">        &gt;&gt;&gt; Jcells[0]</span>
<span class="sd">        Matrix([</span>
<span class="sd">        [2, 1],</span>
<span class="sd">        [0, 2]])</span>
<span class="sd">        &gt;&gt;&gt; Jcells[1]</span>
<span class="sd">        Matrix([</span>
<span class="sd">        [2, 1],</span>
<span class="sd">        [0, 2]])</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        jordan_form</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rows</span>
        <span class="n">Jcells</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">Pcols_new</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">jordan_block_structures</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_jordan_block_structure</span><span class="p">()</span>
        <span class="kn">from</span> <span class="nn">sympy.matrices</span> <span class="kn">import</span> <span class="n">MutableMatrix</span>

        <span class="c1"># Order according to default_sort_key, this makes sure the order is the same as in .diagonalize():</span>
        <span class="k">for</span> <span class="n">eigenval</span> <span class="ow">in</span> <span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">jordan_block_structures</span><span class="o">.</span><span class="n">keys</span><span class="p">()),</span> <span class="n">key</span><span class="o">=</span><span class="n">default_sort_key</span><span class="p">)):</span>
            <span class="n">l_jordan_chains</span> <span class="o">=</span> <span class="n">jordan_block_structures</span><span class="p">[</span><span class="n">eigenval</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="nb">sorted</span><span class="p">((</span><span class="n">l_jordan_chains</span><span class="p">)</span><span class="o">.</span><span class="n">keys</span><span class="p">())):</span>  <span class="c1"># Start with the biggest block</span>
                <span class="n">s_chains</span> <span class="o">=</span> <span class="n">l_jordan_chains</span><span class="p">[</span><span class="n">s</span><span class="p">]</span>
                <span class="n">block</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">jordan_cell</span><span class="p">(</span><span class="n">eigenval</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
                <span class="n">number_of_s_chains</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">s_chains</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">number_of_s_chains</span><span class="p">):</span>
                    <span class="n">Jcells</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)(</span><span class="n">block</span><span class="p">))</span>
                    <span class="n">chain_vectors</span> <span class="o">=</span> <span class="n">s_chains</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                    <span class="n">lc</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">chain_vectors</span><span class="p">)</span>
                    <span class="k">assert</span> <span class="n">lc</span> <span class="o">==</span> <span class="n">s</span>
                    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">lc</span><span class="p">):</span>
                        <span class="n">generalized_eigen_vector</span> <span class="o">=</span> <span class="n">chain_vectors</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                        <span class="n">Pcols_new</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">generalized_eigen_vector</span><span class="p">)</span>
        <span class="n">P</span> <span class="o">=</span> <span class="n">MutableMatrix</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
            <span class="n">P</span><span class="p">[:,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">Pcols_new</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>

        <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)(</span><span class="n">P</span><span class="p">),</span> <span class="n">Jcells</span></div>

    <span class="k">def</span> <span class="nf">_jordan_split</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">algebraical</span><span class="p">,</span> <span class="n">geometrical</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a list of integers with sum equal to &#39;algebraical&#39;</span>
<span class="sd">        and length equal to &#39;geometrical&#39;&quot;&quot;&quot;</span>
        <span class="n">n1</span> <span class="o">=</span> <span class="n">algebraical</span> <span class="o">//</span> <span class="n">geometrical</span>
        <span class="n">res</span> <span class="o">=</span> <span class="p">[</span><span class="n">n1</span><span class="p">]</span><span class="o">*</span><span class="n">geometrical</span>
        <span class="n">res</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">res</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="n">algebraical</span> <span class="o">%</span> <span class="n">geometrical</span>
        <span class="k">assert</span> <span class="nb">sum</span><span class="p">(</span><span class="n">res</span><span class="p">)</span> <span class="o">==</span> <span class="n">algebraical</span>
        <span class="k">return</span> <span class="n">res</span>

<div class="viewcode-block" id="MatrixBase.has"><a class="viewcode-back" href="../../../modules/matrices/matrices.html#sympy.matrices.immutable.MatrixBase.has">[docs]</a>    <span class="k">def</span> <span class="nf">has</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">patterns</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Test whether any subexpression matches any of the patterns.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy import Matrix, Float</span>
<span class="sd">        &gt;&gt;&gt; from sympy.abc import x, y</span>
<span class="sd">        &gt;&gt;&gt; A = Matrix(((1, x), (0.2, 3)))</span>
<span class="sd">        &gt;&gt;&gt; A.has(x)</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; A.has(y)</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; A.has(Float)</span>
<span class="sd">        True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">any</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="o">*</span><span class="n">patterns</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mat</span><span class="p">)</span></div>

<div class="viewcode-block" id="MatrixBase.dual"><a class="viewcode-back" href="../../../modules/matrices/matrices.html#sympy.matrices.immutable.MatrixBase.dual">[docs]</a>    <span class="k">def</span> <span class="nf">dual</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the dual of a matrix, which is:</span>

<span class="sd">        `(1/2)*levicivita(i, j, k, l)*M(k, l)` summed over indices `k` and `l`</span>

<span class="sd">        Since the levicivita method is anti_symmetric for any pairwise</span>
<span class="sd">        exchange of indices, the dual of a symmetric matrix is the zero</span>
<span class="sd">        matrix. Strictly speaking the dual defined here assumes that the</span>
<span class="sd">        &#39;matrix&#39; `M` is a contravariant anti_symmetric second rank tensor,</span>
<span class="sd">        so that the dual is a covariant second rank tensor.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">LeviCivita</span>
        <span class="kn">from</span> <span class="nn">sympy.matrices</span> <span class="kn">import</span> <span class="n">zeros</span>

        <span class="n">M</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[:,</span> <span class="p">:],</span> <span class="bp">self</span><span class="o">.</span><span class="n">rows</span>
        <span class="n">work</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_symmetric</span><span class="p">():</span>
            <span class="k">return</span> <span class="n">work</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
                <span class="n">acum</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
                    <span class="n">acum</span> <span class="o">+=</span> <span class="n">LeviCivita</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span><span class="o">*</span><span class="n">M</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span>
                <span class="n">work</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">acum</span>
                <span class="n">work</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">acum</span>

        <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
            <span class="n">acum</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
                    <span class="n">acum</span> <span class="o">+=</span> <span class="n">LeviCivita</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span><span class="o">*</span><span class="n">M</span><span class="p">[</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">]</span>
            <span class="n">acum</span> <span class="o">/=</span> <span class="mi">2</span>
            <span class="n">work</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">l</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">acum</span>
            <span class="n">work</span><span class="p">[</span><span class="n">l</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">acum</span>

        <span class="k">return</span> <span class="n">work</span></div>

    <span class="nd">@classmethod</span>
<div class="viewcode-block" id="MatrixBase.hstack"><a class="viewcode-back" href="../../../modules/matrices/matrices.html#sympy.matrices.immutable.MatrixBase.hstack">[docs]</a>    <span class="k">def</span> <span class="nf">hstack</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a matrix formed by joining args horizontally (i.e.</span>
<span class="sd">        by repeated application of row_join).</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.matrices import Matrix, eye</span>
<span class="sd">        &gt;&gt;&gt; Matrix.hstack(eye(2), 2*eye(2))</span>
<span class="sd">        Matrix([</span>
<span class="sd">        [1, 0, 2, 0],</span>
<span class="sd">        [0, 1, 0, 2]])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">reduce</span><span class="p">(</span><span class="n">cls</span><span class="o">.</span><span class="n">row_join</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>

    <span class="nd">@classmethod</span>
<div class="viewcode-block" id="MatrixBase.vstack"><a class="viewcode-back" href="../../../modules/matrices/matrices.html#sympy.matrices.immutable.MatrixBase.vstack">[docs]</a>    <span class="k">def</span> <span class="nf">vstack</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a matrix formed by joining args vertically (i.e.</span>
<span class="sd">        by repeated application of col_join).</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.matrices import Matrix, eye</span>
<span class="sd">        &gt;&gt;&gt; Matrix.vstack(eye(2), 2*eye(2))</span>
<span class="sd">        Matrix([</span>
<span class="sd">        [1, 0],</span>
<span class="sd">        [0, 1],</span>
<span class="sd">        [2, 0],</span>
<span class="sd">        [0, 2]])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">reduce</span><span class="p">(</span><span class="n">cls</span><span class="o">.</span><span class="n">col_join</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span></div>

<div class="viewcode-block" id="MatrixBase.row_join"><a class="viewcode-back" href="../../../modules/matrices/matrices.html#sympy.matrices.immutable.MatrixBase.row_join">[docs]</a>    <span class="k">def</span> <span class="nf">row_join</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rhs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Concatenates two matrices along self&#39;s last and rhs&#39;s first column</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy import zeros, ones</span>
<span class="sd">        &gt;&gt;&gt; M = zeros(3)</span>
<span class="sd">        &gt;&gt;&gt; V = ones(3, 1)</span>
<span class="sd">        &gt;&gt;&gt; M.row_join(V)</span>
<span class="sd">        Matrix([</span>
<span class="sd">        [0, 0, 0, 1],</span>
<span class="sd">        [0, 0, 0, 1],</span>
<span class="sd">        [0, 0, 0, 1]])</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        row</span>
<span class="sd">        col_join</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">sympy.matrices</span> <span class="kn">import</span> <span class="n">MutableMatrix</span>
        <span class="c1"># Allows you to build a matrix even if it is null matrix</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)(</span><span class="n">rhs</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">rows</span> <span class="o">!=</span> <span class="n">rhs</span><span class="o">.</span><span class="n">rows</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ShapeError</span><span class="p">(</span>
                <span class="s2">&quot;`self` and `rhs` must have the same number of rows.&quot;</span><span class="p">)</span>
        <span class="n">newmat</span> <span class="o">=</span> <span class="n">MutableMatrix</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span> <span class="o">+</span> <span class="n">rhs</span><span class="o">.</span><span class="n">cols</span><span class="p">)</span>
        <span class="n">newmat</span><span class="p">[:,</span> <span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="n">newmat</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">:]</span> <span class="o">=</span> <span class="n">rhs</span>
        <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)(</span><span class="n">newmat</span><span class="p">)</span></div>

<div class="viewcode-block" id="MatrixBase.col_join"><a class="viewcode-back" href="../../../modules/matrices/matrices.html#sympy.matrices.immutable.MatrixBase.col_join">[docs]</a>    <span class="k">def</span> <span class="nf">col_join</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bott</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Concatenates two matrices along self&#39;s last and bott&#39;s first row</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy import zeros, ones</span>
<span class="sd">        &gt;&gt;&gt; M = zeros(3)</span>
<span class="sd">        &gt;&gt;&gt; V = ones(1, 3)</span>
<span class="sd">        &gt;&gt;&gt; M.col_join(V)</span>
<span class="sd">        Matrix([</span>
<span class="sd">        [0, 0, 0],</span>
<span class="sd">        [0, 0, 0],</span>
<span class="sd">        [0, 0, 0],</span>
<span class="sd">        [1, 1, 1]])</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        col</span>
<span class="sd">        row_join</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">sympy.matrices</span> <span class="kn">import</span> <span class="n">MutableMatrix</span>
        <span class="c1"># Allows you to build a matrix even if it is null matrix</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)(</span><span class="n">bott</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span> <span class="o">!=</span> <span class="n">bott</span><span class="o">.</span><span class="n">cols</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ShapeError</span><span class="p">(</span>
                <span class="s2">&quot;`self` and `bott` must have the same number of columns.&quot;</span><span class="p">)</span>
        <span class="n">newmat</span> <span class="o">=</span> <span class="n">MutableMatrix</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rows</span> <span class="o">+</span> <span class="n">bott</span><span class="o">.</span><span class="n">rows</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">)</span>
        <span class="n">newmat</span><span class="p">[:</span><span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="n">newmat</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">bott</span>
        <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)(</span><span class="n">newmat</span><span class="p">)</span></div>

<div class="viewcode-block" id="MatrixBase.row_insert"><a class="viewcode-back" href="../../../modules/matrices/matrices.html#sympy.matrices.immutable.MatrixBase.row_insert">[docs]</a>    <span class="k">def</span> <span class="nf">row_insert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">mti</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Insert one or more rows at the given row position.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy import zeros, ones</span>
<span class="sd">        &gt;&gt;&gt; M = zeros(3)</span>
<span class="sd">        &gt;&gt;&gt; V = ones(1, 3)</span>
<span class="sd">        &gt;&gt;&gt; M.row_insert(1, V)</span>
<span class="sd">        Matrix([</span>
<span class="sd">        [0, 0, 0],</span>
<span class="sd">        [1, 1, 1],</span>
<span class="sd">        [0, 0, 0],</span>
<span class="sd">        [0, 0, 0]])</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        row</span>
<span class="sd">        col_insert</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">sympy.matrices</span> <span class="kn">import</span> <span class="n">MutableMatrix</span>
        <span class="c1"># Allows you to build a matrix even if it is null matrix</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)(</span><span class="n">mti</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">pos</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">mti</span><span class="o">.</span><span class="n">col_join</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">pos</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rows</span> <span class="o">+</span> <span class="n">pos</span>
        <span class="k">if</span> <span class="n">pos</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">pos</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">elif</span> <span class="n">pos</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="p">:</span>
            <span class="n">pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rows</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span> <span class="o">!=</span> <span class="n">mti</span><span class="o">.</span><span class="n">cols</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ShapeError</span><span class="p">(</span>
                <span class="s2">&quot;`self` and `mti` must have the same number of columns.&quot;</span><span class="p">)</span>

        <span class="n">newmat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rows</span> <span class="o">+</span> <span class="n">mti</span><span class="o">.</span><span class="n">rows</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">)</span>
        <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">pos</span><span class="p">,</span> <span class="n">pos</span> <span class="o">+</span> <span class="n">mti</span><span class="o">.</span><span class="n">rows</span>
        <span class="n">newmat</span><span class="p">[:</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[:</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">newmat</span><span class="p">[</span><span class="n">i</span><span class="p">:</span> <span class="n">j</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">mti</span>
        <span class="n">newmat</span><span class="p">[</span><span class="n">j</span><span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">:,</span> <span class="p">:]</span>
        <span class="k">return</span> <span class="n">newmat</span></div>

<div class="viewcode-block" id="MatrixBase.col_insert"><a class="viewcode-back" href="../../../modules/matrices/matrices.html#sympy.matrices.immutable.MatrixBase.col_insert">[docs]</a>    <span class="k">def</span> <span class="nf">col_insert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">mti</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Insert one or more columns at the given column position.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy import zeros, ones</span>
<span class="sd">        &gt;&gt;&gt; M = zeros(3)</span>
<span class="sd">        &gt;&gt;&gt; V = ones(3, 1)</span>
<span class="sd">        &gt;&gt;&gt; M.col_insert(1, V)</span>
<span class="sd">        Matrix([</span>
<span class="sd">        [0, 1, 0, 0],</span>
<span class="sd">        [0, 1, 0, 0],</span>
<span class="sd">        [0, 1, 0, 0]])</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        col</span>
<span class="sd">        row_insert</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">sympy.matrices</span> <span class="kn">import</span> <span class="n">MutableMatrix</span>
        <span class="c1"># Allows you to build a matrix even if it is null matrix</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)(</span><span class="n">mti</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">pos</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">mti</span><span class="o">.</span><span class="n">row_join</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">pos</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span> <span class="o">+</span> <span class="n">pos</span>
        <span class="k">if</span> <span class="n">pos</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">pos</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">elif</span> <span class="n">pos</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">:</span>
            <span class="n">pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">rows</span> <span class="o">!=</span> <span class="n">mti</span><span class="o">.</span><span class="n">rows</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ShapeError</span><span class="p">(</span><span class="s2">&quot;self and mti must have the same number of rows.&quot;</span><span class="p">)</span>

        <span class="n">newmat</span> <span class="o">=</span> <span class="n">MutableMatrix</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span> <span class="o">+</span> <span class="n">mti</span><span class="o">.</span><span class="n">cols</span><span class="p">)</span>
        <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">pos</span><span class="p">,</span> <span class="n">pos</span> <span class="o">+</span> <span class="n">mti</span><span class="o">.</span><span class="n">cols</span>
        <span class="n">newmat</span><span class="p">[:,</span> <span class="p">:</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[:,</span> <span class="p">:</span><span class="n">i</span><span class="p">]</span>
        <span class="n">newmat</span><span class="p">[:,</span> <span class="n">i</span><span class="p">:</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">mti</span>
        <span class="n">newmat</span><span class="p">[:,</span> <span class="n">j</span><span class="p">:]</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[:,</span> <span class="n">i</span><span class="p">:]</span>
        <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)(</span><span class="n">newmat</span><span class="p">)</span></div>

<div class="viewcode-block" id="MatrixBase.replace"><a class="viewcode-back" href="../../../modules/matrices/matrices.html#sympy.matrices.immutable.MatrixBase.replace">[docs]</a>    <span class="k">def</span> <span class="nf">replace</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">F</span><span class="p">,</span> <span class="n">G</span><span class="p">,</span> <span class="nb">map</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Replaces Function F in Matrix entries with Function G.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy import symbols, Function, Matrix</span>
<span class="sd">        &gt;&gt;&gt; F, G = symbols(&#39;F, G&#39;, cls=Function)</span>
<span class="sd">        &gt;&gt;&gt; M = Matrix(2, 2, lambda i, j: F(i+j)) ; M</span>
<span class="sd">        Matrix([</span>
<span class="sd">        [F(0), F(1)],</span>
<span class="sd">        [F(1), F(2)]])</span>
<span class="sd">        &gt;&gt;&gt; N = M.replace(F,G)</span>
<span class="sd">        &gt;&gt;&gt; N</span>
<span class="sd">        Matrix([</span>
<span class="sd">        [G(0), G(1)],</span>
<span class="sd">        [G(1), G(2)]])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">M</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[:,</span> <span class="p">:]</span>

        <span class="k">return</span> <span class="n">M</span><span class="o">.</span><span class="n">applyfunc</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="n">G</span><span class="p">,</span> <span class="nb">map</span><span class="p">))</span></div>

<div class="viewcode-block" id="MatrixBase.pinv"><a class="viewcode-back" href="../../../modules/matrices/matrices.html#sympy.matrices.immutable.MatrixBase.pinv">[docs]</a>    <span class="k">def</span> <span class="nf">pinv</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate the Moore-Penrose pseudoinverse of the matrix.</span>

<span class="sd">        The Moore-Penrose pseudoinverse exists and is unique for any matrix.</span>
<span class="sd">        If the matrix is invertible, the pseudoinverse is the same as the</span>
<span class="sd">        inverse.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy import Matrix</span>
<span class="sd">        &gt;&gt;&gt; Matrix([[1, 2, 3], [4, 5, 6]]).pinv()</span>
<span class="sd">        Matrix([</span>
<span class="sd">        [-17/18,  4/9],</span>
<span class="sd">        [  -1/9,  1/9],</span>
<span class="sd">        [ 13/18, -2/9]])</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        inv</span>
<span class="sd">        pinv_solve</span>

<span class="sd">        References</span>
<span class="sd">        ==========</span>

<span class="sd">        .. [1] https://en.wikipedia.org/wiki/Moore-Penrose_pseudoinverse</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">A</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="n">AH</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">H</span>
        <span class="c1"># Trivial case: pseudoinverse of all-zero matrix is its transpose.</span>
        <span class="k">if</span> <span class="n">A</span><span class="o">.</span><span class="n">is_zero</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">AH</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">rows</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">(</span><span class="n">AH</span> <span class="o">*</span> <span class="n">A</span><span class="p">)</span><span class="o">.</span><span class="n">inv</span><span class="p">()</span> <span class="o">*</span> <span class="n">AH</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">AH</span> <span class="o">*</span> <span class="p">(</span><span class="n">A</span> <span class="o">*</span> <span class="n">AH</span><span class="p">)</span><span class="o">.</span><span class="n">inv</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="c1"># Matrix is not full rank, so A*AH cannot be inverted.</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;Rank-deficient matrices are not yet &#39;</span>
                                      <span class="s1">&#39;supported.&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="MatrixBase.pinv_solve"><a class="viewcode-back" href="../../../modules/matrices/matrices.html#sympy.matrices.immutable.MatrixBase.pinv_solve">[docs]</a>    <span class="k">def</span> <span class="nf">pinv_solve</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">arbitrary_matrix</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Solve Ax = B using the Moore-Penrose pseudoinverse.</span>

<span class="sd">        There may be zero, one, or infinite solutions.  If one solution</span>
<span class="sd">        exists, it will be returned.  If infinite solutions exist, one will</span>
<span class="sd">        be returned based on the value of arbitrary_matrix.  If no solutions</span>
<span class="sd">        exist, the least-squares solution is returned.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ==========</span>

<span class="sd">        B : Matrix</span>
<span class="sd">            The right hand side of the equation to be solved for.  Must have</span>
<span class="sd">            the same number of rows as matrix A.</span>
<span class="sd">        arbitrary_matrix : Matrix</span>
<span class="sd">            If the system is underdetermined (e.g. A has more columns than</span>
<span class="sd">            rows), infinite solutions are possible, in terms of an arbitrary</span>
<span class="sd">            matrix.  This parameter may be set to a specific matrix to use</span>
<span class="sd">            for that purpose; if so, it must be the same shape as x, with as</span>
<span class="sd">            many rows as matrix A has columns, and as many columns as matrix</span>
<span class="sd">            B.  If left as None, an appropriate matrix containing dummy</span>
<span class="sd">            symbols in the form of ``wn_m`` will be used, with n and m being</span>
<span class="sd">            row and column position of each symbol.</span>

<span class="sd">        Returns</span>
<span class="sd">        =======</span>

<span class="sd">        x : Matrix</span>
<span class="sd">            The matrix that will satisfy Ax = B.  Will have as many rows as</span>
<span class="sd">            matrix A has columns, and as many columns as matrix B.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy import Matrix</span>
<span class="sd">        &gt;&gt;&gt; A = Matrix([[1, 2, 3], [4, 5, 6]])</span>
<span class="sd">        &gt;&gt;&gt; B = Matrix([7, 8])</span>
<span class="sd">        &gt;&gt;&gt; A.pinv_solve(B)</span>
<span class="sd">        Matrix([</span>
<span class="sd">        [ _w0_0/6 - _w1_0/3 + _w2_0/6 - 55/18],</span>
<span class="sd">        [-_w0_0/3 + 2*_w1_0/3 - _w2_0/3 + 1/9],</span>
<span class="sd">        [ _w0_0/6 - _w1_0/3 + _w2_0/6 + 59/18]])</span>
<span class="sd">        &gt;&gt;&gt; A.pinv_solve(B, arbitrary_matrix=Matrix([0, 0, 0]))</span>
<span class="sd">        Matrix([</span>
<span class="sd">        [-55/18],</span>
<span class="sd">        [   1/9],</span>
<span class="sd">        [ 59/18]])</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        lower_triangular_solve</span>
<span class="sd">        upper_triangular_solve</span>
<span class="sd">        gauss_jordan_solve</span>
<span class="sd">        cholesky_solve</span>
<span class="sd">        diagonal_solve</span>
<span class="sd">        LDLsolve</span>
<span class="sd">        LUsolve</span>
<span class="sd">        QRsolve</span>
<span class="sd">        pinv</span>

<span class="sd">        Notes</span>
<span class="sd">        =====</span>

<span class="sd">        This may return either exact solutions or least squares solutions.</span>
<span class="sd">        To determine which, check ``A * A.pinv() * B == B``.  It will be</span>
<span class="sd">        True if exact solutions exist, and False if only a least-squares</span>
<span class="sd">        solution exists.  Be aware that the left hand side of that equation</span>
<span class="sd">        may need to be simplified to correctly compare to the right hand</span>
<span class="sd">        side.</span>

<span class="sd">        References</span>
<span class="sd">        ==========</span>

<span class="sd">        .. [1] https://en.wikipedia.org/wiki/Moore-Penrose_pseudoinverse#Obtaining_all_solutions_of_a_linear_system</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">sympy.matrices</span> <span class="kn">import</span> <span class="n">eye</span>
        <span class="n">A</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="n">A_pinv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pinv</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">arbitrary_matrix</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">rows</span><span class="p">,</span> <span class="n">cols</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">cols</span><span class="p">,</span> <span class="n">B</span><span class="o">.</span><span class="n">cols</span>
            <span class="n">w</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;w:{0}_:{1}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">),</span> <span class="n">cls</span><span class="o">=</span><span class="n">Dummy</span><span class="p">)</span>
            <span class="n">arbitrary_matrix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="p">(</span><span class="n">cols</span><span class="p">,</span> <span class="n">rows</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
        <span class="k">return</span> <span class="n">A_pinv</span> <span class="o">*</span> <span class="n">B</span> <span class="o">+</span> <span class="p">(</span><span class="n">eye</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">cols</span><span class="p">)</span> <span class="o">-</span> <span class="n">A_pinv</span><span class="o">*</span><span class="n">A</span><span class="p">)</span> <span class="o">*</span> <span class="n">arbitrary_matrix</span></div>

<div class="viewcode-block" id="MatrixBase.gauss_jordan_solve"><a class="viewcode-back" href="../../../modules/matrices/matrices.html#sympy.matrices.immutable.MatrixBase.gauss_jordan_solve">[docs]</a>    <span class="k">def</span> <span class="nf">gauss_jordan_solve</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">freevar</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Solves Ax = b using Gauss Jordan elimination.</span>

<span class="sd">        There may be zero, one, or infinite solutions.  If one solution</span>
<span class="sd">        exists, it will be returned. If infinite solutions exist, it will</span>
<span class="sd">        be returned parametrically. If no solutions exist, It will throw</span>
<span class="sd">        ValueError.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ==========</span>

<span class="sd">        b : Matrix</span>
<span class="sd">            The right hand side of the equation to be solved for.  Must have</span>
<span class="sd">            the same number of rows as matrix A.</span>

<span class="sd">        freevar : List</span>
<span class="sd">            If the system is underdetermined (e.g. A has more columns than</span>
<span class="sd">            rows), infinite solutions are possible, in terms of an arbitrary</span>
<span class="sd">            values of free variables. Then the index of the free variables</span>
<span class="sd">            in the solutions (column Matrix) will be returned by freevar, if</span>
<span class="sd">            the flag `freevar` is set to `True`.</span>

<span class="sd">        Returns</span>
<span class="sd">        =======</span>

<span class="sd">        x : Matrix</span>
<span class="sd">            The matrix that will satisfy Ax = B.  Will have as many rows as</span>
<span class="sd">            matrix A has columns, and as many columns as matrix B.</span>

<span class="sd">        params : Matrix</span>
<span class="sd">            If the system is underdetermined (e.g. A has more columns than</span>
<span class="sd">            rows), infinite solutions are possible, in terms of an arbitrary</span>
<span class="sd">            parameters. These arbitrary parameters are returned as params</span>
<span class="sd">            Matrix.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy import Matrix</span>
<span class="sd">        &gt;&gt;&gt; A = Matrix([[1, 2, 1, 1], [1, 2, 2, -1], [2, 4, 0, 6]])</span>
<span class="sd">        &gt;&gt;&gt; b = Matrix([7, 12, 4])</span>
<span class="sd">        &gt;&gt;&gt; sol, params = A.gauss_jordan_solve(b)</span>
<span class="sd">        &gt;&gt;&gt; sol</span>
<span class="sd">        Matrix([</span>
<span class="sd">        [-2*_tau0 - 3*_tau1 + 2],</span>
<span class="sd">        [                 _tau0],</span>
<span class="sd">        [           2*_tau1 + 5],</span>
<span class="sd">        [                 _tau1]])</span>
<span class="sd">        &gt;&gt;&gt; params</span>
<span class="sd">        Matrix([</span>
<span class="sd">        [_tau0],</span>
<span class="sd">        [_tau1]])</span>

<span class="sd">        &gt;&gt;&gt; A = Matrix([[1, 2, 3], [4, 5, 6], [7, 8, 10]])</span>
<span class="sd">        &gt;&gt;&gt; b = Matrix([3, 6, 9])</span>
<span class="sd">        &gt;&gt;&gt; sol, params = A.gauss_jordan_solve(b)</span>
<span class="sd">        &gt;&gt;&gt; sol</span>
<span class="sd">        Matrix([</span>
<span class="sd">        [-1],</span>
<span class="sd">        [ 2],</span>
<span class="sd">        [ 0]])</span>
<span class="sd">        &gt;&gt;&gt; params</span>
<span class="sd">        Matrix(0, 1, [])</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        lower_triangular_solve</span>
<span class="sd">        upper_triangular_solve</span>
<span class="sd">        cholesky_solve</span>
<span class="sd">        diagonal_solve</span>
<span class="sd">        LDLsolve</span>
<span class="sd">        LUsolve</span>
<span class="sd">        QRsolve</span>
<span class="sd">        pinv</span>

<span class="sd">        References</span>
<span class="sd">        ==========</span>

<span class="sd">        .. [1] http://en.wikipedia.org/wiki/Gaussian_elimination</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">sympy.matrices</span> <span class="kn">import</span> <span class="n">Matrix</span><span class="p">,</span> <span class="n">zeros</span>

        <span class="n">aug</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">b</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>
        <span class="n">row</span><span class="p">,</span> <span class="n">col</span> <span class="o">=</span> <span class="n">aug</span><span class="p">[:,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span>

        <span class="c1"># solve by reduced row echelon form</span>
        <span class="n">A</span><span class="p">,</span> <span class="n">pivots</span> <span class="o">=</span> <span class="n">aug</span><span class="o">.</span><span class="n">rref</span><span class="p">(</span><span class="n">simplify</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="n">A</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="n">A</span><span class="p">[:,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">A</span><span class="p">[:,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">pivots</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">p</span><span class="p">:</span> <span class="n">p</span> <span class="o">&lt;</span> <span class="n">col</span><span class="p">,</span> <span class="n">pivots</span><span class="p">))</span>
        <span class="n">rank</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">pivots</span><span class="p">)</span>

        <span class="c1"># Bring to block form</span>
        <span class="n">permutation</span> <span class="o">=</span> <span class="n">Matrix</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">col</span><span class="p">))</span><span class="o">.</span><span class="n">T</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">permutation</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">pivots</span><span class="p">):</span>
            <span class="n">A</span><span class="o">.</span><span class="n">col_swap</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>

        <span class="n">A</span><span class="p">,</span> <span class="n">permutation</span> <span class="o">=</span> <span class="n">A</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:],</span> <span class="n">A</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span>

        <span class="c1"># check for existence of solutions</span>
        <span class="c1"># rank of aug Matrix should be equal to rank of coefficient matrix</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">v</span><span class="p">[</span><span class="n">rank</span><span class="p">:,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">is_zero</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Linear system has no solution&quot;</span><span class="p">)</span>

        <span class="c1"># Get index of free symbols (free parameters)</span>
        <span class="n">free_var_index</span> <span class="o">=</span> <span class="n">permutation</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">pivots</span><span class="p">):]</span>  <span class="c1"># non-pivots columns are free variables</span>

        <span class="c1"># Free parameters</span>
        <span class="n">dummygen</span> <span class="o">=</span> <span class="n">numbered_symbols</span><span class="p">(</span><span class="s2">&quot;tau&quot;</span><span class="p">,</span> <span class="n">Dummy</span><span class="p">)</span>
        <span class="n">tau</span> <span class="o">=</span> <span class="n">Matrix</span><span class="p">([</span><span class="nb">next</span><span class="p">(</span><span class="n">dummygen</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">col</span> <span class="o">-</span> <span class="n">rank</span><span class="p">)])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">col</span> <span class="o">-</span> <span class="n">rank</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Full parametric solution</span>
        <span class="n">V</span> <span class="o">=</span> <span class="n">A</span><span class="p">[:</span><span class="n">rank</span><span class="p">,</span> <span class="n">rank</span><span class="p">:]</span>
        <span class="n">vt</span> <span class="o">=</span> <span class="n">v</span><span class="p">[:</span><span class="n">rank</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">free_sol</span> <span class="o">=</span> <span class="n">tau</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">vt</span> <span class="o">-</span> <span class="n">V</span><span class="o">*</span><span class="n">tau</span><span class="p">,</span> <span class="n">tau</span><span class="p">)</span>

        <span class="c1"># Undo permutation</span>
        <span class="n">sol</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">free_sol</span><span class="p">):</span>
            <span class="n">sol</span><span class="p">[</span><span class="n">permutation</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>

        <span class="k">if</span> <span class="n">freevar</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">sol</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">free_var_index</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">sol</span><span class="p">,</span> <span class="n">tau</span></div></div>


<div class="viewcode-block" id="classof"><a class="viewcode-back" href="../../../modules/matrices/matrices.html#sympy.matrices.immutable.classof">[docs]</a><span class="k">def</span> <span class="nf">classof</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get the type of the result when combining matrices of different types.</span>

<span class="sd">    Currently the strategy is that immutability is contagious.</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy import Matrix, ImmutableMatrix</span>
<span class="sd">    &gt;&gt;&gt; from sympy.matrices.matrices import classof</span>
<span class="sd">    &gt;&gt;&gt; M = Matrix([[1, 2], [3, 4]]) # a Mutable Matrix</span>
<span class="sd">    &gt;&gt;&gt; IM = ImmutableMatrix([[1, 2], [3, 4]])</span>
<span class="sd">    &gt;&gt;&gt; classof(M, IM)</span>
<span class="sd">    &lt;class &#39;sympy.matrices.immutable.ImmutableMatrix&#39;&gt;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">A</span><span class="o">.</span><span class="n">_class_priority</span> <span class="o">&gt;</span> <span class="n">B</span><span class="o">.</span><span class="n">_class_priority</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">A</span><span class="o">.</span><span class="n">__class__</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">B</span><span class="o">.</span><span class="n">__class__</span>
    <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
        <span class="k">pass</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="kn">import</span> <span class="nn">numpy</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">B</span><span class="o">.</span><span class="n">__class__</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">A</span><span class="o">.</span><span class="n">__class__</span>
    <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
        <span class="k">pass</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Incompatible classes </span><span class="si">%s</span><span class="s2">, </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">__class__</span><span class="p">,</span> <span class="n">B</span><span class="o">.</span><span class="n">__class__</span><span class="p">))</span></div>


<div class="viewcode-block" id="a2idx"><a class="viewcode-back" href="../../../modules/matrices/matrices.html#sympy.matrices.immutable.a2idx">[docs]</a><span class="k">def</span> <span class="nf">a2idx</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return integer after making positive and validating against n.&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">j</span> <span class="o">=</span> <span class="n">j</span><span class="o">.</span><span class="n">__index__</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s2">&quot;Invalid index a[</span><span class="si">%r</span><span class="s2">]&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="p">))</span>
    <span class="k">if</span> <span class="n">n</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">j</span> <span class="o">+=</span> <span class="n">n</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">j</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s2">&quot;Index out of range: a[</span><span class="si">%s</span><span class="s2">]&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="p">))</span>
    <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">j</span><span class="p">)</span></div>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../../index.html">
              <img class="logo" src="../../../_static/sympylogo.png" alt="Logo"/>
            </a></p><div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../index.html">Documentation overview</a><ul>
  <li><a href="../../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2015 SymPy Development Team.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.4.1</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.7</a>
      
    </div>

    

    
  </body>
</html>