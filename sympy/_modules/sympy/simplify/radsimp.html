<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>sympy.simplify.radsimp &mdash; SymPy 1.0.1.dev documentation</title>
    
    <link rel="stylesheet" href="../../../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="http://96.sympy-live-tests.appspot.com/static/live-core.css" type="text/css" />
    <link rel="stylesheet" href="http://96.sympy-live-tests.appspot.com/static/live-autocomplete.css" type="text/css" />
    <link rel="stylesheet" href="http://96.sympy-live-tests.appspot.com/static/live-sphinx.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '1.0.1.dev',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="http://96.sympy-live-tests.appspot.com/static/utilities.js"></script>
    <script type="text/javascript" src="http://96.sympy-live-tests.appspot.com/static/external/classy.js"></script>
    <script type="text/javascript" src="http://96.sympy-live-tests.appspot.com/static/live-core.js"></script>
    <script type="text/javascript" src="http://96.sympy-live-tests.appspot.com/static/live-autocomplete.js"></script>
    <script type="text/javascript" src="http://96.sympy-live-tests.appspot.com/static/live-sphinx.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML-full"></script>
    <link rel="shortcut icon" href="../../../_static/sympy-notailtext-favicon.ico"/>
    <link rel="top" title="SymPy 1.0.1.dev documentation" href="../../../index.html" />
    <link rel="up" title="Module code" href="../../index.html" />
   
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head>
  <body role="document">  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for sympy.simplify.radsimp</h1><div class="highlight"><pre>
<span></span><span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">print_function</span><span class="p">,</span> <span class="n">division</span>

<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span>

<span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">SYMPY_DEBUG</span>

<span class="kn">from</span> <span class="nn">sympy.core.evaluate</span> <span class="kn">import</span> <span class="n">global_evaluate</span>
<span class="kn">from</span> <span class="nn">sympy.core.compatibility</span> <span class="kn">import</span> <span class="n">iterable</span><span class="p">,</span> <span class="n">ordered</span><span class="p">,</span> <span class="n">default_sort_key</span>
<span class="kn">from</span> <span class="nn">sympy.core</span> <span class="kn">import</span> <span class="n">expand_power_base</span><span class="p">,</span> <span class="n">sympify</span><span class="p">,</span> <span class="n">Add</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">Mul</span><span class="p">,</span> <span class="n">Derivative</span><span class="p">,</span> <span class="n">Pow</span><span class="p">,</span> <span class="n">symbols</span><span class="p">,</span> <span class="n">expand_mul</span>
<span class="kn">from</span> <span class="nn">sympy.core.numbers</span> <span class="kn">import</span> <span class="n">Rational</span>
<span class="kn">from</span> <span class="nn">sympy.core.exprtools</span> <span class="kn">import</span> <span class="n">Factors</span><span class="p">,</span> <span class="n">gcd_terms</span>
<span class="kn">from</span> <span class="nn">sympy.core.mul</span> <span class="kn">import</span> <span class="n">_keep_coeff</span><span class="p">,</span> <span class="n">_unevaluated_Mul</span>
<span class="kn">from</span> <span class="nn">sympy.core.function</span> <span class="kn">import</span> <span class="n">_mexpand</span>
<span class="kn">from</span> <span class="nn">sympy.core.add</span> <span class="kn">import</span> <span class="n">_unevaluated_Add</span>
<span class="kn">from</span> <span class="nn">sympy.functions</span> <span class="kn">import</span> <span class="n">exp</span><span class="p">,</span> <span class="n">sqrt</span><span class="p">,</span> <span class="n">log</span>
<span class="kn">from</span> <span class="nn">sympy.polys</span> <span class="kn">import</span> <span class="n">gcd</span>
<span class="kn">from</span> <span class="nn">sympy.simplify.sqrtdenest</span> <span class="kn">import</span> <span class="n">sqrtdenest</span>




<div class="viewcode-block" id="collect"><a class="viewcode-back" href="../../../modules/simplify/simplify.html#sympy.simplify.radsimp.collect">[docs]</a><span class="k">def</span> <span class="nf">collect</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">syms</span><span class="p">,</span> <span class="n">func</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">evaluate</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">exact</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">distribute_order_term</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Collect additive terms of an expression.</span>

<span class="sd">    This function collects additive terms of an expression with respect</span>
<span class="sd">    to a list of expression up to powers with rational exponents. By the</span>
<span class="sd">    term symbol here are meant arbitrary expressions, which can contain</span>
<span class="sd">    powers, products, sums etc. In other words symbol is a pattern which</span>
<span class="sd">    will be searched for in the expression&#39;s terms.</span>

<span class="sd">    The input expression is not expanded by :func:`collect`, so user is</span>
<span class="sd">    expected to provide an expression is an appropriate form. This makes</span>
<span class="sd">    :func:`collect` more predictable as there is no magic happening behind the</span>
<span class="sd">    scenes. However, it is important to note, that powers of products are</span>
<span class="sd">    converted to products of powers using the :func:`expand_power_base`</span>
<span class="sd">    function.</span>

<span class="sd">    There are two possible types of output. First, if ``evaluate`` flag is</span>
<span class="sd">    set, this function will return an expression with collected terms or</span>
<span class="sd">    else it will return a dictionary with expressions up to rational powers</span>
<span class="sd">    as keys and collected coefficients as values.</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy import S, collect, expand, factor, Wild</span>
<span class="sd">    &gt;&gt;&gt; from sympy.abc import a, b, c, x, y, z</span>

<span class="sd">    This function can collect symbolic coefficients in polynomials or</span>
<span class="sd">    rational expressions. It will manage to find all integer or rational</span>
<span class="sd">    powers of collection variable::</span>

<span class="sd">        &gt;&gt;&gt; collect(a*x**2 + b*x**2 + a*x - b*x + c, x)</span>
<span class="sd">        c + x**2*(a + b) + x*(a - b)</span>

<span class="sd">    The same result can be achieved in dictionary form::</span>

<span class="sd">        &gt;&gt;&gt; d = collect(a*x**2 + b*x**2 + a*x - b*x + c, x, evaluate=False)</span>
<span class="sd">        &gt;&gt;&gt; d[x**2]</span>
<span class="sd">        a + b</span>
<span class="sd">        &gt;&gt;&gt; d[x]</span>
<span class="sd">        a - b</span>
<span class="sd">        &gt;&gt;&gt; d[S.One]</span>
<span class="sd">        c</span>

<span class="sd">    You can also work with multivariate polynomials. However, remember that</span>
<span class="sd">    this function is greedy so it will care only about a single symbol at time,</span>
<span class="sd">    in specification order::</span>

<span class="sd">        &gt;&gt;&gt; collect(x**2 + y*x**2 + x*y + y + a*y, [x, y])</span>
<span class="sd">        x**2*(y + 1) + x*y + y*(a + 1)</span>

<span class="sd">    Also more complicated expressions can be used as patterns::</span>

<span class="sd">        &gt;&gt;&gt; from sympy import sin, log</span>
<span class="sd">        &gt;&gt;&gt; collect(a*sin(2*x) + b*sin(2*x), sin(2*x))</span>
<span class="sd">        (a + b)*sin(2*x)</span>

<span class="sd">        &gt;&gt;&gt; collect(a*x*log(x) + b*(x*log(x)), x*log(x))</span>
<span class="sd">        x*(a + b)*log(x)</span>

<span class="sd">    You can use wildcards in the pattern::</span>

<span class="sd">        &gt;&gt;&gt; w = Wild(&#39;w1&#39;)</span>
<span class="sd">        &gt;&gt;&gt; collect(a*x**y - b*x**y, w**y)</span>
<span class="sd">        x**y*(a - b)</span>

<span class="sd">    It is also possible to work with symbolic powers, although it has more</span>
<span class="sd">    complicated behavior, because in this case power&#39;s base and symbolic part</span>
<span class="sd">    of the exponent are treated as a single symbol::</span>

<span class="sd">        &gt;&gt;&gt; collect(a*x**c + b*x**c, x)</span>
<span class="sd">        a*x**c + b*x**c</span>
<span class="sd">        &gt;&gt;&gt; collect(a*x**c + b*x**c, x**c)</span>
<span class="sd">        x**c*(a + b)</span>

<span class="sd">    However if you incorporate rationals to the exponents, then you will get</span>
<span class="sd">    well known behavior::</span>

<span class="sd">        &gt;&gt;&gt; collect(a*x**(2*c) + b*x**(2*c), x**c)</span>
<span class="sd">        x**(2*c)*(a + b)</span>

<span class="sd">    Note also that all previously stated facts about :func:`collect` function</span>
<span class="sd">    apply to the exponential function, so you can get::</span>

<span class="sd">        &gt;&gt;&gt; from sympy import exp</span>
<span class="sd">        &gt;&gt;&gt; collect(a*exp(2*x) + b*exp(2*x), exp(x))</span>
<span class="sd">        (a + b)*exp(2*x)</span>

<span class="sd">    If you are interested only in collecting specific powers of some symbols</span>
<span class="sd">    then set ``exact`` flag in arguments::</span>

<span class="sd">        &gt;&gt;&gt; collect(a*x**7 + b*x**7, x, exact=True)</span>
<span class="sd">        a*x**7 + b*x**7</span>
<span class="sd">        &gt;&gt;&gt; collect(a*x**7 + b*x**7, x**7, exact=True)</span>
<span class="sd">        x**7*(a + b)</span>

<span class="sd">    You can also apply this function to differential equations, where</span>
<span class="sd">    derivatives of arbitrary order can be collected. Note that if you</span>
<span class="sd">    collect with respect to a function or a derivative of a function, all</span>
<span class="sd">    derivatives of that function will also be collected. Use</span>
<span class="sd">    ``exact=True`` to prevent this from happening::</span>

<span class="sd">        &gt;&gt;&gt; from sympy import Derivative as D, collect, Function</span>
<span class="sd">        &gt;&gt;&gt; f = Function(&#39;f&#39;) (x)</span>

<span class="sd">        &gt;&gt;&gt; collect(a*D(f,x) + b*D(f,x), D(f,x))</span>
<span class="sd">        (a + b)*Derivative(f(x), x)</span>

<span class="sd">        &gt;&gt;&gt; collect(a*D(D(f,x),x) + b*D(D(f,x),x), f)</span>
<span class="sd">        (a + b)*Derivative(f(x), x, x)</span>

<span class="sd">        &gt;&gt;&gt; collect(a*D(D(f,x),x) + b*D(D(f,x),x), D(f,x), exact=True)</span>
<span class="sd">        a*Derivative(f(x), x, x) + b*Derivative(f(x), x, x)</span>

<span class="sd">        &gt;&gt;&gt; collect(a*D(f,x) + b*D(f,x) + a*f + b*f, f)</span>
<span class="sd">        (a + b)*f(x) + (a + b)*Derivative(f(x), x)</span>

<span class="sd">    Or you can even match both derivative order and exponent at the same time::</span>

<span class="sd">        &gt;&gt;&gt; collect(a*D(D(f,x),x)**2 + b*D(D(f,x),x)**2, D(f,x))</span>
<span class="sd">        (a + b)*Derivative(f(x), x, x)**2</span>

<span class="sd">    Finally, you can apply a function to each of the collected coefficients.</span>
<span class="sd">    For example you can factorize symbolic coefficients of polynomial::</span>

<span class="sd">        &gt;&gt;&gt; f = expand((x + a + 1)**3)</span>

<span class="sd">        &gt;&gt;&gt; collect(f, x, factor)</span>
<span class="sd">        x**3 + 3*x**2*(a + 1) + 3*x*(a + 1)**2 + (a + 1)**3</span>

<span class="sd">    .. note:: Arguments are expected to be in expanded form, so you might have</span>
<span class="sd">              to call :func:`expand` prior to calling this function.</span>

<span class="sd">    See Also</span>
<span class="sd">    ========</span>
<span class="sd">    collect_const, collect_sqrt, rcollect</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">evaluate</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">evaluate</span> <span class="o">=</span> <span class="n">global_evaluate</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">make_expression</span><span class="p">(</span><span class="n">terms</span><span class="p">):</span>
        <span class="n">product</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">term</span><span class="p">,</span> <span class="n">rat</span><span class="p">,</span> <span class="n">sym</span><span class="p">,</span> <span class="n">deriv</span> <span class="ow">in</span> <span class="n">terms</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">deriv</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">var</span><span class="p">,</span> <span class="n">order</span> <span class="o">=</span> <span class="n">deriv</span>

                <span class="k">while</span> <span class="n">order</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">term</span><span class="p">,</span> <span class="n">order</span> <span class="o">=</span> <span class="n">Derivative</span><span class="p">(</span><span class="n">term</span><span class="p">,</span> <span class="n">var</span><span class="p">),</span> <span class="n">order</span> <span class="o">-</span> <span class="mi">1</span>

            <span class="k">if</span> <span class="n">sym</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">rat</span> <span class="ow">is</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span><span class="p">:</span>
                    <span class="n">product</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">term</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">product</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Pow</span><span class="p">(</span><span class="n">term</span><span class="p">,</span> <span class="n">rat</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">product</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Pow</span><span class="p">(</span><span class="n">term</span><span class="p">,</span> <span class="n">rat</span><span class="o">*</span><span class="n">sym</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">Mul</span><span class="p">(</span><span class="o">*</span><span class="n">product</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">parse_derivative</span><span class="p">(</span><span class="n">deriv</span><span class="p">):</span>
        <span class="c1"># scan derivatives tower in the input expression and return</span>
        <span class="c1"># underlying function and maximal differentiation order</span>
        <span class="n">expr</span><span class="p">,</span> <span class="n">sym</span><span class="p">,</span> <span class="n">order</span> <span class="o">=</span> <span class="n">deriv</span><span class="o">.</span><span class="n">expr</span><span class="p">,</span> <span class="n">deriv</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span>

        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">deriv</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
            <span class="k">if</span> <span class="n">s</span> <span class="o">==</span> <span class="n">sym</span><span class="p">:</span>
                <span class="n">order</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                    <span class="s1">&#39;Improve MV Derivative support in collect&#39;</span><span class="p">)</span>

        <span class="k">while</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">Derivative</span><span class="p">):</span>
            <span class="n">s0</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

            <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">expr</span><span class="o">.</span><span class="n">variables</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">s</span> <span class="o">!=</span> <span class="n">s0</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                        <span class="s1">&#39;Improve MV Derivative support in collect&#39;</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">s0</span> <span class="o">==</span> <span class="n">sym</span><span class="p">:</span>
                <span class="n">expr</span><span class="p">,</span> <span class="n">order</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">expr</span><span class="p">,</span> <span class="n">order</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">variables</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">break</span>

        <span class="k">return</span> <span class="n">expr</span><span class="p">,</span> <span class="p">(</span><span class="n">sym</span><span class="p">,</span> <span class="n">Rational</span><span class="p">(</span><span class="n">order</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">parse_term</span><span class="p">(</span><span class="n">expr</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Parses expression expr and outputs tuple (sexpr, rat_expo,</span>
<span class="sd">        sym_expo, deriv)</span>
<span class="sd">        where:</span>
<span class="sd">         - sexpr is the base expression</span>
<span class="sd">         - rat_expo is the rational exponent that sexpr is raised to</span>
<span class="sd">         - sym_expo is the symbolic exponent that sexpr is raised to</span>
<span class="sd">         - deriv contains the derivatives the the expression</span>

<span class="sd">         for example, the output of x would be (x, 1, None, None)</span>
<span class="sd">         the output of 2**x would be (2, 1, x, None)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">rat_expo</span><span class="p">,</span> <span class="n">sym_expo</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span><span class="p">,</span> <span class="bp">None</span>
        <span class="n">sexpr</span><span class="p">,</span> <span class="n">deriv</span> <span class="o">=</span> <span class="n">expr</span><span class="p">,</span> <span class="bp">None</span>

        <span class="k">if</span> <span class="n">expr</span><span class="o">.</span><span class="n">is_Pow</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">base</span><span class="p">,</span> <span class="n">Derivative</span><span class="p">):</span>
                <span class="n">sexpr</span><span class="p">,</span> <span class="n">deriv</span> <span class="o">=</span> <span class="n">parse_derivative</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">base</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">sexpr</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">base</span>

            <span class="k">if</span> <span class="n">expr</span><span class="o">.</span><span class="n">exp</span><span class="o">.</span><span class="n">is_Number</span><span class="p">:</span>
                <span class="n">rat_expo</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">exp</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">coeff</span><span class="p">,</span> <span class="n">tail</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">exp</span><span class="o">.</span><span class="n">as_coeff_Mul</span><span class="p">()</span>

                <span class="k">if</span> <span class="n">coeff</span><span class="o">.</span><span class="n">is_Number</span><span class="p">:</span>
                    <span class="n">rat_expo</span><span class="p">,</span> <span class="n">sym_expo</span> <span class="o">=</span> <span class="n">coeff</span><span class="p">,</span> <span class="n">tail</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">sym_expo</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">exp</span>
        <span class="k">elif</span> <span class="n">expr</span><span class="o">.</span><span class="n">func</span> <span class="ow">is</span> <span class="n">exp</span><span class="p">:</span>
            <span class="n">arg</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">arg</span><span class="o">.</span><span class="n">is_Rational</span><span class="p">:</span>
                <span class="n">sexpr</span><span class="p">,</span> <span class="n">rat_expo</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">Exp1</span><span class="p">,</span> <span class="n">arg</span>
            <span class="k">elif</span> <span class="n">arg</span><span class="o">.</span><span class="n">is_Mul</span><span class="p">:</span>
                <span class="n">coeff</span><span class="p">,</span> <span class="n">tail</span> <span class="o">=</span> <span class="n">arg</span><span class="o">.</span><span class="n">as_coeff_Mul</span><span class="p">(</span><span class="n">rational</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
                <span class="n">sexpr</span><span class="p">,</span> <span class="n">rat_expo</span> <span class="o">=</span> <span class="n">exp</span><span class="p">(</span><span class="n">tail</span><span class="p">),</span> <span class="n">coeff</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">Derivative</span><span class="p">):</span>
            <span class="n">sexpr</span><span class="p">,</span> <span class="n">deriv</span> <span class="o">=</span> <span class="n">parse_derivative</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">sexpr</span><span class="p">,</span> <span class="n">rat_expo</span><span class="p">,</span> <span class="n">sym_expo</span><span class="p">,</span> <span class="n">deriv</span>

    <span class="k">def</span> <span class="nf">parse_expression</span><span class="p">(</span><span class="n">terms</span><span class="p">,</span> <span class="n">pattern</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Parse terms searching for a pattern.</span>
<span class="sd">        terms is a list of tuples as returned by parse_terms;</span>
<span class="sd">        pattern is an expression treated as a product of factors</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">pattern</span> <span class="o">=</span> <span class="n">Mul</span><span class="o">.</span><span class="n">make_args</span><span class="p">(</span><span class="n">pattern</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">terms</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">pattern</span><span class="p">):</span>
            <span class="c1"># pattern is longer than matched product</span>
            <span class="c1"># so no chance for positive parsing result</span>
            <span class="k">return</span> <span class="bp">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">pattern</span> <span class="o">=</span> <span class="p">[</span><span class="n">parse_term</span><span class="p">(</span><span class="n">elem</span><span class="p">)</span> <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">pattern</span><span class="p">]</span>

            <span class="n">terms</span> <span class="o">=</span> <span class="n">terms</span><span class="p">[:]</span>  <span class="c1"># need a copy</span>
            <span class="n">elems</span><span class="p">,</span> <span class="n">common_expo</span><span class="p">,</span> <span class="n">has_deriv</span> <span class="o">=</span> <span class="p">[],</span> <span class="bp">None</span><span class="p">,</span> <span class="bp">False</span>

            <span class="k">for</span> <span class="n">elem</span><span class="p">,</span> <span class="n">e_rat</span><span class="p">,</span> <span class="n">e_sym</span><span class="p">,</span> <span class="n">e_ord</span> <span class="ow">in</span> <span class="n">pattern</span><span class="p">:</span>

                <span class="k">if</span> <span class="n">elem</span><span class="o">.</span><span class="n">is_Number</span> <span class="ow">and</span> <span class="n">e_rat</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">e_sym</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="c1"># a constant is a match for everything</span>
                    <span class="k">continue</span>

                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">terms</span><span class="p">)):</span>
                    <span class="k">if</span> <span class="n">terms</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                        <span class="k">continue</span>

                    <span class="n">term</span><span class="p">,</span> <span class="n">t_rat</span><span class="p">,</span> <span class="n">t_sym</span><span class="p">,</span> <span class="n">t_ord</span> <span class="o">=</span> <span class="n">terms</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>

                    <span class="c1"># keeping track of whether one of the terms had</span>
                    <span class="c1"># a derivative or not as this will require rebuilding</span>
                    <span class="c1"># the expression later</span>
                    <span class="k">if</span> <span class="n">t_ord</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                        <span class="n">has_deriv</span> <span class="o">=</span> <span class="bp">True</span>

                    <span class="k">if</span> <span class="p">(</span><span class="n">term</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">elem</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span>
                            <span class="p">(</span><span class="n">t_sym</span> <span class="o">==</span> <span class="n">e_sym</span> <span class="ow">or</span> <span class="n">t_sym</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span>
                            <span class="n">e_sym</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span>
                            <span class="n">t_sym</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">e_sym</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">)):</span>
                        <span class="k">if</span> <span class="n">exact</span> <span class="ow">is</span> <span class="bp">False</span><span class="p">:</span>
                            <span class="c1"># we don&#39;t have to be exact so find common exponent</span>
                            <span class="c1"># for both expression&#39;s term and pattern&#39;s element</span>
                            <span class="n">expo</span> <span class="o">=</span> <span class="n">t_rat</span> <span class="o">/</span> <span class="n">e_rat</span>

                            <span class="k">if</span> <span class="n">common_expo</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                                <span class="c1"># first time</span>
                                <span class="n">common_expo</span> <span class="o">=</span> <span class="n">expo</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="c1"># common exponent was negotiated before so</span>
                                <span class="c1"># there is no chance for a pattern match unless</span>
                                <span class="c1"># common and current exponents are equal</span>
                                <span class="k">if</span> <span class="n">common_expo</span> <span class="o">!=</span> <span class="n">expo</span><span class="p">:</span>
                                    <span class="n">common_expo</span> <span class="o">=</span> <span class="mi">1</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="c1"># we ought to be exact so all fields of</span>
                            <span class="c1"># interest must match in every details</span>
                            <span class="k">if</span> <span class="n">e_rat</span> <span class="o">!=</span> <span class="n">t_rat</span> <span class="ow">or</span> <span class="n">e_ord</span> <span class="o">!=</span> <span class="n">t_ord</span><span class="p">:</span>
                                <span class="k">continue</span>

                        <span class="c1"># found common term so remove it from the expression</span>
                        <span class="c1"># and try to match next element in the pattern</span>
                        <span class="n">elems</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">terms</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
                        <span class="n">terms</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="bp">None</span>

                        <span class="k">break</span>

                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># pattern element not found</span>
                    <span class="k">return</span> <span class="bp">None</span>

            <span class="k">return</span> <span class="p">[</span><span class="n">_f</span> <span class="k">for</span> <span class="n">_f</span> <span class="ow">in</span> <span class="n">terms</span> <span class="k">if</span> <span class="n">_f</span><span class="p">],</span> <span class="n">elems</span><span class="p">,</span> <span class="n">common_expo</span><span class="p">,</span> <span class="n">has_deriv</span>

    <span class="k">if</span> <span class="n">evaluate</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">expr</span><span class="o">.</span><span class="n">is_Mul</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">expr</span><span class="o">.</span><span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="p">[</span>
                <span class="n">collect</span><span class="p">(</span><span class="n">term</span><span class="p">,</span> <span class="n">syms</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="bp">True</span><span class="p">,</span> <span class="n">exact</span><span class="p">,</span> <span class="n">distribute_order_term</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">term</span> <span class="ow">in</span> <span class="n">expr</span><span class="o">.</span><span class="n">args</span><span class="p">])</span>
        <span class="k">elif</span> <span class="n">expr</span><span class="o">.</span><span class="n">is_Pow</span><span class="p">:</span>
            <span class="n">b</span> <span class="o">=</span> <span class="n">collect</span><span class="p">(</span>
                <span class="n">expr</span><span class="o">.</span><span class="n">base</span><span class="p">,</span> <span class="n">syms</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="bp">True</span><span class="p">,</span> <span class="n">exact</span><span class="p">,</span> <span class="n">distribute_order_term</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">Pow</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">expr</span><span class="o">.</span><span class="n">exp</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">iterable</span><span class="p">(</span><span class="n">syms</span><span class="p">):</span>
        <span class="n">syms</span> <span class="o">=</span> <span class="p">[</span><span class="n">expand_power_base</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">syms</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">syms</span> <span class="o">=</span> <span class="p">[</span><span class="n">expand_power_base</span><span class="p">(</span><span class="n">syms</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="bp">False</span><span class="p">)]</span>

    <span class="n">expr</span> <span class="o">=</span> <span class="n">sympify</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
    <span class="n">order_term</span> <span class="o">=</span> <span class="bp">None</span>

    <span class="k">if</span> <span class="n">distribute_order_term</span><span class="p">:</span>
        <span class="n">order_term</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">getO</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">order_term</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">order_term</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="o">*</span><span class="n">syms</span><span class="p">):</span>
                <span class="n">order_term</span> <span class="o">=</span> <span class="bp">None</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">expr</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">removeO</span><span class="p">()</span>

    <span class="n">summa</span> <span class="o">=</span> <span class="p">[</span><span class="n">expand_power_base</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">Add</span><span class="o">.</span><span class="n">make_args</span><span class="p">(</span><span class="n">expr</span><span class="p">)]</span>

    <span class="n">collected</span><span class="p">,</span> <span class="n">disliked</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">),</span> <span class="n">S</span><span class="o">.</span><span class="n">Zero</span>
    <span class="k">for</span> <span class="n">product</span> <span class="ow">in</span> <span class="n">summa</span><span class="p">:</span>
        <span class="n">terms</span> <span class="o">=</span> <span class="p">[</span><span class="n">parse_term</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">Mul</span><span class="o">.</span><span class="n">make_args</span><span class="p">(</span><span class="n">product</span><span class="p">)]</span>

        <span class="k">for</span> <span class="n">symbol</span> <span class="ow">in</span> <span class="n">syms</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">SYMPY_DEBUG</span><span class="p">:</span>
                <span class="k">print</span><span class="p">(</span><span class="s2">&quot;DEBUG: parsing of expression </span><span class="si">%s</span><span class="s2"> with symbol </span><span class="si">%s</span><span class="s2"> &quot;</span> <span class="o">%</span> <span class="p">(</span>
                    <span class="nb">str</span><span class="p">(</span><span class="n">terms</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="n">symbol</span><span class="p">))</span>
                <span class="p">)</span>

            <span class="n">result</span> <span class="o">=</span> <span class="n">parse_expression</span><span class="p">(</span><span class="n">terms</span><span class="p">,</span> <span class="n">symbol</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">SYMPY_DEBUG</span><span class="p">:</span>
                <span class="k">print</span><span class="p">(</span><span class="s2">&quot;DEBUG: returned </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">result</span><span class="p">))</span>

            <span class="k">if</span> <span class="n">result</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">terms</span><span class="p">,</span> <span class="n">elems</span><span class="p">,</span> <span class="n">common_expo</span><span class="p">,</span> <span class="n">has_deriv</span> <span class="o">=</span> <span class="n">result</span>

                <span class="c1"># when there was derivative in current pattern we</span>
                <span class="c1"># will need to rebuild its expression from scratch</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">has_deriv</span><span class="p">:</span>
                    <span class="n">index</span> <span class="o">=</span> <span class="mi">1</span>
                    <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">elems</span><span class="p">:</span>
                        <span class="n">e</span> <span class="o">=</span> <span class="n">elem</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                        <span class="k">if</span> <span class="n">elem</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                            <span class="n">e</span> <span class="o">*=</span> <span class="n">elem</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
                        <span class="n">index</span> <span class="o">*=</span> <span class="n">Pow</span><span class="p">(</span><span class="n">elem</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">e</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">index</span> <span class="o">=</span> <span class="n">make_expression</span><span class="p">(</span><span class="n">elems</span><span class="p">)</span>
                <span class="n">terms</span> <span class="o">=</span> <span class="n">expand_power_base</span><span class="p">(</span><span class="n">make_expression</span><span class="p">(</span><span class="n">terms</span><span class="p">),</span> <span class="n">deep</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
                <span class="n">index</span> <span class="o">=</span> <span class="n">expand_power_base</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
                <span class="n">collected</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">terms</span><span class="p">)</span>
                <span class="k">break</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># none of the patterns matched</span>
            <span class="n">disliked</span> <span class="o">+=</span> <span class="n">product</span>
    <span class="c1"># add terms now for each key</span>
    <span class="n">collected</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">Add</span><span class="p">(</span><span class="o">*</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">collected</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>

    <span class="k">if</span> <span class="n">disliked</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">S</span><span class="o">.</span><span class="n">Zero</span><span class="p">:</span>
        <span class="n">collected</span><span class="p">[</span><span class="n">S</span><span class="o">.</span><span class="n">One</span><span class="p">]</span> <span class="o">=</span> <span class="n">disliked</span>

    <span class="k">if</span> <span class="n">order_term</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">collected</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">collected</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span> <span class="o">+</span> <span class="n">order_term</span>

    <span class="k">if</span> <span class="n">func</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">collected</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
            <span class="p">[(</span><span class="n">key</span><span class="p">,</span> <span class="n">func</span><span class="p">(</span><span class="n">val</span><span class="p">))</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">collected</span><span class="o">.</span><span class="n">items</span><span class="p">()])</span>

    <span class="k">if</span> <span class="n">evaluate</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">Add</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">key</span><span class="o">*</span><span class="n">val</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">collected</span><span class="o">.</span><span class="n">items</span><span class="p">()])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">collected</span></div>


<div class="viewcode-block" id="rcollect"><a class="viewcode-back" href="../../../modules/simplify/simplify.html#sympy.simplify.radsimp.rcollect">[docs]</a><span class="k">def</span> <span class="nf">rcollect</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="o">*</span><span class="nb">vars</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Recursively collect sums in an expression.</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy.simplify import rcollect</span>
<span class="sd">    &gt;&gt;&gt; from sympy.abc import x, y</span>

<span class="sd">    &gt;&gt;&gt; expr = (x**2*y + x*y + x + y)/(x + y)</span>

<span class="sd">    &gt;&gt;&gt; rcollect(expr, y)</span>
<span class="sd">    (x + y*(x**2 + x + 1))/(x + y)</span>

<span class="sd">    See Also</span>
<span class="sd">    ========</span>
<span class="sd">    collect, collect_const, collect_sqrt</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">expr</span><span class="o">.</span><span class="n">is_Atom</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">expr</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="o">*</span><span class="nb">vars</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">expr</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">expr</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">__class__</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">rcollect</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="o">*</span><span class="nb">vars</span><span class="p">)</span> <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">expr</span><span class="o">.</span><span class="n">args</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">expr</span><span class="o">.</span><span class="n">is_Add</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">collect</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="nb">vars</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">expr</span></div>


<div class="viewcode-block" id="collect_sqrt"><a class="viewcode-back" href="../../../modules/simplify/simplify.html#sympy.simplify.radsimp.collect_sqrt">[docs]</a><span class="k">def</span> <span class="nf">collect_sqrt</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">evaluate</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return expr with terms having common square roots collected together.</span>
<span class="sd">    If ``evaluate`` is False a count indicating the number of sqrt-containing</span>
<span class="sd">    terms will be returned and, if non-zero, the terms of the Add will be</span>
<span class="sd">    returned, else the expression itself will be returned as a single term.</span>
<span class="sd">    If ``evaluate`` is True, the expression with any collected terms will be</span>
<span class="sd">    returned.</span>

<span class="sd">    Note: since I = sqrt(-1), it is collected, too.</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy import sqrt</span>
<span class="sd">    &gt;&gt;&gt; from sympy.simplify.radsimp import collect_sqrt</span>
<span class="sd">    &gt;&gt;&gt; from sympy.abc import a, b</span>

<span class="sd">    &gt;&gt;&gt; r2, r3, r5 = [sqrt(i) for i in [2, 3, 5]]</span>
<span class="sd">    &gt;&gt;&gt; collect_sqrt(a*r2 + b*r2)</span>
<span class="sd">    sqrt(2)*(a + b)</span>
<span class="sd">    &gt;&gt;&gt; collect_sqrt(a*r2 + b*r2 + a*r3 + b*r3)</span>
<span class="sd">    sqrt(2)*(a + b) + sqrt(3)*(a + b)</span>
<span class="sd">    &gt;&gt;&gt; collect_sqrt(a*r2 + b*r2 + a*r3 + b*r5)</span>
<span class="sd">    sqrt(3)*a + sqrt(5)*b + sqrt(2)*(a + b)</span>

<span class="sd">    If evaluate is False then the arguments will be sorted and</span>
<span class="sd">    returned as a list and a count of the number of sqrt-containing</span>
<span class="sd">    terms will be returned:</span>

<span class="sd">    &gt;&gt;&gt; collect_sqrt(a*r2 + b*r2 + a*r3 + b*r5, evaluate=False)</span>
<span class="sd">    ((sqrt(3)*a, sqrt(5)*b, sqrt(2)*(a + b)), 3)</span>
<span class="sd">    &gt;&gt;&gt; collect_sqrt(a*sqrt(2) + b, evaluate=False)</span>
<span class="sd">    ((b, sqrt(2)*a), 1)</span>
<span class="sd">    &gt;&gt;&gt; collect_sqrt(a + b, evaluate=False)</span>
<span class="sd">    ((a + b,), 0)</span>

<span class="sd">    See Also</span>
<span class="sd">    ========</span>
<span class="sd">    collect, collect_const, rcollect</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">evaluate</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">evaluate</span> <span class="o">=</span> <span class="n">global_evaluate</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="c1"># this step will help to standardize any complex arguments</span>
    <span class="c1"># of sqrts</span>
    <span class="n">coeff</span><span class="p">,</span> <span class="n">expr</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">as_content_primitive</span><span class="p">()</span>
    <span class="nb">vars</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">Add</span><span class="o">.</span><span class="n">make_args</span><span class="p">(</span><span class="n">expr</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">a</span><span class="o">.</span><span class="n">args_cnc</span><span class="p">()[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">m</span><span class="o">.</span><span class="n">is_number</span> <span class="ow">and</span> <span class="p">(</span>
                    <span class="n">m</span><span class="o">.</span><span class="n">is_Pow</span> <span class="ow">and</span> <span class="n">m</span><span class="o">.</span><span class="n">exp</span><span class="o">.</span><span class="n">is_Rational</span> <span class="ow">and</span> <span class="n">m</span><span class="o">.</span><span class="n">exp</span><span class="o">.</span><span class="n">q</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">or</span>
                    <span class="n">m</span> <span class="ow">is</span> <span class="n">S</span><span class="o">.</span><span class="n">ImaginaryUnit</span><span class="p">):</span>
                <span class="nb">vars</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>

    <span class="c1"># we only want radicals, so exclude Number handling; in this case</span>
    <span class="c1"># d will be evaluated</span>
    <span class="n">d</span> <span class="o">=</span> <span class="n">collect_const</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="o">*</span><span class="nb">vars</span><span class="p">,</span> <span class="n">Numbers</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
    <span class="n">hit</span> <span class="o">=</span> <span class="n">expr</span> <span class="o">!=</span> <span class="n">d</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">evaluate</span><span class="p">:</span>
        <span class="n">nrad</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c1"># make the evaluated args canonical</span>
        <span class="n">args</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">ordered</span><span class="p">(</span><span class="n">Add</span><span class="o">.</span><span class="n">make_args</span><span class="p">(</span><span class="n">d</span><span class="p">)))</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">args</span><span class="p">):</span>
            <span class="n">c</span><span class="p">,</span> <span class="n">nc</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">args_cnc</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">ci</span> <span class="ow">in</span> <span class="n">c</span><span class="p">:</span>
                <span class="c1"># XXX should this be restricted to ci.is_number as above?</span>
                <span class="k">if</span> <span class="n">ci</span><span class="o">.</span><span class="n">is_Pow</span> <span class="ow">and</span> <span class="n">ci</span><span class="o">.</span><span class="n">exp</span><span class="o">.</span><span class="n">is_Rational</span> <span class="ow">and</span> <span class="n">ci</span><span class="o">.</span><span class="n">exp</span><span class="o">.</span><span class="n">q</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">or</span> \
                        <span class="n">ci</span> <span class="ow">is</span> <span class="n">S</span><span class="o">.</span><span class="n">ImaginaryUnit</span><span class="p">:</span>
                    <span class="n">nrad</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="k">break</span>
            <span class="n">args</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*=</span> <span class="n">coeff</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">hit</span> <span class="ow">or</span> <span class="n">nrad</span><span class="p">):</span>
            <span class="n">args</span> <span class="o">=</span> <span class="p">[</span><span class="n">Add</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)]</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">args</span><span class="p">),</span> <span class="n">nrad</span>

    <span class="k">return</span> <span class="n">coeff</span><span class="o">*</span><span class="n">d</span></div>


<div class="viewcode-block" id="collect_const"><a class="viewcode-back" href="../../../modules/simplify/simplify.html#sympy.simplify.radsimp.collect_const">[docs]</a><span class="k">def</span> <span class="nf">collect_const</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="o">*</span><span class="nb">vars</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A non-greedy collection of terms with similar number coefficients in</span>
<span class="sd">    an Add expr. If ``vars`` is given then only those constants will be</span>
<span class="sd">    targeted. Although any Number can also be targeted, if this is not</span>
<span class="sd">    desired set ``Numbers=False`` and no Float or Rational will be collected.</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy import sqrt</span>
<span class="sd">    &gt;&gt;&gt; from sympy.abc import a, s, x, y, z</span>
<span class="sd">    &gt;&gt;&gt; from sympy.simplify.radsimp import collect_const</span>
<span class="sd">    &gt;&gt;&gt; collect_const(sqrt(3) + sqrt(3)*(1 + sqrt(2)))</span>
<span class="sd">    sqrt(3)*(sqrt(2) + 2)</span>
<span class="sd">    &gt;&gt;&gt; collect_const(sqrt(3)*s + sqrt(7)*s + sqrt(3) + sqrt(7))</span>
<span class="sd">    (sqrt(3) + sqrt(7))*(s + 1)</span>
<span class="sd">    &gt;&gt;&gt; s = sqrt(2) + 2</span>
<span class="sd">    &gt;&gt;&gt; collect_const(sqrt(3)*s + sqrt(3) + sqrt(7)*s + sqrt(7))</span>
<span class="sd">    (sqrt(2) + 3)*(sqrt(3) + sqrt(7))</span>
<span class="sd">    &gt;&gt;&gt; collect_const(sqrt(3)*s + sqrt(3) + sqrt(7)*s + sqrt(7), sqrt(3))</span>
<span class="sd">    sqrt(7) + sqrt(3)*(sqrt(2) + 3) + sqrt(7)*(sqrt(2) + 2)</span>

<span class="sd">    The collection is sign-sensitive, giving higher precedence to the</span>
<span class="sd">    unsigned values:</span>

<span class="sd">    &gt;&gt;&gt; collect_const(x - y - z)</span>
<span class="sd">    x - (y + z)</span>
<span class="sd">    &gt;&gt;&gt; collect_const(-y - z)</span>
<span class="sd">    -(y + z)</span>
<span class="sd">    &gt;&gt;&gt; collect_const(2*x - 2*y - 2*z, 2)</span>
<span class="sd">    2*(x - y - z)</span>
<span class="sd">    &gt;&gt;&gt; collect_const(2*x - 2*y - 2*z, -2)</span>
<span class="sd">    2*x - 2*(y + z)</span>

<span class="sd">    See Also</span>
<span class="sd">    ========</span>
<span class="sd">    collect, collect_sqrt, rcollect</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">expr</span><span class="o">.</span><span class="n">is_Add</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">expr</span>

    <span class="n">recurse</span> <span class="o">=</span> <span class="bp">False</span>
    <span class="n">Numbers</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;Numbers&#39;</span><span class="p">,</span> <span class="bp">True</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">vars</span><span class="p">:</span>
        <span class="n">recurse</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="nb">vars</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">expr</span><span class="o">.</span><span class="n">args</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">Mul</span><span class="o">.</span><span class="n">make_args</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">m</span><span class="o">.</span><span class="n">is_number</span><span class="p">:</span>
                    <span class="nb">vars</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="nb">vars</span> <span class="o">=</span> <span class="n">sympify</span><span class="p">(</span><span class="nb">vars</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">Numbers</span><span class="p">:</span>
        <span class="nb">vars</span> <span class="o">=</span> <span class="p">[</span><span class="n">v</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">vars</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">v</span><span class="o">.</span><span class="n">is_Number</span><span class="p">]</span>

    <span class="nb">vars</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">ordered</span><span class="p">(</span><span class="nb">vars</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">vars</span><span class="p">:</span>
        <span class="n">terms</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
        <span class="n">Fv</span> <span class="o">=</span> <span class="n">Factors</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">Add</span><span class="o">.</span><span class="n">make_args</span><span class="p">(</span><span class="n">expr</span><span class="p">):</span>
            <span class="n">f</span> <span class="o">=</span> <span class="n">Factors</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
            <span class="n">q</span><span class="p">,</span> <span class="n">r</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">div</span><span class="p">(</span><span class="n">Fv</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">r</span><span class="o">.</span><span class="n">is_one</span><span class="p">:</span>
                <span class="c1"># only accept this as a true factor if</span>
                <span class="c1"># it didn&#39;t change an exponent from an Integer</span>
                <span class="c1"># to a non-Integer, e.g. 2/sqrt(2) -&gt; sqrt(2)</span>
                <span class="c1"># -- we aren&#39;t looking for this sort of change</span>
                <span class="n">fwas</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">factors</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="n">fnow</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">factors</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">(</span><span class="n">k</span> <span class="ow">in</span> <span class="n">fwas</span> <span class="ow">and</span> <span class="n">fwas</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">is_Integer</span> <span class="ow">and</span> <span class="ow">not</span>
                        <span class="n">fnow</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">is_Integer</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">fnow</span><span class="p">):</span>
                    <span class="n">terms</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">q</span><span class="o">.</span><span class="n">as_expr</span><span class="p">())</span>
                    <span class="k">continue</span>
            <span class="n">terms</span><span class="p">[</span><span class="n">S</span><span class="o">.</span><span class="n">One</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>

        <span class="n">args</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">hit</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="n">uneval</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">ordered</span><span class="p">(</span><span class="n">terms</span><span class="p">):</span>
            <span class="n">v</span> <span class="o">=</span> <span class="n">terms</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">k</span> <span class="ow">is</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span><span class="p">:</span>
                <span class="n">args</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
                <span class="k">continue</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">v</span> <span class="o">=</span> <span class="n">Add</span><span class="p">(</span><span class="o">*</span><span class="n">v</span><span class="p">)</span>
                <span class="n">hit</span> <span class="o">=</span> <span class="bp">True</span>
                <span class="k">if</span> <span class="n">recurse</span> <span class="ow">and</span> <span class="n">v</span> <span class="o">!=</span> <span class="n">expr</span><span class="p">:</span>
                    <span class="nb">vars</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">v</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

            <span class="c1"># be careful not to let uneval become True unless</span>
            <span class="c1"># it must be because it&#39;s going to be more expensive</span>
            <span class="c1"># to rebuild the expression as an unevaluated one</span>
            <span class="k">if</span> <span class="n">Numbers</span> <span class="ow">and</span> <span class="n">k</span><span class="o">.</span><span class="n">is_Number</span> <span class="ow">and</span> <span class="n">v</span><span class="o">.</span><span class="n">is_Add</span><span class="p">:</span>
                <span class="n">args</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">_keep_coeff</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">sign</span><span class="o">=</span><span class="bp">True</span><span class="p">))</span>
                <span class="n">uneval</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">args</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">k</span><span class="o">*</span><span class="n">v</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">hit</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">uneval</span><span class="p">:</span>
                <span class="n">expr</span> <span class="o">=</span> <span class="n">_unevaluated_Add</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">expr</span> <span class="o">=</span> <span class="n">Add</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">expr</span><span class="o">.</span><span class="n">is_Add</span><span class="p">:</span>
                <span class="k">break</span>

    <span class="k">return</span> <span class="n">expr</span></div>


<div class="viewcode-block" id="radsimp"><a class="viewcode-back" href="../../../modules/simplify/simplify.html#sympy.simplify.radsimp.radsimp">[docs]</a><span class="k">def</span> <span class="nf">radsimp</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">symbolic</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">max_terms</span><span class="o">=</span><span class="mi">4</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Rationalize the denominator by removing square roots.</span>

<span class="sd">    Note: the expression returned from radsimp must be used with caution</span>
<span class="sd">    since if the denominator contains symbols, it will be possible to make</span>
<span class="sd">    substitutions that violate the assumptions of the simplification process:</span>
<span class="sd">    that for a denominator matching a + b*sqrt(c), a != +/-b*sqrt(c). (If</span>
<span class="sd">    there are no symbols, this assumptions is made valid by collecting terms</span>
<span class="sd">    of sqrt(c) so the match variable ``a`` does not contain ``sqrt(c)``.) If</span>
<span class="sd">    you do not want the simplification to occur for symbolic denominators, set</span>
<span class="sd">    ``symbolic`` to False.</span>

<span class="sd">    If there are more than ``max_terms`` radical terms then the expression is</span>
<span class="sd">    returned unchanged.</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy import radsimp, sqrt, Symbol, denom, pprint, I</span>
<span class="sd">    &gt;&gt;&gt; from sympy import factor_terms, fraction, signsimp</span>
<span class="sd">    &gt;&gt;&gt; from sympy.simplify.radsimp import collect_sqrt</span>
<span class="sd">    &gt;&gt;&gt; from sympy.abc import a, b, c</span>

<span class="sd">    &gt;&gt;&gt; radsimp(1/(I + 1))</span>
<span class="sd">    (1 - I)/2</span>
<span class="sd">    &gt;&gt;&gt; radsimp(1/(2 + sqrt(2)))</span>
<span class="sd">    (-sqrt(2) + 2)/2</span>
<span class="sd">    &gt;&gt;&gt; x,y = map(Symbol, &#39;xy&#39;)</span>
<span class="sd">    &gt;&gt;&gt; e = ((2 + 2*sqrt(2))*x + (2 + sqrt(8))*y)/(2 + sqrt(2))</span>
<span class="sd">    &gt;&gt;&gt; radsimp(e)</span>
<span class="sd">    sqrt(2)*(x + y)</span>

<span class="sd">    No simplification beyond removal of the gcd is done. One might</span>
<span class="sd">    want to polish the result a little, however, by collecting</span>
<span class="sd">    square root terms:</span>

<span class="sd">    &gt;&gt;&gt; r2 = sqrt(2)</span>
<span class="sd">    &gt;&gt;&gt; r5 = sqrt(5)</span>
<span class="sd">    &gt;&gt;&gt; ans = radsimp(1/(y*r2 + x*r2 + a*r5 + b*r5)); pprint(ans)</span>
<span class="sd">        ___       ___       ___       ___</span>
<span class="sd">      \/ 5 *a + \/ 5 *b - \/ 2 *x - \/ 2 *y</span>
<span class="sd">    ------------------------------------------</span>
<span class="sd">       2               2      2              2</span>
<span class="sd">    5*a  + 10*a*b + 5*b  - 2*x  - 4*x*y - 2*y</span>

<span class="sd">    &gt;&gt;&gt; n, d = fraction(ans)</span>
<span class="sd">    &gt;&gt;&gt; pprint(factor_terms(signsimp(collect_sqrt(n))/d, radical=True))</span>
<span class="sd">            ___             ___</span>
<span class="sd">          \/ 5 *(a + b) - \/ 2 *(x + y)</span>
<span class="sd">    ------------------------------------------</span>
<span class="sd">       2               2      2              2</span>
<span class="sd">    5*a  + 10*a*b + 5*b  - 2*x  - 4*x*y - 2*y</span>

<span class="sd">    If radicals in the denominator cannot be removed or there is no denominator,</span>
<span class="sd">    the original expression will be returned.</span>

<span class="sd">    &gt;&gt;&gt; radsimp(sqrt(2)*x + sqrt(2))</span>
<span class="sd">    sqrt(2)*x + sqrt(2)</span>

<span class="sd">    Results with symbols will not always be valid for all substitutions:</span>

<span class="sd">    &gt;&gt;&gt; eq = 1/(a + b*sqrt(c))</span>
<span class="sd">    &gt;&gt;&gt; eq.subs(a, b*sqrt(c))</span>
<span class="sd">    1/(2*b*sqrt(c))</span>
<span class="sd">    &gt;&gt;&gt; radsimp(eq).subs(a, b*sqrt(c))</span>
<span class="sd">    nan</span>

<span class="sd">    If symbolic=False, symbolic denominators will not be transformed (but</span>
<span class="sd">    numeric denominators will still be processed):</span>

<span class="sd">    &gt;&gt;&gt; radsimp(eq, symbolic=False)</span>
<span class="sd">    1/(a + b*sqrt(c))</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">sympy.simplify.simplify</span> <span class="kn">import</span> <span class="n">signsimp</span>

    <span class="n">syms</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s2">&quot;a:d A:D&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">_num</span><span class="p">(</span><span class="n">rterms</span><span class="p">):</span>
        <span class="c1"># return the multiplier that will simplify the expression described</span>
        <span class="c1"># by rterms [(sqrt arg, coeff), ... ]</span>
        <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">D</span> <span class="o">=</span> <span class="n">syms</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">rterms</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">reps</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">([</span><span class="n">A</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">b</span><span class="p">],</span> <span class="p">[</span><span class="n">j</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">rterms</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">i</span><span class="p">])))</span>
            <span class="k">return</span> <span class="p">(</span>
            <span class="n">sqrt</span><span class="p">(</span><span class="n">A</span><span class="p">)</span><span class="o">*</span><span class="n">a</span> <span class="o">-</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">B</span><span class="p">)</span><span class="o">*</span><span class="n">b</span><span class="p">)</span><span class="o">.</span><span class="n">xreplace</span><span class="p">(</span><span class="n">reps</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">rterms</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">reps</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">([</span><span class="n">A</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">c</span><span class="p">],</span> <span class="p">[</span><span class="n">j</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">rterms</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">i</span><span class="p">])))</span>
            <span class="k">return</span> <span class="p">(</span>
            <span class="p">(</span><span class="n">sqrt</span><span class="p">(</span><span class="n">A</span><span class="p">)</span><span class="o">*</span><span class="n">a</span> <span class="o">+</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">B</span><span class="p">)</span><span class="o">*</span><span class="n">b</span> <span class="o">-</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">C</span><span class="p">)</span><span class="o">*</span><span class="n">c</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">sqrt</span><span class="p">(</span><span class="n">A</span><span class="p">)</span><span class="o">*</span><span class="n">sqrt</span><span class="p">(</span><span class="n">B</span><span class="p">)</span><span class="o">*</span><span class="n">a</span><span class="o">*</span><span class="n">b</span> <span class="o">-</span> <span class="n">A</span><span class="o">*</span><span class="n">a</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span>
            <span class="n">B</span><span class="o">*</span><span class="n">b</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">C</span><span class="o">*</span><span class="n">c</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span><span class="o">.</span><span class="n">xreplace</span><span class="p">(</span><span class="n">reps</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">rterms</span><span class="p">)</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
            <span class="n">reps</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">([</span><span class="n">A</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">D</span><span class="p">,</span> <span class="n">d</span><span class="p">],</span> <span class="p">[</span><span class="n">j</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">rterms</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">i</span><span class="p">])))</span>
            <span class="k">return</span> <span class="p">((</span><span class="n">sqrt</span><span class="p">(</span><span class="n">A</span><span class="p">)</span><span class="o">*</span><span class="n">a</span> <span class="o">+</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">B</span><span class="p">)</span><span class="o">*</span><span class="n">b</span> <span class="o">-</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">C</span><span class="p">)</span><span class="o">*</span><span class="n">c</span> <span class="o">-</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">D</span><span class="p">)</span><span class="o">*</span><span class="n">d</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">sqrt</span><span class="p">(</span><span class="n">A</span><span class="p">)</span><span class="o">*</span><span class="n">sqrt</span><span class="p">(</span><span class="n">B</span><span class="p">)</span><span class="o">*</span><span class="n">a</span><span class="o">*</span><span class="n">b</span>
                <span class="o">-</span> <span class="n">A</span><span class="o">*</span><span class="n">a</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">B</span><span class="o">*</span><span class="n">b</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">sqrt</span><span class="p">(</span><span class="n">C</span><span class="p">)</span><span class="o">*</span><span class="n">sqrt</span><span class="p">(</span><span class="n">D</span><span class="p">)</span><span class="o">*</span><span class="n">c</span><span class="o">*</span><span class="n">d</span> <span class="o">+</span> <span class="n">C</span><span class="o">*</span><span class="n">c</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span>
                <span class="n">D</span><span class="o">*</span><span class="n">d</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="o">-</span><span class="mi">8</span><span class="o">*</span><span class="n">sqrt</span><span class="p">(</span><span class="n">A</span><span class="p">)</span><span class="o">*</span><span class="n">sqrt</span><span class="p">(</span><span class="n">B</span><span class="p">)</span><span class="o">*</span><span class="n">sqrt</span><span class="p">(</span><span class="n">C</span><span class="p">)</span><span class="o">*</span><span class="n">sqrt</span><span class="p">(</span><span class="n">D</span><span class="p">)</span><span class="o">*</span><span class="n">a</span><span class="o">*</span><span class="n">b</span><span class="o">*</span><span class="n">c</span><span class="o">*</span><span class="n">d</span> <span class="o">+</span> <span class="n">A</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">a</span><span class="o">**</span><span class="mi">4</span> <span class="o">-</span>
                <span class="mi">2</span><span class="o">*</span><span class="n">A</span><span class="o">*</span><span class="n">B</span><span class="o">*</span><span class="n">a</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">b</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">A</span><span class="o">*</span><span class="n">C</span><span class="o">*</span><span class="n">a</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">c</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">A</span><span class="o">*</span><span class="n">D</span><span class="o">*</span><span class="n">a</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">d</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">B</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">b</span><span class="o">**</span><span class="mi">4</span> <span class="o">-</span>
                <span class="mi">2</span><span class="o">*</span><span class="n">B</span><span class="o">*</span><span class="n">C</span><span class="o">*</span><span class="n">b</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">c</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">B</span><span class="o">*</span><span class="n">D</span><span class="o">*</span><span class="n">b</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">d</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">C</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">c</span><span class="o">**</span><span class="mi">4</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">C</span><span class="o">*</span><span class="n">D</span><span class="o">*</span><span class="n">c</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">d</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span>
                <span class="n">D</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">d</span><span class="o">**</span><span class="mi">4</span><span class="p">))</span><span class="o">.</span><span class="n">xreplace</span><span class="p">(</span><span class="n">reps</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">rterms</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">rterms</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span>

    <span class="k">def</span> <span class="nf">ispow2</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">log2</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">d</span><span class="o">.</span><span class="n">is_Pow</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span>
        <span class="n">e</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">exp</span>
        <span class="k">if</span> <span class="n">e</span><span class="o">.</span><span class="n">is_Rational</span> <span class="ow">and</span> <span class="n">e</span><span class="o">.</span><span class="n">q</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">or</span> <span class="n">symbolic</span> <span class="ow">and</span> <span class="n">fraction</span><span class="p">(</span><span class="n">e</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">True</span>
        <span class="k">if</span> <span class="n">log2</span><span class="p">:</span>
            <span class="n">q</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">e</span><span class="o">.</span><span class="n">is_Rational</span><span class="p">:</span>
                <span class="n">q</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">q</span>
            <span class="k">elif</span> <span class="n">symbolic</span><span class="p">:</span>
                <span class="n">d</span> <span class="o">=</span> <span class="n">fraction</span><span class="p">(</span><span class="n">e</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">d</span><span class="o">.</span><span class="n">is_Integer</span><span class="p">:</span>
                    <span class="n">q</span> <span class="o">=</span> <span class="n">d</span>
            <span class="k">if</span> <span class="n">q</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">log</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">is_Integer</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">True</span>
        <span class="k">return</span> <span class="bp">False</span>

    <span class="k">def</span> <span class="nf">handle</span><span class="p">(</span><span class="n">expr</span><span class="p">):</span>
        <span class="c1"># Handle first reduces to the case</span>
        <span class="c1"># expr = 1/d, where d is an add, or d is base**p/2.</span>
        <span class="c1"># We do this by recursively calling handle on each piece.</span>
        <span class="kn">from</span> <span class="nn">sympy.simplify.simplify</span> <span class="kn">import</span> <span class="n">nsimplify</span>

        <span class="n">n</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="n">fraction</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">expr</span><span class="o">.</span><span class="n">is_Atom</span> <span class="ow">or</span> <span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">is_Atom</span> <span class="ow">and</span> <span class="n">n</span><span class="o">.</span><span class="n">is_Atom</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">expr</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="n">n</span><span class="o">.</span><span class="n">is_Atom</span><span class="p">:</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">handle</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">n</span><span class="o">.</span><span class="n">args</span><span class="p">])</span>
            <span class="k">return</span> <span class="n">_unevaluated_Mul</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">handle</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">d</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">n</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">_unevaluated_Mul</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">handle</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">d</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">d</span><span class="o">.</span><span class="n">is_Mul</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">_unevaluated_Mul</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">handle</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">d</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">d</span><span class="o">.</span><span class="n">args</span><span class="p">])</span>

        <span class="c1"># By this step, expr is 1/d, and d is not a mul.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">symbolic</span> <span class="ow">and</span> <span class="n">d</span><span class="o">.</span><span class="n">free_symbols</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">expr</span>

        <span class="k">if</span> <span class="n">ispow2</span><span class="p">(</span><span class="n">d</span><span class="p">):</span>
            <span class="n">d2</span> <span class="o">=</span> <span class="n">sqrtdenest</span><span class="p">(</span><span class="n">sqrt</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">base</span><span class="p">))</span><span class="o">**</span><span class="n">fraction</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">exp</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">d2</span> <span class="o">!=</span> <span class="n">d</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">handle</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">d2</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">d</span><span class="o">.</span><span class="n">is_Pow</span> <span class="ow">and</span> <span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">exp</span><span class="o">.</span><span class="n">is_integer</span> <span class="ow">or</span> <span class="n">d</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">is_positive</span><span class="p">):</span>
            <span class="c1"># (1/d**i) = (1/d)**i</span>
            <span class="k">return</span> <span class="n">handle</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">d</span><span class="o">.</span><span class="n">base</span><span class="p">)</span><span class="o">**</span><span class="n">d</span><span class="o">.</span><span class="n">exp</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">is_Add</span> <span class="ow">or</span> <span class="n">ispow2</span><span class="p">(</span><span class="n">d</span><span class="p">)):</span>
            <span class="k">return</span> <span class="mi">1</span><span class="o">/</span><span class="n">d</span><span class="o">.</span><span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">handle</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">d</span><span class="o">.</span><span class="n">args</span><span class="p">])</span>

        <span class="c1"># handle 1/d treating d as an Add (though it may not be)</span>

        <span class="n">keep</span> <span class="o">=</span> <span class="bp">True</span>  <span class="c1"># keep changes that are made</span>

        <span class="c1"># flatten it and collect radicals after checking for special</span>
        <span class="c1"># conditions</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">_mexpand</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>

        <span class="c1"># did it change?</span>
        <span class="k">if</span> <span class="n">d</span><span class="o">.</span><span class="n">is_Atom</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">1</span><span class="o">/</span><span class="n">d</span>

        <span class="c1"># is it a number that might be handled easily?</span>
        <span class="k">if</span> <span class="n">d</span><span class="o">.</span><span class="n">is_number</span><span class="p">:</span>
            <span class="n">_d</span> <span class="o">=</span> <span class="n">nsimplify</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">_d</span><span class="o">.</span><span class="n">is_Number</span> <span class="ow">and</span> <span class="n">_d</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span><span class="n">d</span><span class="p">):</span>
                <span class="k">return</span> <span class="mi">1</span><span class="o">/</span><span class="n">_d</span>

        <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
            <span class="c1"># collect similar terms</span>
            <span class="n">collected</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">Add</span><span class="o">.</span><span class="n">make_args</span><span class="p">(</span><span class="n">d</span><span class="p">):</span>  <span class="c1"># d might have become non-Add</span>
                <span class="n">p2</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">other</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">Mul</span><span class="o">.</span><span class="n">make_args</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">ispow2</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">log2</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
                        <span class="n">p2</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">base</span> <span class="k">if</span> <span class="n">i</span><span class="o">.</span><span class="n">exp</span> <span class="ow">is</span> <span class="n">S</span><span class="o">.</span><span class="n">Half</span> <span class="k">else</span> <span class="n">i</span><span class="o">.</span><span class="n">base</span><span class="o">**</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">i</span><span class="o">.</span><span class="n">exp</span><span class="p">))</span>
                    <span class="k">elif</span> <span class="n">i</span> <span class="ow">is</span> <span class="n">S</span><span class="o">.</span><span class="n">ImaginaryUnit</span><span class="p">:</span>
                        <span class="n">p2</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">NegativeOne</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">other</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                <span class="n">collected</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">ordered</span><span class="p">(</span><span class="n">p2</span><span class="p">))]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Mul</span><span class="p">(</span><span class="o">*</span><span class="n">other</span><span class="p">))</span>
            <span class="n">rterms</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">ordered</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">collected</span><span class="o">.</span><span class="n">items</span><span class="p">())))</span>
            <span class="n">rterms</span> <span class="o">=</span> <span class="p">[(</span><span class="n">Mul</span><span class="p">(</span><span class="o">*</span><span class="n">i</span><span class="p">),</span> <span class="n">Add</span><span class="p">(</span><span class="o">*</span><span class="n">j</span><span class="p">))</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">rterms</span><span class="p">]</span>
            <span class="n">nrad</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">rterms</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="mi">1</span> <span class="k">if</span> <span class="n">rterms</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span> <span class="k">else</span> <span class="mi">0</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">nrad</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="k">elif</span> <span class="n">nrad</span> <span class="o">&gt;</span> <span class="n">max_terms</span><span class="p">:</span>
                <span class="c1"># there may have been invalid operations leading to this point</span>
                <span class="c1"># so don&#39;t keep changes, e.g. this expression is troublesome</span>
                <span class="c1"># in collecting terms so as not to raise the issue of 2834:</span>
                <span class="c1"># r = sqrt(sqrt(5) + 5)</span>
                <span class="c1"># eq = 1/(sqrt(5)*r + 2*sqrt(5)*sqrt(-sqrt(5) + 5) + 5*r)</span>
                <span class="n">keep</span> <span class="o">=</span> <span class="bp">False</span>
                <span class="k">break</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">rterms</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">4</span><span class="p">:</span>
                <span class="c1"># in general, only 4 terms can be removed with repeated squaring</span>
                <span class="c1"># but other considerations can guide selection of radical terms</span>
                <span class="c1"># so that radicals are removed</span>
                <span class="k">if</span> <span class="nb">all</span><span class="p">([</span><span class="n">x</span><span class="o">.</span><span class="n">is_Integer</span> <span class="ow">and</span> <span class="p">(</span><span class="n">y</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">is_Rational</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">rterms</span><span class="p">]):</span>
                    <span class="n">nd</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="n">rad_rationalize</span><span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">One</span><span class="p">,</span> <span class="n">Add</span><span class="o">.</span><span class="n">_from_args</span><span class="p">(</span>
                        <span class="p">[</span><span class="n">sqrt</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">y</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">rterms</span><span class="p">]))</span>
                    <span class="n">n</span> <span class="o">*=</span> <span class="n">nd</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># is there anything else that might be attempted?</span>
                    <span class="n">keep</span> <span class="o">=</span> <span class="bp">False</span>
                <span class="k">break</span>
            <span class="kn">from</span> <span class="nn">sympy.simplify.powsimp</span> <span class="kn">import</span> <span class="n">powsimp</span><span class="p">,</span> <span class="n">powdenest</span>

            <span class="n">num</span> <span class="o">=</span> <span class="n">powsimp</span><span class="p">(</span><span class="n">_num</span><span class="p">(</span><span class="n">rterms</span><span class="p">))</span>
            <span class="n">n</span> <span class="o">*=</span> <span class="n">num</span>
            <span class="n">d</span> <span class="o">*=</span> <span class="n">num</span>
            <span class="n">d</span> <span class="o">=</span> <span class="n">powdenest</span><span class="p">(</span><span class="n">_mexpand</span><span class="p">(</span><span class="n">d</span><span class="p">),</span> <span class="n">force</span><span class="o">=</span><span class="n">symbolic</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">d</span><span class="o">.</span><span class="n">is_Atom</span><span class="p">:</span>
                <span class="k">break</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">keep</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">expr</span>
        <span class="k">return</span> <span class="n">_unevaluated_Mul</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="n">d</span><span class="p">)</span>

    <span class="n">coeff</span><span class="p">,</span> <span class="n">expr</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">as_coeff_Add</span><span class="p">()</span>
    <span class="n">expr</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">normal</span><span class="p">()</span>
    <span class="n">old</span> <span class="o">=</span> <span class="n">fraction</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
    <span class="n">n</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="n">fraction</span><span class="p">(</span><span class="n">handle</span><span class="p">(</span><span class="n">expr</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">old</span> <span class="o">!=</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">d</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">d</span><span class="o">.</span><span class="n">is_Atom</span><span class="p">:</span>
            <span class="n">was</span> <span class="o">=</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">signsimp</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">evaluate</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
            <span class="n">d</span> <span class="o">=</span> <span class="n">signsimp</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">evaluate</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
            <span class="n">u</span> <span class="o">=</span> <span class="n">Factors</span><span class="p">(</span><span class="n">_unevaluated_Mul</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="n">d</span><span class="p">))</span>
            <span class="n">u</span> <span class="o">=</span> <span class="n">_unevaluated_Mul</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">k</span><span class="o">**</span><span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">u</span><span class="o">.</span><span class="n">factors</span><span class="o">.</span><span class="n">items</span><span class="p">()])</span>
            <span class="n">n</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="n">fraction</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">old</span> <span class="o">==</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">d</span><span class="p">):</span>
                <span class="n">n</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="n">was</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">expand_mul</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">d</span><span class="o">.</span><span class="n">is_Number</span> <span class="ow">or</span> <span class="n">d</span><span class="o">.</span><span class="n">is_Add</span><span class="p">:</span>
            <span class="n">n2</span><span class="p">,</span> <span class="n">d2</span> <span class="o">=</span> <span class="n">fraction</span><span class="p">(</span><span class="n">gcd_terms</span><span class="p">(</span><span class="n">_unevaluated_Mul</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="n">d</span><span class="p">)))</span>
            <span class="k">if</span> <span class="n">d2</span><span class="o">.</span><span class="n">is_Number</span> <span class="ow">or</span> <span class="p">(</span><span class="n">d2</span><span class="o">.</span><span class="n">count_ops</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="n">d</span><span class="o">.</span><span class="n">count_ops</span><span class="p">()):</span>
                <span class="n">n</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="p">[</span><span class="n">signsimp</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">(</span><span class="n">n2</span><span class="p">,</span> <span class="n">d2</span><span class="p">)]</span>
                <span class="k">if</span> <span class="n">n</span><span class="o">.</span><span class="n">is_Mul</span> <span class="ow">and</span> <span class="n">n</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">is_Number</span><span class="p">:</span>
                    <span class="n">n</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">n</span><span class="o">.</span><span class="n">args</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">coeff</span> <span class="o">+</span> <span class="n">_unevaluated_Mul</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="n">d</span><span class="p">)</span></div>


<div class="viewcode-block" id="rad_rationalize"><a class="viewcode-back" href="../../../modules/simplify/simplify.html#sympy.simplify.radsimp.rad_rationalize">[docs]</a><span class="k">def</span> <span class="nf">rad_rationalize</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="n">den</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Rationalize num/den by removing square roots in the denominator;</span>
<span class="sd">    num and den are sum of terms whose squares are rationals</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy import sqrt</span>
<span class="sd">    &gt;&gt;&gt; from sympy.simplify.radsimp import rad_rationalize</span>
<span class="sd">    &gt;&gt;&gt; rad_rationalize(sqrt(3), 1 + sqrt(2)/3)</span>
<span class="sd">    (-sqrt(3) + sqrt(6)/3, -7/9)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">den</span><span class="o">.</span><span class="n">is_Add</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">num</span><span class="p">,</span> <span class="n">den</span>
    <span class="n">g</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">split_surds</span><span class="p">(</span><span class="n">den</span><span class="p">)</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">a</span><span class="o">*</span><span class="n">sqrt</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
    <span class="n">num</span> <span class="o">=</span> <span class="n">_mexpand</span><span class="p">((</span><span class="n">a</span> <span class="o">-</span> <span class="n">b</span><span class="p">)</span><span class="o">*</span><span class="n">num</span><span class="p">)</span>
    <span class="n">den</span> <span class="o">=</span> <span class="n">_mexpand</span><span class="p">(</span><span class="n">a</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">b</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">rad_rationalize</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="n">den</span><span class="p">)</span></div>


<div class="viewcode-block" id="fraction"><a class="viewcode-back" href="../../../modules/simplify/simplify.html#sympy.simplify.radsimp.fraction">[docs]</a><span class="k">def</span> <span class="nf">fraction</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">exact</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns a pair with expression&#39;s numerator and denominator.</span>
<span class="sd">       If the given expression is not a fraction then this function</span>
<span class="sd">       will return the tuple (expr, 1).</span>

<span class="sd">       This function will not make any attempt to simplify nested</span>
<span class="sd">       fractions or to do any term rewriting at all.</span>

<span class="sd">       If only one of the numerator/denominator pair is needed then</span>
<span class="sd">       use numer(expr) or denom(expr) functions respectively.</span>

<span class="sd">       &gt;&gt;&gt; from sympy import fraction, Rational, Symbol</span>
<span class="sd">       &gt;&gt;&gt; from sympy.abc import x, y</span>

<span class="sd">       &gt;&gt;&gt; fraction(x/y)</span>
<span class="sd">       (x, y)</span>
<span class="sd">       &gt;&gt;&gt; fraction(x)</span>
<span class="sd">       (x, 1)</span>

<span class="sd">       &gt;&gt;&gt; fraction(1/y**2)</span>
<span class="sd">       (1, y**2)</span>

<span class="sd">       &gt;&gt;&gt; fraction(x*y/2)</span>
<span class="sd">       (x*y, 2)</span>
<span class="sd">       &gt;&gt;&gt; fraction(Rational(1, 2))</span>
<span class="sd">       (1, 2)</span>

<span class="sd">       This function will also work fine with assumptions:</span>

<span class="sd">       &gt;&gt;&gt; k = Symbol(&#39;k&#39;, negative=True)</span>
<span class="sd">       &gt;&gt;&gt; fraction(x * y**k)</span>
<span class="sd">       (x, y**(-k))</span>

<span class="sd">       If we know nothing about sign of some exponent and &#39;exact&#39;</span>
<span class="sd">       flag is unset, then structure this exponent&#39;s structure will</span>
<span class="sd">       be analyzed and pretty fraction will be returned:</span>

<span class="sd">       &gt;&gt;&gt; from sympy import exp</span>
<span class="sd">       &gt;&gt;&gt; fraction(2*x**(-y))</span>
<span class="sd">       (2, x**y)</span>

<span class="sd">       &gt;&gt;&gt; fraction(exp(-x))</span>
<span class="sd">       (1, exp(x))</span>

<span class="sd">       &gt;&gt;&gt; fraction(exp(-x), exact=True)</span>
<span class="sd">       (exp(-x), 1)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">expr</span> <span class="o">=</span> <span class="n">sympify</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>

    <span class="n">numer</span><span class="p">,</span> <span class="n">denom</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">term</span> <span class="ow">in</span> <span class="n">Mul</span><span class="o">.</span><span class="n">make_args</span><span class="p">(</span><span class="n">expr</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">term</span><span class="o">.</span><span class="n">is_commutative</span> <span class="ow">and</span> <span class="p">(</span><span class="n">term</span><span class="o">.</span><span class="n">is_Pow</span> <span class="ow">or</span> <span class="n">term</span><span class="o">.</span><span class="n">func</span> <span class="ow">is</span> <span class="n">exp</span><span class="p">):</span>
            <span class="n">b</span><span class="p">,</span> <span class="n">ex</span> <span class="o">=</span> <span class="n">term</span><span class="o">.</span><span class="n">as_base_exp</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">ex</span><span class="o">.</span><span class="n">is_negative</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">ex</span> <span class="ow">is</span> <span class="n">S</span><span class="o">.</span><span class="n">NegativeOne</span><span class="p">:</span>
                    <span class="n">denom</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">denom</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Pow</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="o">-</span><span class="n">ex</span><span class="p">))</span>
            <span class="k">elif</span> <span class="n">ex</span><span class="o">.</span><span class="n">is_positive</span><span class="p">:</span>
                <span class="n">numer</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">term</span><span class="p">)</span>
            <span class="k">elif</span> <span class="ow">not</span> <span class="n">exact</span> <span class="ow">and</span> <span class="n">ex</span><span class="o">.</span><span class="n">is_Mul</span><span class="p">:</span>
                <span class="n">n</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="n">term</span><span class="o">.</span><span class="n">as_numer_denom</span><span class="p">()</span>
                <span class="n">numer</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
                <span class="n">denom</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">numer</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">term</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">term</span><span class="o">.</span><span class="n">is_Rational</span><span class="p">:</span>
            <span class="n">n</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="n">term</span><span class="o">.</span><span class="n">as_numer_denom</span><span class="p">()</span>
            <span class="n">numer</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
            <span class="n">denom</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">numer</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">term</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">Mul</span><span class="p">(</span><span class="o">*</span><span class="n">numer</span><span class="p">),</span> <span class="n">Mul</span><span class="p">(</span><span class="o">*</span><span class="n">denom</span><span class="p">)</span></div>


<span class="k">def</span> <span class="nf">numer</span><span class="p">(</span><span class="n">expr</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">fraction</span><span class="p">(</span><span class="n">expr</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">denom</span><span class="p">(</span><span class="n">expr</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">fraction</span><span class="p">(</span><span class="n">expr</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">fraction_expand</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="o">**</span><span class="n">hints</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">expr</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="n">frac</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="o">**</span><span class="n">hints</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">numer_expand</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="o">**</span><span class="n">hints</span><span class="p">):</span>
    <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">fraction</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">a</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="n">numer</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="o">**</span><span class="n">hints</span><span class="p">)</span> <span class="o">/</span> <span class="n">b</span>


<span class="k">def</span> <span class="nf">denom_expand</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="o">**</span><span class="n">hints</span><span class="p">):</span>
    <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">fraction</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">a</span> <span class="o">/</span> <span class="n">b</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="n">denom</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="o">**</span><span class="n">hints</span><span class="p">)</span>


<span class="n">expand_numer</span> <span class="o">=</span> <span class="n">numer_expand</span>
<span class="n">expand_denom</span> <span class="o">=</span> <span class="n">denom_expand</span>
<span class="n">expand_fraction</span> <span class="o">=</span> <span class="n">fraction_expand</span>


<span class="k">def</span> <span class="nf">split_surds</span><span class="p">(</span><span class="n">expr</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    split an expression with terms whose squares are rationals</span>
<span class="sd">    into a sum of terms whose surds squared have gcd equal to g</span>
<span class="sd">    and a sum of terms with surds squared prime with g</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy import sqrt</span>
<span class="sd">    &gt;&gt;&gt; from sympy.simplify.radsimp import split_surds</span>
<span class="sd">    &gt;&gt;&gt; split_surds(3*sqrt(3) + sqrt(5)/7 + sqrt(6) + sqrt(10) + sqrt(15))</span>
<span class="sd">    (3, sqrt(2) + sqrt(5) + 3, sqrt(5)/7 + sqrt(10))</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">args</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">args</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">default_sort_key</span><span class="p">)</span>
    <span class="n">coeff_muls</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">as_coeff_Mul</span><span class="p">()</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">args</span><span class="p">]</span>
    <span class="n">surds</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">coeff_muls</span> <span class="k">if</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">is_Pow</span><span class="p">]</span>
    <span class="n">surds</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="n">default_sort_key</span><span class="p">)</span>
    <span class="n">g</span><span class="p">,</span> <span class="n">b1</span><span class="p">,</span> <span class="n">b2</span> <span class="o">=</span> <span class="n">_split_gcd</span><span class="p">(</span><span class="o">*</span><span class="n">surds</span><span class="p">)</span>
    <span class="n">g2</span> <span class="o">=</span> <span class="n">g</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">b2</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">b1</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">b1n</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">/</span><span class="n">g</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">b1</span><span class="p">]</span>
        <span class="n">b1n</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">b1n</span> <span class="k">if</span> <span class="n">x</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">]</span>
        <span class="c1"># only a common factor has been factored; split again</span>
        <span class="n">g1</span><span class="p">,</span> <span class="n">b1n</span><span class="p">,</span> <span class="n">b2</span> <span class="o">=</span> <span class="n">_split_gcd</span><span class="p">(</span><span class="o">*</span><span class="n">b1n</span><span class="p">)</span>
        <span class="n">g2</span> <span class="o">=</span> <span class="n">g</span><span class="o">*</span><span class="n">g1</span>
    <span class="n">a1v</span><span class="p">,</span> <span class="n">a2v</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">c</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">coeff_muls</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">s</span><span class="o">.</span><span class="n">is_Pow</span> <span class="ow">and</span> <span class="n">s</span><span class="o">.</span><span class="n">exp</span> <span class="o">==</span> <span class="n">S</span><span class="o">.</span><span class="n">Half</span><span class="p">:</span>
            <span class="n">s1</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">base</span>
            <span class="k">if</span> <span class="n">s1</span> <span class="ow">in</span> <span class="n">b1</span><span class="p">:</span>
                <span class="n">a1v</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c</span><span class="o">*</span><span class="n">sqrt</span><span class="p">(</span><span class="n">s1</span><span class="o">/</span><span class="n">g2</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">a2v</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c</span><span class="o">*</span><span class="n">s</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">a2v</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c</span><span class="o">*</span><span class="n">s</span><span class="p">)</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">Add</span><span class="p">(</span><span class="o">*</span><span class="n">a1v</span><span class="p">)</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">Add</span><span class="p">(</span><span class="o">*</span><span class="n">a2v</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">g2</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span>


<span class="k">def</span> <span class="nf">_split_gcd</span><span class="p">(</span><span class="o">*</span><span class="n">a</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    split the list of integers ``a`` into a list of integers, ``a1`` having</span>
<span class="sd">    ``g = gcd(a1)``, and a list ``a2`` whose elements are not divisible by</span>
<span class="sd">    ``g``.  Returns ``g, a1, a2``</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy.simplify.radsimp import _split_gcd</span>
<span class="sd">    &gt;&gt;&gt; _split_gcd(55, 35, 22, 14, 77, 10)</span>
<span class="sd">    (5, [55, 35, 10], [22, 14, 77])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">g</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">b1</span> <span class="o">=</span> <span class="p">[</span><span class="n">g</span><span class="p">]</span>
    <span class="n">b2</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
        <span class="n">g1</span> <span class="o">=</span> <span class="n">gcd</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">g1</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">b2</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">g</span> <span class="o">=</span> <span class="n">g1</span>
            <span class="n">b1</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">g</span><span class="p">,</span> <span class="n">b1</span><span class="p">,</span> <span class="n">b2</span>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../../index.html">
              <img class="logo" src="../../../_static/sympylogo.png" alt="Logo"/>
            </a></p><div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../index.html">Documentation overview</a><ul>
  <li><a href="../../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2015 SymPy Development Team.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.4.1</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.7</a>
      
    </div>

    

    
  </body>
</html>