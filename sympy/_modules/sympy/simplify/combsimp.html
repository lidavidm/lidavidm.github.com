<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>sympy.simplify.combsimp &mdash; SymPy 1.0.1.dev documentation</title>
    
    <link rel="stylesheet" href="../../../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="http://96.sympy-live-tests.appspot.com/static/live-core.css" type="text/css" />
    <link rel="stylesheet" href="http://96.sympy-live-tests.appspot.com/static/live-autocomplete.css" type="text/css" />
    <link rel="stylesheet" href="http://96.sympy-live-tests.appspot.com/static/live-sphinx.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '1.0.1.dev',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="http://96.sympy-live-tests.appspot.com/static/utilities.js"></script>
    <script type="text/javascript" src="http://96.sympy-live-tests.appspot.com/static/external/classy.js"></script>
    <script type="text/javascript" src="http://96.sympy-live-tests.appspot.com/static/live-core.js"></script>
    <script type="text/javascript" src="http://96.sympy-live-tests.appspot.com/static/live-autocomplete.js"></script>
    <script type="text/javascript" src="http://96.sympy-live-tests.appspot.com/static/live-sphinx.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML-full"></script>
    <link rel="shortcut icon" href="../../../_static/sympy-notailtext-favicon.ico"/>
    <link rel="top" title="SymPy 1.0.1.dev documentation" href="../../../index.html" />
    <link rel="up" title="Module code" href="../../index.html" />
   
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head>
  <body role="document">  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for sympy.simplify.combsimp</h1><div class="highlight"><pre>
<span></span><span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">print_function</span><span class="p">,</span> <span class="n">division</span>

<span class="kn">from</span> <span class="nn">sympy.core</span> <span class="kn">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">Mul</span><span class="p">,</span> <span class="n">Pow</span><span class="p">,</span> <span class="n">Add</span>
<span class="kn">from</span> <span class="nn">sympy.core.compatibility</span> <span class="kn">import</span> <span class="n">ordered</span><span class="p">,</span> <span class="n">default_sort_key</span>
<span class="kn">from</span> <span class="nn">sympy.functions.combinatorial.factorials</span> <span class="kn">import</span> <span class="n">binomial</span><span class="p">,</span> <span class="n">CombinatorialFunction</span><span class="p">,</span> <span class="n">factorial</span>
<span class="kn">from</span> <span class="nn">sympy.functions</span> <span class="kn">import</span> <span class="n">gamma</span><span class="p">,</span> <span class="n">sqrt</span><span class="p">,</span> <span class="n">sin</span>
<span class="kn">from</span> <span class="nn">sympy.polys</span> <span class="kn">import</span> <span class="n">factor</span><span class="p">,</span> <span class="n">cancel</span>

<span class="kn">from</span> <span class="nn">sympy.utilities.timeutils</span> <span class="kn">import</span> <span class="n">timethis</span>
<span class="kn">from</span> <span class="nn">sympy.utilities.iterables</span> <span class="kn">import</span> <span class="n">sift</span>
<span class="kn">from</span> <span class="nn">sympy.utilities.iterables</span> <span class="kn">import</span> <span class="n">uniq</span>



<span class="nd">@timethis</span><span class="p">(</span><span class="s1">&#39;combsimp&#39;</span><span class="p">)</span>
<div class="viewcode-block" id="combsimp"><a class="viewcode-back" href="../../../modules/simplify/simplify.html#sympy.simplify.combsimp.combsimp">[docs]</a><span class="k">def</span> <span class="nf">combsimp</span><span class="p">(</span><span class="n">expr</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    Simplify combinatorial expressions.</span>

<span class="sd">    This function takes as input an expression containing factorials,</span>
<span class="sd">    binomials, Pochhammer symbol and other &quot;combinatorial&quot; functions,</span>
<span class="sd">    and tries to minimize the number of those functions and reduce</span>
<span class="sd">    the size of their arguments.</span>

<span class="sd">    The algorithm works by rewriting all combinatorial functions as</span>
<span class="sd">    expressions involving rising factorials (Pochhammer symbols) and</span>
<span class="sd">    applies recurrence relations and other transformations applicable</span>
<span class="sd">    to rising factorials, to reduce their arguments, possibly letting</span>
<span class="sd">    the resulting rising factorial to cancel. Rising factorials with</span>
<span class="sd">    the second argument being an integer are expanded into polynomial</span>
<span class="sd">    forms and finally all other rising factorial are rewritten in terms</span>
<span class="sd">    of more familiar functions. If the initial expression consisted of</span>
<span class="sd">    gamma functions alone, the result is expressed in terms of gamma</span>
<span class="sd">    functions. If the initial expression consists of gamma function</span>
<span class="sd">    with some other combinatorial, the result is expressed in terms of</span>
<span class="sd">    gamma functions.</span>

<span class="sd">    If the result is expressed using gamma functions, the following three</span>
<span class="sd">    additional steps are performed:</span>

<span class="sd">    1. Reduce the number of gammas by applying the reflection theorem</span>
<span class="sd">       gamma(x)*gamma(1-x) == pi/sin(pi*x).</span>
<span class="sd">    2. Reduce the number of gammas by applying the multiplication theorem</span>
<span class="sd">       gamma(x)*gamma(x+1/n)*...*gamma(x+(n-1)/n) == C*gamma(n*x).</span>
<span class="sd">    3. Reduce the number of prefactors by absorbing them into gammas, where</span>
<span class="sd">       possible.</span>

<span class="sd">    All transformation rules can be found (or was derived from) here:</span>

<span class="sd">    1. http://functions.wolfram.com/GammaBetaErf/Pochhammer/17/01/02/</span>
<span class="sd">    2. http://functions.wolfram.com/GammaBetaErf/Pochhammer/27/01/0005/</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy.simplify import combsimp</span>
<span class="sd">    &gt;&gt;&gt; from sympy import factorial, binomial</span>
<span class="sd">    &gt;&gt;&gt; from sympy.abc import n, k</span>

<span class="sd">    &gt;&gt;&gt; combsimp(factorial(n)/factorial(n - 3))</span>
<span class="sd">    n*(n - 2)*(n - 1)</span>
<span class="sd">    &gt;&gt;&gt; combsimp(binomial(n+1, k+1)/binomial(n, k))</span>
<span class="sd">    (n + 1)/(k + 1)</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># as a rule of thumb, if the expression contained gammas initially, it</span>
    <span class="c1"># probably makes sense to retain them</span>
    <span class="n">as_gamma</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">gamma</span><span class="p">)</span>
    <span class="n">as_factorial</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">factorial</span><span class="p">)</span>
    <span class="n">as_binomial</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">binomial</span><span class="p">)</span>


    <span class="n">expr</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">binomial</span><span class="p">,</span>
        <span class="k">lambda</span> <span class="n">n</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="n">_rf</span><span class="p">((</span><span class="n">n</span> <span class="o">-</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">expand</span><span class="p">(),</span> <span class="n">k</span><span class="o">.</span><span class="n">expand</span><span class="p">())</span><span class="o">/</span><span class="n">_rf</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">k</span><span class="o">.</span><span class="n">expand</span><span class="p">()))</span>
    <span class="n">expr</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">factorial</span><span class="p">,</span>
        <span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">_rf</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="o">.</span><span class="n">expand</span><span class="p">()))</span>
    <span class="n">expr</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">rewrite</span><span class="p">(</span><span class="n">gamma</span><span class="p">)</span>
    <span class="n">expr</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">gamma</span><span class="p">,</span>
        <span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">_rf</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">expand</span><span class="p">()))</span>

    <span class="k">if</span> <span class="n">as_gamma</span><span class="p">:</span>
        <span class="n">expr</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">_rf</span><span class="p">,</span>
            <span class="k">lambda</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">gamma</span><span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">)</span><span class="o">/</span><span class="n">gamma</span><span class="p">(</span><span class="n">a</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">expr</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">_rf</span><span class="p">,</span>
            <span class="k">lambda</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">binomial</span><span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span><span class="o">*</span><span class="n">gamma</span><span class="p">(</span><span class="n">b</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">rule</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
        <span class="n">coeff</span><span class="p">,</span> <span class="n">rewrite</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span><span class="p">,</span> <span class="bp">False</span>

        <span class="n">cn</span><span class="p">,</span> <span class="n">_n</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">as_coeff_Add</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">_n</span> <span class="ow">and</span> <span class="n">cn</span><span class="o">.</span><span class="n">is_Integer</span> <span class="ow">and</span> <span class="n">cn</span><span class="p">:</span>
            <span class="n">coeff</span> <span class="o">*=</span> <span class="n">_rf</span><span class="p">(</span><span class="n">_n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">cn</span><span class="p">)</span><span class="o">/</span><span class="n">_rf</span><span class="p">(</span><span class="n">_n</span> <span class="o">-</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">cn</span><span class="p">)</span>
            <span class="n">rewrite</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">_n</span>

        <span class="c1"># this sort of binomial has already been removed by</span>
        <span class="c1"># rising factorials but is left here in case the order</span>
        <span class="c1"># of rule application is changed</span>
        <span class="k">if</span> <span class="n">k</span><span class="o">.</span><span class="n">is_Add</span><span class="p">:</span>
            <span class="n">ck</span><span class="p">,</span> <span class="n">_k</span> <span class="o">=</span> <span class="n">k</span><span class="o">.</span><span class="n">as_coeff_Add</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">_k</span> <span class="ow">and</span> <span class="n">ck</span><span class="o">.</span><span class="n">is_Integer</span> <span class="ow">and</span> <span class="n">ck</span><span class="p">:</span>
                <span class="n">coeff</span> <span class="o">*=</span> <span class="n">_rf</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="n">ck</span> <span class="o">-</span> <span class="n">_k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ck</span><span class="p">)</span><span class="o">/</span><span class="n">_rf</span><span class="p">(</span><span class="n">_k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ck</span><span class="p">)</span>
                <span class="n">rewrite</span> <span class="o">=</span> <span class="bp">True</span>
                <span class="n">k</span> <span class="o">=</span> <span class="n">_k</span>

        <span class="k">if</span> <span class="n">rewrite</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">coeff</span><span class="o">*</span><span class="n">binomial</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>

    <span class="n">expr</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">binomial</span><span class="p">,</span> <span class="n">rule</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">rule_gamma</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Simplify products of gamma functions further. &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">expr</span><span class="o">.</span><span class="n">is_Atom</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">expr</span>

        <span class="k">def</span> <span class="nf">gamma_rat</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="c1"># helper to simplify ratios of gammas</span>
            <span class="n">was</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">gamma</span><span class="p">)</span>
            <span class="n">xx</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">gamma</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">_rf</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">expand</span><span class="p">()</span>
                <span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">_rf</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">gamma</span><span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">)</span><span class="o">/</span><span class="n">gamma</span><span class="p">(</span><span class="n">a</span><span class="p">)))</span>
            <span class="k">if</span> <span class="n">xx</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">gamma</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">was</span><span class="p">:</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">xx</span>
            <span class="k">return</span> <span class="n">x</span>

        <span class="k">def</span> <span class="nf">gamma_factor</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="c1"># return True if there is a gamma factor in shallow args</span>
            <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">func</span> <span class="ow">is</span> <span class="n">gamma</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">True</span>
            <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">is_Add</span> <span class="ow">or</span> <span class="n">x</span><span class="o">.</span><span class="n">is_Mul</span><span class="p">:</span>
                <span class="k">return</span> <span class="nb">any</span><span class="p">(</span><span class="n">gamma_factor</span><span class="p">(</span><span class="n">xi</span><span class="p">)</span> <span class="k">for</span> <span class="n">xi</span> <span class="ow">in</span> <span class="n">x</span><span class="o">.</span><span class="n">args</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">is_Pow</span> <span class="ow">and</span> <span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">exp</span><span class="o">.</span><span class="n">is_integer</span> <span class="ow">or</span> <span class="n">x</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">is_positive</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">gamma_factor</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">base</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">False</span>

        <span class="c1"># recursion step</span>
        <span class="k">if</span> <span class="n">level</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">expr</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">rule_gamma</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">level</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">expr</span><span class="o">.</span><span class="n">args</span><span class="p">])</span>
            <span class="n">level</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">expr</span><span class="o">.</span><span class="n">is_Mul</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">expr</span>

        <span class="c1"># non-commutative step</span>
        <span class="k">if</span> <span class="n">level</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">args</span><span class="p">,</span> <span class="n">nc</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">args_cnc</span><span class="p">()</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">args</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">expr</span>
            <span class="k">if</span> <span class="n">nc</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">rule_gamma</span><span class="p">(</span><span class="n">Mul</span><span class="o">.</span><span class="n">_from_args</span><span class="p">(</span><span class="n">args</span><span class="p">),</span> <span class="n">level</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">Mul</span><span class="o">.</span><span class="n">_from_args</span><span class="p">(</span><span class="n">nc</span><span class="p">)</span>
            <span class="n">level</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="c1"># pure gamma handling, not factor absorbtion</span>
        <span class="k">if</span> <span class="n">level</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">sifted</span> <span class="o">=</span> <span class="n">sift</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">args</span><span class="p">,</span> <span class="n">gamma_factor</span><span class="p">)</span>
            <span class="n">gamma_ind</span> <span class="o">=</span> <span class="n">Mul</span><span class="p">(</span><span class="o">*</span><span class="n">sifted</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="bp">False</span><span class="p">,</span> <span class="p">[]))</span>
            <span class="n">d</span> <span class="o">=</span> <span class="n">Mul</span><span class="p">(</span><span class="o">*</span><span class="n">sifted</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="bp">True</span><span class="p">,</span> <span class="p">[]))</span>
            <span class="k">assert</span> <span class="ow">not</span> <span class="n">sifted</span>

            <span class="n">nd</span><span class="p">,</span> <span class="n">dd</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">as_numer_denom</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">ipass</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
                <span class="n">args</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">ordered</span><span class="p">(</span><span class="n">Mul</span><span class="o">.</span><span class="n">make_args</span><span class="p">(</span><span class="n">nd</span><span class="p">)))</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">ni</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">args</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">ni</span><span class="o">.</span><span class="n">is_Add</span><span class="p">:</span>
                        <span class="n">ni</span><span class="p">,</span> <span class="n">dd</span> <span class="o">=</span> <span class="n">Add</span><span class="p">(</span><span class="o">*</span><span class="p">[</span>
                            <span class="n">rule_gamma</span><span class="p">(</span><span class="n">gamma_rat</span><span class="p">(</span><span class="n">a</span><span class="o">/</span><span class="n">dd</span><span class="p">),</span> <span class="n">level</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">ni</span><span class="o">.</span><span class="n">args</span><span class="p">]</span>
                            <span class="p">)</span><span class="o">.</span><span class="n">as_numer_denom</span><span class="p">()</span>
                        <span class="n">args</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">ni</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="n">dd</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">gamma</span><span class="p">):</span>
                            <span class="k">break</span>
                <span class="n">nd</span> <span class="o">=</span> <span class="n">Mul</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">ipass</span> <span class="o">==</span>  <span class="mi">0</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">gamma_factor</span><span class="p">(</span><span class="n">nd</span><span class="p">):</span>
                    <span class="k">break</span>
                <span class="n">nd</span><span class="p">,</span> <span class="n">dd</span> <span class="o">=</span> <span class="n">dd</span><span class="p">,</span> <span class="n">nd</span>  <span class="c1"># now process in reversed order</span>
            <span class="n">expr</span> <span class="o">=</span> <span class="n">gamma_ind</span><span class="o">*</span><span class="n">nd</span><span class="o">/</span><span class="n">dd</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">is_Mul</span> <span class="ow">and</span> <span class="p">(</span><span class="n">gamma_factor</span><span class="p">(</span><span class="n">dd</span><span class="p">)</span> <span class="ow">or</span> <span class="n">gamma_factor</span><span class="p">(</span><span class="n">nd</span><span class="p">))):</span>
                <span class="k">return</span> <span class="n">expr</span>
            <span class="n">level</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="c1"># iteration until constant</span>
        <span class="k">if</span> <span class="n">level</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
                <span class="n">was</span> <span class="o">=</span> <span class="n">expr</span>
                <span class="n">expr</span> <span class="o">=</span> <span class="n">rule_gamma</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">expr</span> <span class="o">==</span> <span class="n">was</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">expr</span>

        <span class="n">numer_gammas</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">denom_gammas</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">numer_others</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">denom_others</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">def</span> <span class="nf">explicate</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">p</span> <span class="ow">is</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">None</span><span class="p">,</span> <span class="p">[]</span>
            <span class="n">b</span><span class="p">,</span> <span class="n">e</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">as_base_exp</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">e</span><span class="o">.</span><span class="n">is_Integer</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">b</span><span class="o">.</span><span class="n">func</span> <span class="ow">is</span> <span class="n">gamma</span><span class="p">:</span>
                    <span class="k">return</span> <span class="bp">True</span><span class="p">,</span> <span class="p">[</span><span class="n">b</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">*</span><span class="n">e</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="bp">False</span><span class="p">,</span> <span class="p">[</span><span class="n">b</span><span class="p">]</span><span class="o">*</span><span class="n">e</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">False</span><span class="p">,</span> <span class="p">[</span><span class="n">p</span><span class="p">]</span>

        <span class="n">newargs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">ordered</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">args</span><span class="p">))</span>
        <span class="k">while</span> <span class="n">newargs</span><span class="p">:</span>
            <span class="n">n</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="n">newargs</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span><span class="o">.</span><span class="n">as_numer_denom</span><span class="p">()</span>
            <span class="n">isg</span><span class="p">,</span> <span class="n">l</span> <span class="o">=</span> <span class="n">explicate</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">isg</span><span class="p">:</span>
                <span class="n">numer_gammas</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">isg</span> <span class="ow">is</span> <span class="bp">False</span><span class="p">:</span>
                <span class="n">numer_others</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>
            <span class="n">isg</span><span class="p">,</span> <span class="n">l</span> <span class="o">=</span> <span class="n">explicate</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">isg</span><span class="p">:</span>
                <span class="n">denom_gammas</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">isg</span> <span class="ow">is</span> <span class="bp">False</span><span class="p">:</span>
                <span class="n">denom_others</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>

        <span class="c1"># =========== level 2 work: pure gamma manipulation =========</span>

        <span class="c1"># Try to reduce the number of gamma factors by applying the</span>
        <span class="c1"># reflection formula gamma(x)*gamma(1-x) = pi/sin(pi*x)</span>
        <span class="k">for</span> <span class="n">gammas</span><span class="p">,</span> <span class="n">numer</span><span class="p">,</span> <span class="n">denom</span> <span class="ow">in</span> <span class="p">[(</span>
            <span class="n">numer_gammas</span><span class="p">,</span> <span class="n">numer_others</span><span class="p">,</span> <span class="n">denom_others</span><span class="p">),</span>
                <span class="p">(</span><span class="n">denom_gammas</span><span class="p">,</span> <span class="n">denom_others</span><span class="p">,</span> <span class="n">numer_others</span><span class="p">)]:</span>
            <span class="n">new</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">while</span> <span class="n">gammas</span><span class="p">:</span>
                <span class="n">g1</span> <span class="o">=</span> <span class="n">gammas</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">g1</span><span class="o">.</span><span class="n">is_integer</span><span class="p">:</span>
                    <span class="n">new</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">g1</span><span class="p">)</span>
                    <span class="k">continue</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">g2</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">gammas</span><span class="p">):</span>
                    <span class="n">n</span> <span class="o">=</span> <span class="n">g1</span> <span class="o">+</span> <span class="n">g2</span> <span class="o">-</span> <span class="mi">1</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">n</span><span class="o">.</span><span class="n">is_Integer</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="n">numer</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">Pi</span><span class="p">)</span>
                    <span class="n">denom</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sin</span><span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">Pi</span><span class="o">*</span><span class="n">g1</span><span class="p">))</span>
                    <span class="n">gammas</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
                            <span class="n">numer</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">g1</span> <span class="o">+</span> <span class="n">k</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="n">n</span><span class="p">):</span>
                            <span class="n">denom</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="o">-</span><span class="n">g1</span> <span class="o">-</span> <span class="n">k</span><span class="p">)</span>
                    <span class="k">break</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">new</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">g1</span><span class="p">)</span>
            <span class="c1"># /!\ updating IN PLACE</span>
            <span class="n">gammas</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">new</span>

        <span class="c1"># Try to reduce the number of gammas by using the duplication</span>
        <span class="c1"># theorem to cancel an upper and lower: gamma(2*s)/gamma(s) =</span>
        <span class="c1"># 2**(2*s + 1)/(4*sqrt(pi))*gamma(s + 1/2). Although this could</span>
        <span class="c1"># be done with higher argument ratios like gamma(3*x)/gamma(x),</span>
        <span class="c1"># this would not reduce the number of gammas as in this case.</span>
        <span class="k">for</span> <span class="n">ng</span><span class="p">,</span> <span class="n">dg</span><span class="p">,</span> <span class="n">no</span><span class="p">,</span> <span class="n">do</span> <span class="ow">in</span> <span class="p">[(</span><span class="n">numer_gammas</span><span class="p">,</span> <span class="n">denom_gammas</span><span class="p">,</span> <span class="n">numer_others</span><span class="p">,</span>
                                <span class="n">denom_others</span><span class="p">),</span>
                               <span class="p">(</span><span class="n">denom_gammas</span><span class="p">,</span> <span class="n">numer_gammas</span><span class="p">,</span> <span class="n">denom_others</span><span class="p">,</span>
                                <span class="n">numer_others</span><span class="p">)]:</span>

            <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">ng</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">dg</span><span class="p">:</span>
                        <span class="n">n</span> <span class="o">=</span> <span class="n">x</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">y</span>
                        <span class="k">if</span> <span class="n">n</span><span class="o">.</span><span class="n">is_Integer</span><span class="p">:</span>
                            <span class="k">break</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="k">break</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">break</span>
                <span class="n">ng</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
                <span class="n">dg</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
                        <span class="n">no</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">y</span> <span class="o">+</span> <span class="n">k</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="n">n</span><span class="p">):</span>
                        <span class="n">do</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">y</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">k</span><span class="p">)</span>
                <span class="n">ng</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">y</span> <span class="o">+</span> <span class="n">S</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
                <span class="n">no</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">y</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
                <span class="n">do</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sqrt</span><span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">Pi</span><span class="p">))</span>

        <span class="c1"># Try to reduce the number of gamma factors by applying the</span>
        <span class="c1"># multiplication theorem (used when n gammas with args differing</span>
        <span class="c1"># by 1/n mod 1 are encountered).</span>
        <span class="c1">#</span>
        <span class="c1"># run of 2 with args differing by 1/2</span>
        <span class="c1">#</span>
        <span class="c1"># &gt;&gt;&gt; combsimp(gamma(x)*gamma(x+S.Half))</span>
        <span class="c1"># 2*sqrt(2)*2**(-2*x - 1/2)*sqrt(pi)*gamma(2*x)</span>
        <span class="c1">#</span>
        <span class="c1"># run of 3 args differing by 1/3 (mod 1)</span>
        <span class="c1">#</span>
        <span class="c1"># &gt;&gt;&gt; combsimp(gamma(x)*gamma(x+S(1)/3)*gamma(x+S(2)/3))</span>
        <span class="c1"># 6*3**(-3*x - 1/2)*pi*gamma(3*x)</span>
        <span class="c1"># &gt;&gt;&gt; combsimp(gamma(x)*gamma(x+S(1)/3)*gamma(x+S(5)/3))</span>
        <span class="c1"># 2*3**(-3*x - 1/2)*pi*(3*x + 2)*gamma(3*x)</span>
        <span class="c1">#</span>
        <span class="k">def</span> <span class="nf">_run</span><span class="p">(</span><span class="n">coeffs</span><span class="p">):</span>
            <span class="c1"># find runs in coeffs such that the difference in terms (mod 1)</span>
            <span class="c1"># of t1, t2, ..., tn is 1/n</span>
            <span class="n">u</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">uniq</span><span class="p">(</span><span class="n">coeffs</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">u</span><span class="p">)):</span>
                <span class="n">dj</span> <span class="o">=</span> <span class="p">([((</span><span class="n">u</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">-</span> <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">%</span> <span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">u</span><span class="p">))])</span>
                <span class="k">for</span> <span class="n">one</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">dj</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">one</span><span class="o">.</span><span class="n">p</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">one</span><span class="o">.</span><span class="n">q</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">n</span> <span class="o">=</span> <span class="n">one</span><span class="o">.</span><span class="n">q</span>
                        <span class="n">got</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span><span class="p">]</span>
                        <span class="n">get</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span>
                        <span class="k">for</span> <span class="n">d</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">dj</span><span class="p">:</span>
                            <span class="n">m</span> <span class="o">=</span> <span class="n">n</span><span class="o">*</span><span class="n">d</span>
                            <span class="k">if</span> <span class="n">m</span><span class="o">.</span><span class="n">is_Integer</span> <span class="ow">and</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">get</span><span class="p">:</span>
                                <span class="n">get</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
                                <span class="n">got</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
                                <span class="k">if</span> <span class="ow">not</span> <span class="n">get</span><span class="p">:</span>
                                    <span class="k">break</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="k">continue</span>
                        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">got</span><span class="p">):</span>
                            <span class="n">c</span> <span class="o">=</span> <span class="n">u</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                            <span class="n">coeffs</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
                            <span class="n">got</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">c</span>
                        <span class="k">return</span> <span class="n">one</span><span class="o">.</span><span class="n">q</span><span class="p">,</span> <span class="n">got</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">got</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>

        <span class="k">def</span> <span class="nf">_mult_thm</span><span class="p">(</span><span class="n">gammas</span><span class="p">,</span> <span class="n">numer</span><span class="p">,</span> <span class="n">denom</span><span class="p">):</span>
            <span class="c1"># pull off and analyze the leading coefficient from each gamma arg</span>
            <span class="c1"># looking for runs in those Rationals</span>

            <span class="c1"># expr -&gt; coeff + resid -&gt; rats[resid] = coeff</span>
            <span class="n">rats</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">gammas</span><span class="p">:</span>
                <span class="n">c</span><span class="p">,</span> <span class="n">resid</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">as_coeff_Add</span><span class="p">()</span>
                <span class="n">rats</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">resid</span><span class="p">,</span> <span class="p">[])</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>

            <span class="c1"># look for runs in Rationals for each resid</span>
            <span class="n">keys</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">rats</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">default_sort_key</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">resid</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">:</span>
                <span class="n">coeffs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">rats</span><span class="p">[</span><span class="n">resid</span><span class="p">]))</span>
                <span class="n">new</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
                    <span class="n">run</span> <span class="o">=</span> <span class="n">_run</span><span class="p">(</span><span class="n">coeffs</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">run</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                        <span class="k">break</span>

                    <span class="c1"># process the sequence that was found:</span>
                    <span class="c1"># 1) convert all the gamma functions to have the right</span>
                    <span class="c1">#    argument (could be off by an integer)</span>
                    <span class="c1"># 2) append the factors corresponding to the theorem</span>
                    <span class="c1"># 3) append the new gamma function</span>

                    <span class="n">n</span><span class="p">,</span> <span class="n">ui</span><span class="p">,</span> <span class="n">other</span> <span class="o">=</span> <span class="n">run</span>

                    <span class="c1"># (1)</span>
                    <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">other</span><span class="p">:</span>
                        <span class="n">con</span> <span class="o">=</span> <span class="n">resid</span> <span class="o">+</span> <span class="n">u</span> <span class="o">-</span> <span class="mi">1</span>
                        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">u</span> <span class="o">-</span> <span class="n">ui</span><span class="p">)):</span>
                            <span class="n">numer</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">con</span> <span class="o">-</span> <span class="n">k</span><span class="p">)</span>

                    <span class="n">con</span> <span class="o">=</span> <span class="n">n</span><span class="o">*</span><span class="p">(</span><span class="n">resid</span> <span class="o">+</span> <span class="n">ui</span><span class="p">)</span>  <span class="c1"># for (2) and (3)</span>

                    <span class="c1"># (2)</span>
                    <span class="n">numer</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="mi">2</span><span class="o">*</span><span class="n">S</span><span class="o">.</span><span class="n">Pi</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="n">S</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span>
                                 <span class="n">n</span><span class="o">**</span><span class="p">(</span><span class="n">S</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span> <span class="o">-</span> <span class="n">con</span><span class="p">))</span>
                    <span class="c1"># (3)</span>
                    <span class="n">new</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">con</span><span class="p">)</span>

                <span class="c1"># restore resid to coeffs</span>
                <span class="n">rats</span><span class="p">[</span><span class="n">resid</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">resid</span> <span class="o">+</span> <span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">coeffs</span><span class="p">]</span> <span class="o">+</span> <span class="n">new</span>

            <span class="c1"># rebuild the gamma arguments</span>
            <span class="n">g</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">resid</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">:</span>
                <span class="n">g</span> <span class="o">+=</span> <span class="n">rats</span><span class="p">[</span><span class="n">resid</span><span class="p">]</span>
            <span class="c1"># /!\ updating IN PLACE</span>
            <span class="n">gammas</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">g</span>

        <span class="k">for</span> <span class="n">l</span><span class="p">,</span> <span class="n">numer</span><span class="p">,</span> <span class="n">denom</span> <span class="ow">in</span> <span class="p">[(</span><span class="n">numer_gammas</span><span class="p">,</span> <span class="n">numer_others</span><span class="p">,</span> <span class="n">denom_others</span><span class="p">),</span>
                                <span class="p">(</span><span class="n">denom_gammas</span><span class="p">,</span> <span class="n">denom_others</span><span class="p">,</span> <span class="n">numer_others</span><span class="p">)]:</span>
            <span class="n">_mult_thm</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">numer</span><span class="p">,</span> <span class="n">denom</span><span class="p">)</span>

        <span class="c1"># =========== level &gt;= 2 work: factor absorbtion =========</span>

        <span class="k">if</span> <span class="n">level</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="c1"># Try to absorb factors into the gammas: x*gamma(x) -&gt; gamma(x + 1)</span>
            <span class="c1"># and gamma(x)/(x - 1) -&gt; gamma(x - 1)</span>
            <span class="c1"># This code (in particular repeated calls to find_fuzzy) can be very</span>
            <span class="c1"># slow.</span>
            <span class="k">def</span> <span class="nf">find_fuzzy</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">l</span><span class="p">:</span>
                    <span class="k">return</span>
                <span class="n">S1</span><span class="p">,</span> <span class="n">T1</span> <span class="o">=</span> <span class="n">compute_ST</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">l</span><span class="p">:</span>
                    <span class="n">S2</span><span class="p">,</span> <span class="n">T2</span> <span class="o">=</span> <span class="n">inv</span><span class="p">[</span><span class="n">y</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">T1</span> <span class="o">!=</span> <span class="n">T2</span> <span class="ow">or</span> <span class="p">(</span><span class="ow">not</span> <span class="n">S1</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">S2</span><span class="p">)</span> <span class="ow">and</span>
                                    <span class="p">(</span><span class="n">S1</span> <span class="o">!=</span> <span class="nb">set</span><span class="p">()</span> <span class="ow">or</span> <span class="n">S2</span> <span class="o">!=</span> <span class="nb">set</span><span class="p">())):</span>
                        <span class="k">continue</span>
                    <span class="c1"># XXX we want some simplification (e.g. cancel or</span>
                    <span class="c1"># simplify) but no matter what it&#39;s slow.</span>
                    <span class="n">a</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">cancel</span><span class="p">(</span><span class="n">x</span><span class="o">/</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">free_symbols</span><span class="p">)</span>
                    <span class="n">b</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">free_symbols</span><span class="p">)</span>
                    <span class="n">c</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="o">.</span><span class="n">free_symbols</span><span class="p">)</span>
                    <span class="c1"># TODO is there a better heuristic?</span>
                    <span class="k">if</span> <span class="n">a</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="p">(</span><span class="n">b</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">c</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>
                        <span class="k">return</span> <span class="n">y</span>

            <span class="c1"># We thus try to avoid expensive calls by building the following</span>
            <span class="c1"># &quot;invariants&quot;: For every factor or gamma function argument</span>
            <span class="c1">#   - the set of free symbols S</span>
            <span class="c1">#   - the set of functional components T</span>
            <span class="c1"># We will only try to absorb if T1==T2 and (S1 intersect S2 != emptyset</span>
            <span class="c1"># or S1 == S2 == emptyset)</span>
            <span class="n">inv</span> <span class="o">=</span> <span class="p">{}</span>

            <span class="k">def</span> <span class="nf">compute_ST</span><span class="p">(</span><span class="n">expr</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">expr</span> <span class="ow">in</span> <span class="n">inv</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">inv</span><span class="p">[</span><span class="n">expr</span><span class="p">]</span>
                <span class="k">return</span> <span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">free_symbols</span><span class="p">,</span> <span class="n">expr</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">Function</span><span class="p">)</span><span class="o">.</span><span class="n">union</span><span class="p">(</span>
                        <span class="nb">set</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">exp</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">expr</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">Pow</span><span class="p">))))</span>

            <span class="k">def</span> <span class="nf">update_ST</span><span class="p">(</span><span class="n">expr</span><span class="p">):</span>
                <span class="n">inv</span><span class="p">[</span><span class="n">expr</span><span class="p">]</span> <span class="o">=</span> <span class="n">compute_ST</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">expr</span> <span class="ow">in</span> <span class="n">numer_gammas</span> <span class="o">+</span> <span class="n">denom_gammas</span> <span class="o">+</span> <span class="n">numer_others</span> <span class="o">+</span> <span class="n">denom_others</span><span class="p">:</span>
                <span class="n">update_ST</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">gammas</span><span class="p">,</span> <span class="n">numer</span><span class="p">,</span> <span class="n">denom</span> <span class="ow">in</span> <span class="p">[(</span>
                <span class="n">numer_gammas</span><span class="p">,</span> <span class="n">numer_others</span><span class="p">,</span> <span class="n">denom_others</span><span class="p">),</span>
                    <span class="p">(</span><span class="n">denom_gammas</span><span class="p">,</span> <span class="n">denom_others</span><span class="p">,</span> <span class="n">numer_others</span><span class="p">)]:</span>
                <span class="n">new</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">while</span> <span class="n">gammas</span><span class="p">:</span>
                    <span class="n">g</span> <span class="o">=</span> <span class="n">gammas</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                    <span class="n">cont</span> <span class="o">=</span> <span class="bp">True</span>
                    <span class="k">while</span> <span class="n">cont</span><span class="p">:</span>
                        <span class="n">cont</span> <span class="o">=</span> <span class="bp">False</span>
                        <span class="n">y</span> <span class="o">=</span> <span class="n">find_fuzzy</span><span class="p">(</span><span class="n">numer</span><span class="p">,</span> <span class="n">g</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">y</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                            <span class="n">numer</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
                            <span class="k">if</span> <span class="n">y</span> <span class="o">!=</span> <span class="n">g</span><span class="p">:</span>
                                <span class="n">numer</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">y</span><span class="o">/</span><span class="n">g</span><span class="p">)</span>
                                <span class="n">update_ST</span><span class="p">(</span><span class="n">y</span><span class="o">/</span><span class="n">g</span><span class="p">)</span>
                            <span class="n">g</span> <span class="o">+=</span> <span class="mi">1</span>
                            <span class="n">cont</span> <span class="o">=</span> <span class="bp">True</span>
                        <span class="n">y</span> <span class="o">=</span> <span class="n">find_fuzzy</span><span class="p">(</span><span class="n">denom</span><span class="p">,</span> <span class="n">g</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">y</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                            <span class="n">denom</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
                            <span class="k">if</span> <span class="n">y</span> <span class="o">!=</span> <span class="n">g</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                                <span class="n">numer</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">g</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="n">y</span><span class="p">)</span>
                                <span class="n">update_ST</span><span class="p">((</span><span class="n">g</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="n">y</span><span class="p">)</span>
                            <span class="n">g</span> <span class="o">-=</span> <span class="mi">1</span>
                            <span class="n">cont</span> <span class="o">=</span> <span class="bp">True</span>
                    <span class="n">new</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
                <span class="c1"># /!\ updating IN PLACE</span>
                <span class="n">gammas</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">new</span>

        <span class="c1"># =========== rebuild expr ==================================</span>

        <span class="k">return</span> <span class="n">Mul</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">gamma</span><span class="p">(</span><span class="n">g</span><span class="p">)</span> <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">numer_gammas</span><span class="p">])</span> \
            <span class="o">/</span> <span class="n">Mul</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">gamma</span><span class="p">(</span><span class="n">g</span><span class="p">)</span> <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">denom_gammas</span><span class="p">])</span> \
            <span class="o">*</span> <span class="n">Mul</span><span class="p">(</span><span class="o">*</span><span class="n">numer_others</span><span class="p">)</span> <span class="o">/</span> <span class="n">Mul</span><span class="p">(</span><span class="o">*</span><span class="n">denom_others</span><span class="p">)</span>

    <span class="c1"># (for some reason we cannot use Basic.replace in this case)</span>
    <span class="n">was</span> <span class="o">=</span> <span class="n">factor</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
    <span class="n">expr</span> <span class="o">=</span> <span class="n">rule_gamma</span><span class="p">(</span><span class="n">was</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">expr</span> <span class="o">!=</span> <span class="n">was</span><span class="p">:</span>
        <span class="n">expr</span> <span class="o">=</span> <span class="n">factor</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">as_gamma</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">as_factorial</span><span class="p">:</span>
            <span class="n">expr</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">rewrite</span><span class="p">(</span><span class="n">factorial</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">as_binomial</span><span class="p">:</span>
            <span class="n">expr</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">rewrite</span><span class="p">(</span><span class="n">binomial</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">expr</span></div>

<span class="k">class</span> <span class="nc">_rf</span><span class="p">(</span><span class="n">Function</span><span class="p">):</span>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">eval</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">b</span><span class="o">.</span><span class="n">is_Integer</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">b</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span>

            <span class="n">n</span><span class="p">,</span> <span class="n">result</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">b</span><span class="p">),</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span>

            <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
                    <span class="n">result</span> <span class="o">*=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">i</span>

                <span class="k">return</span> <span class="n">result</span>
            <span class="k">elif</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                    <span class="n">result</span> <span class="o">*=</span> <span class="n">a</span> <span class="o">-</span> <span class="n">i</span>

                <span class="k">return</span> <span class="mi">1</span><span class="o">/</span><span class="n">result</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">b</span><span class="o">.</span><span class="n">is_Add</span><span class="p">:</span>
                <span class="n">c</span><span class="p">,</span> <span class="n">_b</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">as_coeff_Add</span><span class="p">()</span>

                <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">is_Integer</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">c</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="k">return</span> <span class="n">_rf</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">_b</span><span class="p">)</span><span class="o">*</span><span class="n">_rf</span><span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">_b</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="n">c</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="k">return</span> <span class="n">_rf</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">_b</span><span class="p">)</span><span class="o">/</span><span class="n">_rf</span><span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">_b</span> <span class="o">+</span> <span class="n">c</span><span class="p">,</span> <span class="o">-</span><span class="n">c</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">is_Add</span><span class="p">:</span>
                <span class="n">c</span><span class="p">,</span> <span class="n">_a</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">as_coeff_Add</span><span class="p">()</span>

                <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">is_Integer</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">c</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="k">return</span> <span class="n">_rf</span><span class="p">(</span><span class="n">_a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span><span class="o">*</span><span class="n">_rf</span><span class="p">(</span><span class="n">_a</span> <span class="o">+</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span><span class="o">/</span><span class="n">_rf</span><span class="p">(</span><span class="n">_a</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="n">c</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="k">return</span> <span class="n">_rf</span><span class="p">(</span><span class="n">_a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span><span class="o">*</span><span class="n">_rf</span><span class="p">(</span><span class="n">_a</span> <span class="o">+</span> <span class="n">c</span><span class="p">,</span> <span class="o">-</span><span class="n">c</span><span class="p">)</span><span class="o">/</span><span class="n">_rf</span><span class="p">(</span><span class="n">_a</span> <span class="o">+</span> <span class="n">b</span> <span class="o">+</span> <span class="n">c</span><span class="p">,</span> <span class="o">-</span><span class="n">c</span><span class="p">)</span>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../../index.html">
              <img class="logo" src="../../../_static/sympylogo.png" alt="Logo"/>
            </a></p><div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../index.html">Documentation overview</a><ul>
  <li><a href="../../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2015 SymPy Development Team.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.4.1</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.7</a>
      
    </div>

    

    
  </body>
</html>