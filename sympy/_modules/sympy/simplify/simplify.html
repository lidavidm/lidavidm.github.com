<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>sympy.simplify.simplify &mdash; SymPy 1.0.1.dev documentation</title>
    
    <link rel="stylesheet" href="../../../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="http://96.sympy-live-tests.appspot.com/static/live-core.css" type="text/css" />
    <link rel="stylesheet" href="http://96.sympy-live-tests.appspot.com/static/live-autocomplete.css" type="text/css" />
    <link rel="stylesheet" href="http://96.sympy-live-tests.appspot.com/static/live-sphinx.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '1.0.1.dev',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="http://96.sympy-live-tests.appspot.com/static/utilities.js"></script>
    <script type="text/javascript" src="http://96.sympy-live-tests.appspot.com/static/external/classy.js"></script>
    <script type="text/javascript" src="http://96.sympy-live-tests.appspot.com/static/live-core.js"></script>
    <script type="text/javascript" src="http://96.sympy-live-tests.appspot.com/static/live-autocomplete.js"></script>
    <script type="text/javascript" src="http://96.sympy-live-tests.appspot.com/static/live-sphinx.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML-full"></script>
    <link rel="shortcut icon" href="../../../_static/sympy-notailtext-favicon.ico"/>
    <link rel="top" title="SymPy 1.0.1.dev documentation" href="../../../index.html" />
    <link rel="up" title="Module code" href="../../index.html" />
   
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head>
  <body role="document">  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for sympy.simplify.simplify</h1><div class="highlight"><pre>
<span></span><span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">print_function</span><span class="p">,</span> <span class="n">division</span>

<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span>

<span class="kn">from</span> <span class="nn">sympy.core</span> <span class="kn">import</span> <span class="p">(</span><span class="n">Basic</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">Add</span><span class="p">,</span> <span class="n">Mul</span><span class="p">,</span> <span class="n">Pow</span><span class="p">,</span>
    <span class="n">Symbol</span><span class="p">,</span> <span class="n">sympify</span><span class="p">,</span> <span class="n">expand_mul</span><span class="p">,</span> <span class="n">expand_func</span><span class="p">,</span>
    <span class="n">Function</span><span class="p">,</span> <span class="n">Dummy</span><span class="p">,</span> <span class="n">Expr</span><span class="p">,</span> <span class="n">factor_terms</span><span class="p">,</span>
    <span class="n">symbols</span><span class="p">,</span> <span class="n">expand_power_exp</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">sympy.core.compatibility</span> <span class="kn">import</span> <span class="p">(</span><span class="n">iterable</span><span class="p">,</span>
    <span class="n">ordered</span><span class="p">,</span> <span class="nb">range</span><span class="p">,</span> <span class="n">as_int</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">sympy.core.numbers</span> <span class="kn">import</span> <span class="n">Float</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">pi</span><span class="p">,</span> <span class="n">Rational</span><span class="p">,</span> <span class="n">Integer</span>
<span class="kn">from</span> <span class="nn">sympy.core.function</span> <span class="kn">import</span> <span class="n">expand_log</span><span class="p">,</span> <span class="n">count_ops</span><span class="p">,</span> <span class="n">_mexpand</span><span class="p">,</span> <span class="n">_coeff_isneg</span>
<span class="kn">from</span> <span class="nn">sympy.core.rules</span> <span class="kn">import</span> <span class="n">Transform</span>
<span class="kn">from</span> <span class="nn">sympy.core.evaluate</span> <span class="kn">import</span> <span class="n">global_evaluate</span>
<span class="kn">from</span> <span class="nn">sympy.functions</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">gamma</span><span class="p">,</span> <span class="n">exp</span><span class="p">,</span> <span class="n">sqrt</span><span class="p">,</span> <span class="n">log</span><span class="p">,</span> <span class="n">exp_polar</span><span class="p">,</span> <span class="n">piecewise_fold</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">sympy.functions.elementary.exponential</span> <span class="kn">import</span> <span class="n">ExpBase</span>
<span class="kn">from</span> <span class="nn">sympy.functions.elementary.hyperbolic</span> <span class="kn">import</span> <span class="n">HyperbolicFunction</span>
<span class="kn">from</span> <span class="nn">sympy.functions.elementary.integers</span> <span class="kn">import</span> <span class="n">ceiling</span>
<span class="kn">from</span> <span class="nn">sympy.functions.elementary.complexes</span> <span class="kn">import</span> <span class="n">unpolarify</span>
<span class="kn">from</span> <span class="nn">sympy.functions.elementary.trigonometric</span> <span class="kn">import</span> <span class="n">TrigonometricFunction</span>
<span class="kn">from</span> <span class="nn">sympy.functions.combinatorial.factorials</span> <span class="kn">import</span> <span class="n">CombinatorialFunction</span>
<span class="kn">from</span> <span class="nn">sympy.functions.special.bessel</span> <span class="kn">import</span> <span class="n">besselj</span><span class="p">,</span> <span class="n">besseli</span><span class="p">,</span> <span class="n">besselk</span><span class="p">,</span> <span class="n">jn</span><span class="p">,</span> <span class="n">bessely</span>

<span class="kn">from</span> <span class="nn">sympy.utilities.iterables</span> <span class="kn">import</span> <span class="n">has_variety</span>

<span class="kn">from</span> <span class="nn">sympy.simplify.radsimp</span> <span class="kn">import</span> <span class="n">radsimp</span><span class="p">,</span> <span class="n">fraction</span>
<span class="kn">from</span> <span class="nn">sympy.simplify.trigsimp</span> <span class="kn">import</span> <span class="n">trigsimp</span><span class="p">,</span> <span class="n">exptrigsimp</span>
<span class="kn">from</span> <span class="nn">sympy.simplify.powsimp</span> <span class="kn">import</span> <span class="n">powsimp</span>
<span class="kn">from</span> <span class="nn">sympy.simplify.cse_opts</span> <span class="kn">import</span> <span class="n">sub_pre</span><span class="p">,</span> <span class="n">sub_post</span>
<span class="kn">from</span> <span class="nn">sympy.simplify.sqrtdenest</span> <span class="kn">import</span> <span class="n">sqrtdenest</span>
<span class="kn">from</span> <span class="nn">sympy.simplify.combsimp</span> <span class="kn">import</span> <span class="n">combsimp</span>

<span class="kn">from</span> <span class="nn">sympy.polys</span> <span class="kn">import</span> <span class="p">(</span><span class="n">together</span><span class="p">,</span> <span class="n">cancel</span><span class="p">,</span> <span class="n">factor</span><span class="p">)</span>


<span class="kn">import</span> <span class="nn">mpmath</span>



<div class="viewcode-block" id="separatevars"><a class="viewcode-back" href="../../../modules/simplify/simplify.html#sympy.simplify.simplify.separatevars">[docs]</a><span class="k">def</span> <span class="nf">separatevars</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">symbols</span><span class="o">=</span><span class="p">[],</span> <span class="nb">dict</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">force</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Separates variables in an expression, if possible.  By</span>
<span class="sd">    default, it separates with respect to all symbols in an</span>
<span class="sd">    expression and collects constant coefficients that are</span>
<span class="sd">    independent of symbols.</span>

<span class="sd">    If dict=True then the separated terms will be returned</span>
<span class="sd">    in a dictionary keyed to their corresponding symbols.</span>
<span class="sd">    By default, all symbols in the expression will appear as</span>
<span class="sd">    keys; if symbols are provided, then all those symbols will</span>
<span class="sd">    be used as keys, and any terms in the expression containing</span>
<span class="sd">    other symbols or non-symbols will be returned keyed to the</span>
<span class="sd">    string &#39;coeff&#39;. (Passing None for symbols will return the</span>
<span class="sd">    expression in a dictionary keyed to &#39;coeff&#39;.)</span>

<span class="sd">    If force=True, then bases of powers will be separated regardless</span>
<span class="sd">    of assumptions on the symbols involved.</span>

<span class="sd">    Notes</span>
<span class="sd">    =====</span>
<span class="sd">    The order of the factors is determined by Mul, so that the</span>
<span class="sd">    separated expressions may not necessarily be grouped together.</span>

<span class="sd">    Although factoring is necessary to separate variables in some</span>
<span class="sd">    expressions, it is not necessary in all cases, so one should not</span>
<span class="sd">    count on the returned factors being factored.</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy.abc import x, y, z, alpha</span>
<span class="sd">    &gt;&gt;&gt; from sympy import separatevars, sin</span>
<span class="sd">    &gt;&gt;&gt; separatevars((x*y)**y)</span>
<span class="sd">    (x*y)**y</span>
<span class="sd">    &gt;&gt;&gt; separatevars((x*y)**y, force=True)</span>
<span class="sd">    x**y*y**y</span>

<span class="sd">    &gt;&gt;&gt; e = 2*x**2*z*sin(y)+2*z*x**2</span>
<span class="sd">    &gt;&gt;&gt; separatevars(e)</span>
<span class="sd">    2*x**2*z*(sin(y) + 1)</span>
<span class="sd">    &gt;&gt;&gt; separatevars(e, symbols=(x, y), dict=True)</span>
<span class="sd">    {&#39;coeff&#39;: 2*z, x: x**2, y: sin(y) + 1}</span>
<span class="sd">    &gt;&gt;&gt; separatevars(e, [x, y, alpha], dict=True)</span>
<span class="sd">    {&#39;coeff&#39;: 2*z, alpha: 1, x: x**2, y: sin(y) + 1}</span>

<span class="sd">    If the expression is not really separable, or is only partially</span>
<span class="sd">    separable, separatevars will do the best it can to separate it</span>
<span class="sd">    by using factoring.</span>

<span class="sd">    &gt;&gt;&gt; separatevars(x + x*y - 3*x**2)</span>
<span class="sd">    -x*(3*x - y - 1)</span>

<span class="sd">    If the expression is not separable then expr is returned unchanged</span>
<span class="sd">    or (if dict=True) then None is returned.</span>

<span class="sd">    &gt;&gt;&gt; eq = 2*x + y*sin(x)</span>
<span class="sd">    &gt;&gt;&gt; separatevars(eq) == eq</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; separatevars(2*x + y*sin(x), symbols=(x, y), dict=True) == None</span>
<span class="sd">    True</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">expr</span> <span class="o">=</span> <span class="n">sympify</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">dict</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_separatevars_dict</span><span class="p">(</span><span class="n">_separatevars</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">force</span><span class="p">),</span> <span class="n">symbols</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_separatevars</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">force</span><span class="p">)</span></div>


<span class="k">def</span> <span class="nf">_separatevars</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">force</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">free_symbols</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">expr</span>
    <span class="c1"># don&#39;t destroy a Mul since much of the work may already be done</span>
    <span class="k">if</span> <span class="n">expr</span><span class="o">.</span><span class="n">is_Mul</span><span class="p">:</span>
        <span class="n">args</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">args</span><span class="p">)</span>
        <span class="n">changed</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">args</span><span class="p">):</span>
            <span class="n">args</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">separatevars</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">force</span><span class="p">)</span>
            <span class="n">changed</span> <span class="o">=</span> <span class="n">changed</span> <span class="ow">or</span> <span class="n">args</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">a</span>
        <span class="k">if</span> <span class="n">changed</span><span class="p">:</span>
            <span class="n">expr</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">expr</span>

    <span class="c1"># get a Pow ready for expansion</span>
    <span class="k">if</span> <span class="n">expr</span><span class="o">.</span><span class="n">is_Pow</span><span class="p">:</span>
        <span class="n">expr</span> <span class="o">=</span> <span class="n">Pow</span><span class="p">(</span><span class="n">separatevars</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">base</span><span class="p">,</span> <span class="n">force</span><span class="o">=</span><span class="n">force</span><span class="p">),</span> <span class="n">expr</span><span class="o">.</span><span class="n">exp</span><span class="p">)</span>

    <span class="c1"># First try other expansion methods</span>
    <span class="n">expr</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="n">mul</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">multinomial</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">force</span><span class="o">=</span><span class="n">force</span><span class="p">)</span>

    <span class="n">_expr</span><span class="p">,</span> <span class="n">reps</span> <span class="o">=</span> <span class="n">posify</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span> <span class="k">if</span> <span class="n">force</span> <span class="k">else</span> <span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="p">{})</span>
    <span class="n">expr</span> <span class="o">=</span> <span class="n">factor</span><span class="p">(</span><span class="n">_expr</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">reps</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">expr</span><span class="o">.</span><span class="n">is_Add</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">expr</span>

    <span class="c1"># Find any common coefficients to pull out</span>
    <span class="n">args</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">args</span><span class="p">)</span>
    <span class="n">commonc</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">args_cnc</span><span class="p">(</span><span class="n">cset</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">warn</span><span class="o">=</span><span class="bp">False</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
        <span class="n">commonc</span> <span class="o">&amp;=</span> <span class="n">i</span><span class="o">.</span><span class="n">args_cnc</span><span class="p">(</span><span class="n">cset</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">warn</span><span class="o">=</span><span class="bp">False</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">commonc</span> <span class="o">=</span> <span class="n">Mul</span><span class="p">(</span><span class="o">*</span><span class="n">commonc</span><span class="p">)</span>
    <span class="n">commonc</span> <span class="o">=</span> <span class="n">commonc</span><span class="o">.</span><span class="n">as_coeff_Mul</span><span class="p">()[</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># ignore constants</span>
    <span class="n">commonc_set</span> <span class="o">=</span> <span class="n">commonc</span><span class="o">.</span><span class="n">args_cnc</span><span class="p">(</span><span class="n">cset</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">warn</span><span class="o">=</span><span class="bp">False</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># remove them</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">args</span><span class="p">):</span>
        <span class="n">c</span><span class="p">,</span> <span class="n">nc</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">args_cnc</span><span class="p">(</span><span class="n">cset</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">warn</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">c</span> <span class="o">-</span> <span class="n">commonc_set</span>
        <span class="n">args</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">Mul</span><span class="p">(</span><span class="o">*</span><span class="n">c</span><span class="p">)</span><span class="o">*</span><span class="n">Mul</span><span class="p">(</span><span class="o">*</span><span class="n">nc</span><span class="p">)</span>
    <span class="n">nonsepar</span> <span class="o">=</span> <span class="n">Add</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">nonsepar</span><span class="o">.</span><span class="n">free_symbols</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">_expr</span> <span class="o">=</span> <span class="n">nonsepar</span>
        <span class="n">_expr</span><span class="p">,</span> <span class="n">reps</span> <span class="o">=</span> <span class="n">posify</span><span class="p">(</span><span class="n">_expr</span><span class="p">)</span> <span class="k">if</span> <span class="n">force</span> <span class="k">else</span> <span class="p">(</span><span class="n">_expr</span><span class="p">,</span> <span class="p">{})</span>
        <span class="n">_expr</span> <span class="o">=</span> <span class="p">(</span><span class="n">factor</span><span class="p">(</span><span class="n">_expr</span><span class="p">))</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">reps</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">_expr</span><span class="o">.</span><span class="n">is_Add</span><span class="p">:</span>
            <span class="n">nonsepar</span> <span class="o">=</span> <span class="n">_expr</span>

    <span class="k">return</span> <span class="n">commonc</span><span class="o">*</span><span class="n">nonsepar</span>


<span class="k">def</span> <span class="nf">_separatevars_dict</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">symbols</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">symbols</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">((</span><span class="n">t</span><span class="o">.</span><span class="n">is_Atom</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">symbols</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;symbols must be Atoms.&quot;</span><span class="p">)</span>
        <span class="n">symbols</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">symbols</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">symbols</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;coeff&#39;</span><span class="p">:</span> <span class="n">expr</span><span class="p">}</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">symbols</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">free_symbols</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">symbols</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">None</span>

    <span class="n">ret</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(((</span><span class="n">i</span><span class="p">,</span> <span class="p">[])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">symbols</span> <span class="o">+</span> <span class="p">[</span><span class="s1">&#39;coeff&#39;</span><span class="p">]))</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">Mul</span><span class="o">.</span><span class="n">make_args</span><span class="p">(</span><span class="n">expr</span><span class="p">):</span>
        <span class="n">expsym</span> <span class="o">=</span> <span class="n">i</span><span class="o">.</span><span class="n">free_symbols</span>
        <span class="n">intersection</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">symbols</span><span class="p">)</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">expsym</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">intersection</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">None</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">intersection</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># There are no symbols, so it is part of the coefficient</span>
            <span class="n">ret</span><span class="p">[</span><span class="s1">&#39;coeff&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ret</span><span class="p">[</span><span class="n">intersection</span><span class="o">.</span><span class="n">pop</span><span class="p">()]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

    <span class="c1"># rebuild</span>
    <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">ret</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">ret</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">Mul</span><span class="p">(</span><span class="o">*</span><span class="n">v</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">ret</span>


<span class="k">def</span> <span class="nf">_is_sum_surds</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
    <span class="n">args</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">args</span> <span class="k">if</span> <span class="n">p</span><span class="o">.</span><span class="n">is_Add</span> <span class="k">else</span> <span class="p">[</span><span class="n">p</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">((</span><span class="n">y</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">is_Rational</span> <span class="ow">and</span> <span class="n">y</span><span class="o">.</span><span class="n">is_real</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">False</span>
    <span class="k">return</span> <span class="bp">True</span>


<div class="viewcode-block" id="posify"><a class="viewcode-back" href="../../../modules/simplify/simplify.html#sympy.simplify.simplify.posify">[docs]</a><span class="k">def</span> <span class="nf">posify</span><span class="p">(</span><span class="n">eq</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return eq (with generic symbols made positive) and a</span>
<span class="sd">    dictionary containing the mapping between the old and new</span>
<span class="sd">    symbols.</span>

<span class="sd">    Any symbol that has positive=None will be replaced with a positive dummy</span>
<span class="sd">    symbol having the same name. This replacement will allow more symbolic</span>
<span class="sd">    processing of expressions, especially those involving powers and</span>
<span class="sd">    logarithms.</span>

<span class="sd">    A dictionary that can be sent to subs to restore eq to its original</span>
<span class="sd">    symbols is also returned.</span>

<span class="sd">    &gt;&gt;&gt; from sympy import posify, Symbol, log, solve</span>
<span class="sd">    &gt;&gt;&gt; from sympy.abc import x</span>
<span class="sd">    &gt;&gt;&gt; posify(x + Symbol(&#39;p&#39;, positive=True) + Symbol(&#39;n&#39;, negative=True))</span>
<span class="sd">    (_x + n + p, {_x: x})</span>

<span class="sd">    &gt;&gt;&gt; eq = 1/x</span>
<span class="sd">    &gt;&gt;&gt; log(eq).expand()</span>
<span class="sd">    log(1/x)</span>
<span class="sd">    &gt;&gt;&gt; log(posify(eq)[0]).expand()</span>
<span class="sd">    -log(_x)</span>
<span class="sd">    &gt;&gt;&gt; p, rep = posify(eq)</span>
<span class="sd">    &gt;&gt;&gt; log(p).expand().subs(rep)</span>
<span class="sd">    -log(x)</span>

<span class="sd">    It is possible to apply the same transformations to an iterable</span>
<span class="sd">    of expressions:</span>

<span class="sd">    &gt;&gt;&gt; eq = x**2 - 4</span>
<span class="sd">    &gt;&gt;&gt; solve(eq, x)</span>
<span class="sd">    [-2, 2]</span>
<span class="sd">    &gt;&gt;&gt; eq_x, reps = posify([eq, x]); eq_x</span>
<span class="sd">    [_x**2 - 4, _x]</span>
<span class="sd">    &gt;&gt;&gt; solve(*eq_x)</span>
<span class="sd">    [2]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">eq</span> <span class="o">=</span> <span class="n">sympify</span><span class="p">(</span><span class="n">eq</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">iterable</span><span class="p">(</span><span class="n">eq</span><span class="p">):</span>
        <span class="n">f</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">eq</span><span class="p">)</span>
        <span class="n">eq</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">eq</span><span class="p">)</span>
        <span class="n">syms</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">eq</span><span class="p">:</span>
            <span class="n">syms</span> <span class="o">=</span> <span class="n">syms</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">Symbol</span><span class="p">))</span>
        <span class="n">reps</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">syms</span><span class="p">:</span>
            <span class="n">reps</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">dict</span><span class="p">((</span><span class="n">v</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">posify</span><span class="p">(</span><span class="n">s</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">()))</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">e</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">eq</span><span class="p">):</span>
            <span class="n">eq</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">reps</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">f</span><span class="p">(</span><span class="n">eq</span><span class="p">),</span> <span class="p">{</span><span class="n">r</span><span class="p">:</span> <span class="n">s</span> <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">reps</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>

    <span class="n">reps</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">([(</span><span class="n">s</span><span class="p">,</span> <span class="n">Dummy</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">positive</span><span class="o">=</span><span class="bp">True</span><span class="p">))</span>
                 <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">eq</span><span class="o">.</span><span class="n">free_symbols</span> <span class="k">if</span> <span class="n">s</span><span class="o">.</span><span class="n">is_positive</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">])</span>
    <span class="n">eq</span> <span class="o">=</span> <span class="n">eq</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">reps</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">eq</span><span class="p">,</span> <span class="p">{</span><span class="n">r</span><span class="p">:</span> <span class="n">s</span> <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">reps</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span></div>


<div class="viewcode-block" id="hypersimp"><a class="viewcode-back" href="../../../modules/simplify/simplify.html#sympy.simplify.simplify.hypersimp">[docs]</a><span class="k">def</span> <span class="nf">hypersimp</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Given combinatorial term f(k) simplify its consecutive term ratio</span>
<span class="sd">       i.e. f(k+1)/f(k).  The input term can be composed of functions and</span>
<span class="sd">       integer sequences which have equivalent representation in terms</span>
<span class="sd">       of gamma special function.</span>

<span class="sd">       The algorithm performs three basic steps:</span>

<span class="sd">       1. Rewrite all functions in terms of gamma, if possible.</span>

<span class="sd">       2. Rewrite all occurrences of gamma in terms of products</span>
<span class="sd">          of gamma and rising factorial with integer,  absolute</span>
<span class="sd">          constant exponent.</span>

<span class="sd">       3. Perform simplification of nested fractions, powers</span>
<span class="sd">          and if the resulting expression is a quotient of</span>
<span class="sd">          polynomials, reduce their total degree.</span>

<span class="sd">       If f(k) is hypergeometric then as result we arrive with a</span>
<span class="sd">       quotient of polynomials of minimal degree. Otherwise None</span>
<span class="sd">       is returned.</span>

<span class="sd">       For more information on the implemented algorithm refer to:</span>

<span class="sd">       1. W. Koepf, Algorithms for m-fold Hypergeometric Summation,</span>
<span class="sd">          Journal of Symbolic Computation (1995) 20, 399-417</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">sympify</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>

    <span class="n">g</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">f</span>

    <span class="n">g</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">rewrite</span><span class="p">(</span><span class="n">gamma</span><span class="p">)</span>
    <span class="n">g</span> <span class="o">=</span> <span class="n">expand_func</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
    <span class="n">g</span> <span class="o">=</span> <span class="n">powsimp</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">combine</span><span class="o">=</span><span class="s1">&#39;exp&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">g</span><span class="o">.</span><span class="n">is_rational_function</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">simplify</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">ratio</span><span class="o">=</span><span class="n">S</span><span class="o">.</span><span class="n">Infinity</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">None</span></div>


<div class="viewcode-block" id="hypersimilar"><a class="viewcode-back" href="../../../modules/simplify/simplify.html#sympy.simplify.simplify.hypersimilar">[docs]</a><span class="k">def</span> <span class="nf">hypersimilar</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns True if &#39;f&#39; and &#39;g&#39; are hyper-similar.</span>

<span class="sd">       Similarity in hypergeometric sense means that a quotient of</span>
<span class="sd">       f(k) and g(k) is a rational function in k.  This procedure</span>
<span class="sd">       is useful in solving recurrence relations.</span>

<span class="sd">       For more information see hypersimp().</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">f</span><span class="p">,</span> <span class="n">g</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">sympify</span><span class="p">,</span> <span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">)))</span>

    <span class="n">h</span> <span class="o">=</span> <span class="p">(</span><span class="n">f</span><span class="o">/</span><span class="n">g</span><span class="p">)</span><span class="o">.</span><span class="n">rewrite</span><span class="p">(</span><span class="n">gamma</span><span class="p">)</span>
    <span class="n">h</span> <span class="o">=</span> <span class="n">h</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="n">func</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">basic</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">h</span><span class="o">.</span><span class="n">is_rational_function</span><span class="p">(</span><span class="n">k</span><span class="p">)</span></div>


<span class="k">def</span> <span class="nf">signsimp</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">evaluate</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Make all Add sub-expressions canonical wrt sign.</span>

<span class="sd">    If an Add subexpression, ``a``, can have a sign extracted,</span>
<span class="sd">    as determined by could_extract_minus_sign, it is replaced</span>
<span class="sd">    with Mul(-1, a, evaluate=False). This allows signs to be</span>
<span class="sd">    extracted from powers and products.</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy import signsimp, exp, symbols</span>
<span class="sd">    &gt;&gt;&gt; from sympy.abc import x, y</span>
<span class="sd">    &gt;&gt;&gt; i = symbols(&#39;i&#39;, odd=True)</span>
<span class="sd">    &gt;&gt;&gt; n = -1 + 1/x</span>
<span class="sd">    &gt;&gt;&gt; n/x/(-n)**2 - 1/n/x</span>
<span class="sd">    (-1 + 1/x)/(x*(1 - 1/x)**2) - 1/(x*(-1 + 1/x))</span>
<span class="sd">    &gt;&gt;&gt; signsimp(_)</span>
<span class="sd">    0</span>
<span class="sd">    &gt;&gt;&gt; x*n + x*-n</span>
<span class="sd">    x*(-1 + 1/x) + x*(1 - 1/x)</span>
<span class="sd">    &gt;&gt;&gt; signsimp(_)</span>
<span class="sd">    0</span>

<span class="sd">    Since powers automatically handle leading signs</span>

<span class="sd">    &gt;&gt;&gt; (-2)**i</span>
<span class="sd">    -2**i</span>

<span class="sd">    signsimp can be used to put the base of a power with an integer</span>
<span class="sd">    exponent into canonical form:</span>

<span class="sd">    &gt;&gt;&gt; n**i</span>
<span class="sd">    (-1 + 1/x)**i</span>

<span class="sd">    By default, signsimp doesn&#39;t leave behind any hollow simplification:</span>
<span class="sd">    if making an Add canonical wrt sign didn&#39;t change the expression, the</span>
<span class="sd">    original Add is restored. If this is not desired then the keyword</span>
<span class="sd">    ``evaluate`` can be set to False:</span>

<span class="sd">    &gt;&gt;&gt; e = exp(y - x)</span>
<span class="sd">    &gt;&gt;&gt; signsimp(e) == e</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; signsimp(e, evaluate=False)</span>
<span class="sd">    exp(-(x - y))</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">evaluate</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">evaluate</span> <span class="o">=</span> <span class="n">global_evaluate</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">expr</span> <span class="o">=</span> <span class="n">sympify</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">Expr</span><span class="p">)</span> <span class="ow">or</span> <span class="n">expr</span><span class="o">.</span><span class="n">is_Atom</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">expr</span>
    <span class="n">e</span> <span class="o">=</span> <span class="n">sub_post</span><span class="p">(</span><span class="n">sub_pre</span><span class="p">(</span><span class="n">expr</span><span class="p">))</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">Expr</span><span class="p">)</span> <span class="ow">or</span> <span class="n">e</span><span class="o">.</span><span class="n">is_Atom</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">e</span>
    <span class="k">if</span> <span class="n">e</span><span class="o">.</span><span class="n">is_Add</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">e</span><span class="o">.</span><span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">signsimp</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">e</span><span class="o">.</span><span class="n">args</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">evaluate</span><span class="p">:</span>
        <span class="n">e</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">xreplace</span><span class="p">({</span><span class="n">m</span><span class="p">:</span> <span class="o">-</span><span class="p">(</span><span class="o">-</span><span class="n">m</span><span class="p">)</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">e</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">Mul</span><span class="p">)</span> <span class="k">if</span> <span class="o">-</span><span class="p">(</span><span class="o">-</span><span class="n">m</span><span class="p">)</span> <span class="o">!=</span> <span class="n">m</span><span class="p">})</span>
    <span class="k">return</span> <span class="n">e</span>


<div class="viewcode-block" id="simplify"><a class="viewcode-back" href="../../../modules/simplify/simplify.html#sympy.simplify.simplify.simplify">[docs]</a><span class="k">def</span> <span class="nf">simplify</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">ratio</span><span class="o">=</span><span class="mf">1.7</span><span class="p">,</span> <span class="n">measure</span><span class="o">=</span><span class="n">count_ops</span><span class="p">,</span> <span class="n">fu</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Simplifies the given expression.</span>

<span class="sd">    Simplification is not a well defined term and the exact strategies</span>
<span class="sd">    this function tries can change in the future versions of SymPy. If</span>
<span class="sd">    your algorithm relies on &quot;simplification&quot; (whatever it is), try to</span>
<span class="sd">    determine what you need exactly  -  is it powsimp()?, radsimp()?,</span>
<span class="sd">    together()?, logcombine()?, or something else? And use this particular</span>
<span class="sd">    function directly, because those are well defined and thus your algorithm</span>
<span class="sd">    will be robust.</span>

<span class="sd">    Nonetheless, especially for interactive use, or when you don&#39;t know</span>
<span class="sd">    anything about the structure of the expression, simplify() tries to apply</span>
<span class="sd">    intelligent heuristics to make the input expression &quot;simpler&quot;.  For</span>
<span class="sd">    example:</span>

<span class="sd">    &gt;&gt;&gt; from sympy import simplify, cos, sin</span>
<span class="sd">    &gt;&gt;&gt; from sympy.abc import x, y</span>
<span class="sd">    &gt;&gt;&gt; a = (x + x**2)/(x*sin(y)**2 + x*cos(y)**2)</span>
<span class="sd">    &gt;&gt;&gt; a</span>
<span class="sd">    (x**2 + x)/(x*sin(y)**2 + x*cos(y)**2)</span>
<span class="sd">    &gt;&gt;&gt; simplify(a)</span>
<span class="sd">    x + 1</span>

<span class="sd">    Note that we could have obtained the same result by using specific</span>
<span class="sd">    simplification functions:</span>

<span class="sd">    &gt;&gt;&gt; from sympy import trigsimp, cancel</span>
<span class="sd">    &gt;&gt;&gt; trigsimp(a)</span>
<span class="sd">    (x**2 + x)/x</span>
<span class="sd">    &gt;&gt;&gt; cancel(_)</span>
<span class="sd">    x + 1</span>

<span class="sd">    In some cases, applying :func:`simplify` may actually result in some more</span>
<span class="sd">    complicated expression. The default ``ratio=1.7`` prevents more extreme</span>
<span class="sd">    cases: if (result length)/(input length) &gt; ratio, then input is returned</span>
<span class="sd">    unmodified.  The ``measure`` parameter lets you specify the function used</span>
<span class="sd">    to determine how complex an expression is.  The function should take a</span>
<span class="sd">    single argument as an expression and return a number such that if</span>
<span class="sd">    expression ``a`` is more complex than expression ``b``, then</span>
<span class="sd">    ``measure(a) &gt; measure(b)``.  The default measure function is</span>
<span class="sd">    :func:`count_ops`, which returns the total number of operations in the</span>
<span class="sd">    expression.</span>

<span class="sd">    For example, if ``ratio=1``, ``simplify`` output can&#39;t be longer</span>
<span class="sd">    than input.</span>

<span class="sd">    ::</span>

<span class="sd">        &gt;&gt;&gt; from sympy import sqrt, simplify, count_ops, oo</span>
<span class="sd">        &gt;&gt;&gt; root = 1/(sqrt(2)+3)</span>

<span class="sd">    Since ``simplify(root)`` would result in a slightly longer expression,</span>
<span class="sd">    root is returned unchanged instead::</span>

<span class="sd">       &gt;&gt;&gt; simplify(root, ratio=1) == root</span>
<span class="sd">       True</span>

<span class="sd">    If ``ratio=oo``, simplify will be applied anyway::</span>

<span class="sd">        &gt;&gt;&gt; count_ops(simplify(root, ratio=oo)) &gt; count_ops(root)</span>
<span class="sd">        True</span>

<span class="sd">    Note that the shortest expression is not necessary the simplest, so</span>
<span class="sd">    setting ``ratio`` to 1 may not be a good idea.</span>
<span class="sd">    Heuristically, the default value ``ratio=1.7`` seems like a reasonable</span>
<span class="sd">    choice.</span>

<span class="sd">    You can easily define your own measure function based on what you feel</span>
<span class="sd">    should represent the &quot;size&quot; or &quot;complexity&quot; of the input expression.  Note</span>
<span class="sd">    that some choices, such as ``lambda expr: len(str(expr))`` may appear to be</span>
<span class="sd">    good metrics, but have other problems (in this case, the measure function</span>
<span class="sd">    may slow down simplify too much for very large expressions).  If you don&#39;t</span>
<span class="sd">    know what a good metric would be, the default, ``count_ops``, is a good</span>
<span class="sd">    one.</span>

<span class="sd">    For example:</span>

<span class="sd">    &gt;&gt;&gt; from sympy import symbols, log</span>
<span class="sd">    &gt;&gt;&gt; a, b = symbols(&#39;a b&#39;, positive=True)</span>
<span class="sd">    &gt;&gt;&gt; g = log(a) + log(b) + log(a)*log(1/b)</span>
<span class="sd">    &gt;&gt;&gt; h = simplify(g)</span>
<span class="sd">    &gt;&gt;&gt; h</span>
<span class="sd">    log(a*b**(-log(a) + 1))</span>
<span class="sd">    &gt;&gt;&gt; count_ops(g)</span>
<span class="sd">    8</span>
<span class="sd">    &gt;&gt;&gt; count_ops(h)</span>
<span class="sd">    5</span>

<span class="sd">    So you can see that ``h`` is simpler than ``g`` using the count_ops metric.</span>
<span class="sd">    However, we may not like how ``simplify`` (in this case, using</span>
<span class="sd">    ``logcombine``) has created the ``b**(log(1/a) + 1)`` term.  A simple way</span>
<span class="sd">    to reduce this would be to give more weight to powers as operations in</span>
<span class="sd">    ``count_ops``.  We can do this by using the ``visual=True`` option:</span>

<span class="sd">    &gt;&gt;&gt; print(count_ops(g, visual=True))</span>
<span class="sd">    2*ADD + DIV + 4*LOG + MUL</span>
<span class="sd">    &gt;&gt;&gt; print(count_ops(h, visual=True))</span>
<span class="sd">    2*LOG + MUL + POW + SUB</span>

<span class="sd">    &gt;&gt;&gt; from sympy import Symbol, S</span>
<span class="sd">    &gt;&gt;&gt; def my_measure(expr):</span>
<span class="sd">    ...     POW = Symbol(&#39;POW&#39;)</span>
<span class="sd">    ...     # Discourage powers by giving POW a weight of 10</span>
<span class="sd">    ...     count = count_ops(expr, visual=True).subs(POW, 10)</span>
<span class="sd">    ...     # Every other operation gets a weight of 1 (the default)</span>
<span class="sd">    ...     count = count.replace(Symbol, type(S.One))</span>
<span class="sd">    ...     return count</span>
<span class="sd">    &gt;&gt;&gt; my_measure(g)</span>
<span class="sd">    8</span>
<span class="sd">    &gt;&gt;&gt; my_measure(h)</span>
<span class="sd">    14</span>
<span class="sd">    &gt;&gt;&gt; 15./8 &gt; 1.7 # 1.7 is the default ratio</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; simplify(g, measure=my_measure)</span>
<span class="sd">    -log(a)*log(b) + log(a) + log(b)</span>

<span class="sd">    Note that because ``simplify()`` internally tries many different</span>
<span class="sd">    simplification strategies and then compares them using the measure</span>
<span class="sd">    function, we get a completely different result that is still different</span>
<span class="sd">    from the input expression by doing this.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">expr</span> <span class="o">=</span> <span class="n">sympify</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">expr</span><span class="o">.</span><span class="n">_eval_simplify</span><span class="p">(</span><span class="n">ratio</span><span class="o">=</span><span class="n">ratio</span><span class="p">,</span> <span class="n">measure</span><span class="o">=</span><span class="n">measure</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
        <span class="k">pass</span>

    <span class="n">original_expr</span> <span class="o">=</span> <span class="n">expr</span> <span class="o">=</span> <span class="n">signsimp</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>

    <span class="kn">from</span> <span class="nn">sympy.simplify.hyperexpand</span> <span class="kn">import</span> <span class="n">hyperexpand</span>
    <span class="kn">from</span> <span class="nn">sympy.functions.special.bessel</span> <span class="kn">import</span> <span class="n">BesselBase</span>
    <span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Sum</span><span class="p">,</span> <span class="n">Product</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">Basic</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">expr</span><span class="o">.</span><span class="n">args</span><span class="p">:</span>  <span class="c1"># XXX: temporary hack</span>
        <span class="k">return</span> <span class="n">expr</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="p">(</span><span class="n">Add</span><span class="p">,</span> <span class="n">Mul</span><span class="p">,</span> <span class="n">Pow</span><span class="p">,</span> <span class="n">ExpBase</span><span class="p">)):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">Function</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="s2">&quot;inverse&quot;</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> \
               <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">expr</span><span class="o">.</span><span class="n">inverse</span><span class="p">(</span><span class="n">argindex</span><span class="o">=</span><span class="mi">1</span><span class="p">)):</span>
                <span class="k">return</span> <span class="n">simplify</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ratio</span><span class="o">=</span><span class="n">ratio</span><span class="p">,</span>
                                <span class="n">measure</span><span class="o">=</span><span class="n">measure</span><span class="p">,</span> <span class="n">fu</span><span class="o">=</span><span class="n">fu</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">expr</span><span class="o">.</span><span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">simplify</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">ratio</span><span class="o">=</span><span class="n">ratio</span><span class="p">,</span> <span class="n">measure</span><span class="o">=</span><span class="n">measure</span><span class="p">,</span> <span class="n">fu</span><span class="o">=</span><span class="n">fu</span><span class="p">)</span>
                         <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">expr</span><span class="o">.</span><span class="n">args</span><span class="p">])</span>

    <span class="c1"># TODO: Apply different strategies, considering expression pattern:</span>
    <span class="c1"># is it a purely rational function? Is there any trigonometric function?...</span>
    <span class="c1"># See also https://github.com/sympy/sympy/pull/185.</span>

    <span class="k">def</span> <span class="nf">shorter</span><span class="p">(</span><span class="o">*</span><span class="n">choices</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Return the choice that has the fewest ops. In case of a tie,</span>
<span class="sd">        the expression listed first is selected.&#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">has_variety</span><span class="p">(</span><span class="n">choices</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">choices</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="nb">min</span><span class="p">(</span><span class="n">choices</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">measure</span><span class="p">)</span>

    <span class="n">expr</span> <span class="o">=</span> <span class="n">bottom_up</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">w</span><span class="p">:</span> <span class="n">w</span><span class="o">.</span><span class="n">normal</span><span class="p">())</span>
    <span class="n">expr</span> <span class="o">=</span> <span class="n">Mul</span><span class="p">(</span><span class="o">*</span><span class="n">powsimp</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span><span class="o">.</span><span class="n">as_content_primitive</span><span class="p">())</span>
    <span class="n">_e</span> <span class="o">=</span> <span class="n">cancel</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
    <span class="n">expr1</span> <span class="o">=</span> <span class="n">shorter</span><span class="p">(</span><span class="n">_e</span><span class="p">,</span> <span class="n">_mexpand</span><span class="p">(</span><span class="n">_e</span><span class="p">)</span><span class="o">.</span><span class="n">cancel</span><span class="p">())</span>  <span class="c1"># issue 6829</span>
    <span class="n">expr2</span> <span class="o">=</span> <span class="n">shorter</span><span class="p">(</span><span class="n">together</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="bp">True</span><span class="p">),</span> <span class="n">together</span><span class="p">(</span><span class="n">expr1</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="bp">True</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">ratio</span> <span class="ow">is</span> <span class="n">S</span><span class="o">.</span><span class="n">Infinity</span><span class="p">:</span>
        <span class="n">expr</span> <span class="o">=</span> <span class="n">expr2</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">expr</span> <span class="o">=</span> <span class="n">shorter</span><span class="p">(</span><span class="n">expr2</span><span class="p">,</span> <span class="n">expr1</span><span class="p">,</span> <span class="n">expr</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">Basic</span><span class="p">):</span>  <span class="c1"># XXX: temporary hack</span>
        <span class="k">return</span> <span class="n">expr</span>

    <span class="n">expr</span> <span class="o">=</span> <span class="n">factor_terms</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">sign</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>

    <span class="c1"># hyperexpand automatically only works on hypergeometric terms</span>
    <span class="n">expr</span> <span class="o">=</span> <span class="n">hyperexpand</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>

    <span class="n">expr</span> <span class="o">=</span> <span class="n">piecewise_fold</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">expr</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">BesselBase</span><span class="p">):</span>
        <span class="n">expr</span> <span class="o">=</span> <span class="n">besselsimp</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">expr</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">TrigonometricFunction</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">fu</span> <span class="ow">or</span> <span class="n">expr</span><span class="o">.</span><span class="n">has</span><span class="p">(</span>
            <span class="n">HyperbolicFunction</span><span class="p">):</span>
        <span class="n">expr</span> <span class="o">=</span> <span class="n">trigsimp</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">expr</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">log</span><span class="p">):</span>
        <span class="n">expr</span> <span class="o">=</span> <span class="n">shorter</span><span class="p">(</span><span class="n">expand_log</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="bp">True</span><span class="p">),</span> <span class="n">logcombine</span><span class="p">(</span><span class="n">expr</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">expr</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">CombinatorialFunction</span><span class="p">,</span> <span class="n">gamma</span><span class="p">):</span>
        <span class="n">expr</span> <span class="o">=</span> <span class="n">combsimp</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">expr</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">Sum</span><span class="p">):</span>
        <span class="n">expr</span> <span class="o">=</span> <span class="n">sum_simplify</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">expr</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">Product</span><span class="p">):</span>
        <span class="n">expr</span> <span class="o">=</span> <span class="n">product_simplify</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>

    <span class="n">short</span> <span class="o">=</span> <span class="n">shorter</span><span class="p">(</span><span class="n">powsimp</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">combine</span><span class="o">=</span><span class="s1">&#39;exp&#39;</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="bp">True</span><span class="p">),</span> <span class="n">powsimp</span><span class="p">(</span><span class="n">expr</span><span class="p">),</span> <span class="n">expr</span><span class="p">)</span>
    <span class="n">short</span> <span class="o">=</span> <span class="n">shorter</span><span class="p">(</span><span class="n">short</span><span class="p">,</span> <span class="n">factor_terms</span><span class="p">(</span><span class="n">short</span><span class="p">),</span> <span class="n">expand_power_exp</span><span class="p">(</span><span class="n">expand_mul</span><span class="p">(</span><span class="n">short</span><span class="p">)))</span>
    <span class="k">if</span> <span class="n">short</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">TrigonometricFunction</span><span class="p">,</span> <span class="n">HyperbolicFunction</span><span class="p">,</span> <span class="n">ExpBase</span><span class="p">):</span>
        <span class="n">short</span> <span class="o">=</span> <span class="n">exptrigsimp</span><span class="p">(</span><span class="n">short</span><span class="p">,</span> <span class="n">simplify</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>

    <span class="c1"># get rid of hollow 2-arg Mul factorization</span>
    <span class="n">hollow_mul</span> <span class="o">=</span> <span class="n">Transform</span><span class="p">(</span>
        <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">Mul</span><span class="p">(</span><span class="o">*</span><span class="n">x</span><span class="o">.</span><span class="n">args</span><span class="p">),</span>
        <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span>
        <span class="n">x</span><span class="o">.</span><span class="n">is_Mul</span> <span class="ow">and</span>
        <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span>
        <span class="n">x</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">is_Number</span> <span class="ow">and</span>
        <span class="n">x</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">is_Add</span> <span class="ow">and</span>
        <span class="n">x</span><span class="o">.</span><span class="n">is_commutative</span><span class="p">)</span>
    <span class="n">expr</span> <span class="o">=</span> <span class="n">short</span><span class="o">.</span><span class="n">xreplace</span><span class="p">(</span><span class="n">hollow_mul</span><span class="p">)</span>

    <span class="n">numer</span><span class="p">,</span> <span class="n">denom</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">as_numer_denom</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">denom</span><span class="o">.</span><span class="n">is_Add</span><span class="p">:</span>
        <span class="n">n</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="n">fraction</span><span class="p">(</span><span class="n">radsimp</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">denom</span><span class="p">,</span> <span class="n">symbolic</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">max_terms</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">n</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span><span class="p">:</span>
            <span class="n">expr</span> <span class="o">=</span> <span class="p">(</span><span class="n">numer</span><span class="o">*</span><span class="n">n</span><span class="p">)</span><span class="o">.</span><span class="n">expand</span><span class="p">()</span><span class="o">/</span><span class="n">d</span>

    <span class="k">if</span> <span class="n">expr</span><span class="o">.</span><span class="n">could_extract_minus_sign</span><span class="p">():</span>
        <span class="n">n</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="n">fraction</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">d</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">expr</span> <span class="o">=</span> <span class="n">signsimp</span><span class="p">(</span><span class="o">-</span><span class="n">n</span><span class="o">/</span><span class="p">(</span><span class="o">-</span><span class="n">d</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">measure</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">ratio</span><span class="o">*</span><span class="n">measure</span><span class="p">(</span><span class="n">original_expr</span><span class="p">):</span>
        <span class="n">expr</span> <span class="o">=</span> <span class="n">original_expr</span>

    <span class="k">return</span> <span class="n">expr</span></div>


<span class="k">def</span> <span class="nf">sum_simplify</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Main function for Sum simplification&quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">sympy.concrete.summations</span> <span class="kn">import</span> <span class="n">Sum</span>

    <span class="n">terms</span> <span class="o">=</span> <span class="n">Add</span><span class="o">.</span><span class="n">make_args</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
    <span class="n">s_t</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># Sum Terms</span>
    <span class="n">o_t</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># Other Terms</span>

    <span class="k">for</span> <span class="n">term</span> <span class="ow">in</span> <span class="n">terms</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">term</span><span class="p">,</span> <span class="n">Mul</span><span class="p">):</span>
            <span class="n">constant</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">other</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">s</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">n_sum_terms</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">term</span><span class="o">.</span><span class="n">args</span><span class="p">)):</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">term</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">Sum</span><span class="p">):</span>
                    <span class="n">s</span> <span class="o">=</span> <span class="n">term</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                    <span class="n">n_sum_terms</span> <span class="o">=</span> <span class="n">n_sum_terms</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="k">elif</span> <span class="n">term</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">is_number</span> <span class="o">==</span> <span class="bp">True</span><span class="p">:</span>
                    <span class="n">constant</span> <span class="o">=</span> <span class="n">constant</span> <span class="o">*</span> <span class="n">term</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">other</span> <span class="o">=</span> <span class="n">other</span> <span class="o">*</span> <span class="n">term</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">other</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">n_sum_terms</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># Insert the constant inside the Sum</span>
                <span class="n">s_t</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Sum</span><span class="p">(</span><span class="n">constant</span> <span class="o">*</span> <span class="n">s</span><span class="o">.</span><span class="n">function</span><span class="p">,</span> <span class="o">*</span><span class="n">s</span><span class="o">.</span><span class="n">limits</span><span class="p">))</span>
            <span class="k">elif</span> <span class="n">other</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">n_sum_terms</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">o_t</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">other</span> <span class="o">*</span> <span class="n">Sum</span><span class="p">(</span><span class="n">constant</span> <span class="o">*</span> <span class="n">s</span><span class="o">.</span><span class="n">function</span><span class="p">,</span> <span class="o">*</span><span class="n">s</span><span class="o">.</span><span class="n">limits</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">o_t</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">term</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">term</span><span class="p">,</span> <span class="n">Sum</span><span class="p">):</span>
            <span class="n">s_t</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">term</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">o_t</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">term</span><span class="p">)</span>

    <span class="n">used</span> <span class="o">=</span> <span class="p">[</span><span class="bp">False</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">s_t</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">method</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">s_term1</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">s_t</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">used</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">s_term2</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">s_t</span><span class="p">):</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">used</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="ow">and</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">j</span><span class="p">:</span>
                        <span class="n">temp</span> <span class="o">=</span> <span class="n">sum_add</span><span class="p">(</span><span class="n">s_term1</span><span class="p">,</span> <span class="n">s_term2</span><span class="p">,</span> <span class="n">method</span><span class="p">)</span>
                        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">temp</span><span class="p">,</span> <span class="n">Sum</span><span class="p">):</span>
                            <span class="n">s_t</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp</span>
                            <span class="n">s_term1</span> <span class="o">=</span> <span class="n">s_t</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                            <span class="n">used</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>

    <span class="n">result</span> <span class="o">=</span> <span class="n">Add</span><span class="p">(</span><span class="o">*</span><span class="n">o_t</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">s_term</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">s_t</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">used</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">Add</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">s_term</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">result</span>


<span class="k">def</span> <span class="nf">sum_add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Helper function for Sum simplification&quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">sympy.concrete.summations</span> <span class="kn">import</span> <span class="n">Sum</span>

    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">limits</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">limits</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">Sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">function</span> <span class="o">+</span> <span class="n">other</span><span class="o">.</span><span class="n">function</span><span class="p">,</span> <span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">limits</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">simplify</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">function</span> <span class="o">-</span> <span class="n">other</span><span class="o">.</span><span class="n">function</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">limits</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">limits</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">limits</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">x1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">limits</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">y1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">limits</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span>
                    <span class="n">j</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">limits</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">x2</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">limits</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">y2</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">limits</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span>

                    <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">j</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">x2</span> <span class="o">==</span> <span class="n">y1</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span>
                            <span class="k">return</span> <span class="n">Sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">function</span><span class="p">,</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">y2</span><span class="p">))</span>
                        <span class="k">elif</span> <span class="n">x1</span> <span class="o">==</span> <span class="n">y2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span>
                            <span class="k">return</span> <span class="n">Sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">function</span><span class="p">,</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">y1</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">Add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">product_simplify</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Main function for Product simplification&quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">sympy.concrete.products</span> <span class="kn">import</span> <span class="n">Product</span>

    <span class="n">terms</span> <span class="o">=</span> <span class="n">Mul</span><span class="o">.</span><span class="n">make_args</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
    <span class="n">p_t</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># Product Terms</span>
    <span class="n">o_t</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># Other Terms</span>

    <span class="k">for</span> <span class="n">term</span> <span class="ow">in</span> <span class="n">terms</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">term</span><span class="p">,</span> <span class="n">Product</span><span class="p">):</span>
            <span class="n">p_t</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">term</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">o_t</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">term</span><span class="p">)</span>

    <span class="n">used</span> <span class="o">=</span> <span class="p">[</span><span class="bp">False</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">p_t</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">method</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">p_term1</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">p_t</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">used</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">p_term2</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">p_t</span><span class="p">):</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">used</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="ow">and</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">j</span><span class="p">:</span>
                        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">product_mul</span><span class="p">(</span><span class="n">p_term1</span><span class="p">,</span> <span class="n">p_term2</span><span class="p">,</span> <span class="n">method</span><span class="p">),</span> <span class="n">Product</span><span class="p">):</span>
                            <span class="n">p_t</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">product_mul</span><span class="p">(</span><span class="n">p_term1</span><span class="p">,</span> <span class="n">p_term2</span><span class="p">,</span> <span class="n">method</span><span class="p">)</span>
                            <span class="n">used</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>

    <span class="n">result</span> <span class="o">=</span> <span class="n">Mul</span><span class="p">(</span><span class="o">*</span><span class="n">o_t</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">p_term</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">p_t</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">used</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">Mul</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">p_term</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">result</span>


<span class="k">def</span> <span class="nf">product_mul</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Helper function for Product simplification&quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">sympy.concrete.products</span> <span class="kn">import</span> <span class="n">Product</span>

    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">limits</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">limits</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">Product</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">function</span> <span class="o">*</span> <span class="n">other</span><span class="o">.</span><span class="n">function</span><span class="p">,</span> <span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">limits</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">simplify</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">function</span> <span class="o">-</span> <span class="n">other</span><span class="o">.</span><span class="n">function</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">limits</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">limits</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">limits</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">x1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">limits</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">y1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">limits</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span>
                    <span class="n">j</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">limits</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">x2</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">limits</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">y2</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">limits</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span>

                    <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">j</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">x2</span> <span class="o">==</span> <span class="n">y1</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span>
                            <span class="k">return</span> <span class="n">Product</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">function</span><span class="p">,</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">y2</span><span class="p">))</span>
                        <span class="k">elif</span> <span class="n">x1</span> <span class="o">==</span> <span class="n">y2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span>
                            <span class="k">return</span> <span class="n">Product</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">function</span><span class="p">,</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">y1</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">Mul</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_nthroot_solve</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">prec</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">     helper function for ``nthroot``</span>
<span class="sd">     It denests ``p**Rational(1, n)`` using its minimal polynomial</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">sympy.polys.numberfields</span> <span class="kn">import</span> <span class="n">_minimal_polynomial_sq</span>
    <span class="kn">from</span> <span class="nn">sympy.solvers</span> <span class="kn">import</span> <span class="n">solve</span>
    <span class="k">while</span> <span class="n">n</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">sqrtdenest</span><span class="p">(</span><span class="n">sqrt</span><span class="p">(</span><span class="n">p</span><span class="p">))</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">n</span> <span class="o">//</span> <span class="mi">2</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">p</span>
    <span class="n">pn</span> <span class="o">=</span> <span class="n">p</span><span class="o">**</span><span class="n">Rational</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">)</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">_minimal_polynomial_sq</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">f</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">None</span>
    <span class="n">sols</span> <span class="o">=</span> <span class="n">solve</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">sol</span> <span class="ow">in</span> <span class="n">sols</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">sol</span> <span class="o">-</span> <span class="n">pn</span><span class="p">)</span><span class="o">.</span><span class="n">n</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mf">1.</span><span class="o">/</span><span class="mi">10</span><span class="o">**</span><span class="n">prec</span><span class="p">:</span>
            <span class="n">sol</span> <span class="o">=</span> <span class="n">sqrtdenest</span><span class="p">(</span><span class="n">sol</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">_mexpand</span><span class="p">(</span><span class="n">sol</span><span class="o">**</span><span class="n">n</span><span class="p">)</span> <span class="o">==</span> <span class="n">p</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">sol</span>


<div class="viewcode-block" id="logcombine"><a class="viewcode-back" href="../../../modules/simplify/simplify.html#sympy.simplify.simplify.logcombine">[docs]</a><span class="k">def</span> <span class="nf">logcombine</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">force</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Takes logarithms and combines them using the following rules:</span>

<span class="sd">    - log(x) + log(y) == log(x*y) if both are not negative</span>
<span class="sd">    - a*log(x) == log(x**a) if x is positive and a is real</span>

<span class="sd">    If ``force`` is True then the assumptions above will be assumed to hold if</span>
<span class="sd">    there is no assumption already in place on a quantity. For example, if</span>
<span class="sd">    ``a`` is imaginary or the argument negative, force will not perform a</span>
<span class="sd">    combination but if ``a`` is a symbol with no assumptions the change will</span>
<span class="sd">    take place.</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy import Symbol, symbols, log, logcombine, I</span>
<span class="sd">    &gt;&gt;&gt; from sympy.abc import a, x, y, z</span>
<span class="sd">    &gt;&gt;&gt; logcombine(a*log(x) + log(y) - log(z))</span>
<span class="sd">    a*log(x) + log(y) - log(z)</span>
<span class="sd">    &gt;&gt;&gt; logcombine(a*log(x) + log(y) - log(z), force=True)</span>
<span class="sd">    log(x**a*y/z)</span>
<span class="sd">    &gt;&gt;&gt; x,y,z = symbols(&#39;x,y,z&#39;, positive=True)</span>
<span class="sd">    &gt;&gt;&gt; a = Symbol(&#39;a&#39;, real=True)</span>
<span class="sd">    &gt;&gt;&gt; logcombine(a*log(x) + log(y) - log(z))</span>
<span class="sd">    log(x**a*y/z)</span>

<span class="sd">    The transformation is limited to factors and/or terms that</span>
<span class="sd">    contain logs, so the result depends on the initial state of</span>
<span class="sd">    expansion:</span>

<span class="sd">    &gt;&gt;&gt; eq = (2 + 3*I)*log(x)</span>
<span class="sd">    &gt;&gt;&gt; logcombine(eq, force=True) == eq</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; logcombine(eq.expand(), force=True)</span>
<span class="sd">    log(x**2) + I*log(x**3)</span>

<span class="sd">    See Also</span>
<span class="sd">    ========</span>
<span class="sd">    posify: replace all symbols with symbols having positive assumptions</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">rv</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">rv</span><span class="o">.</span><span class="n">is_Add</span> <span class="ow">or</span> <span class="n">rv</span><span class="o">.</span><span class="n">is_Mul</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">rv</span>

        <span class="k">def</span> <span class="nf">gooda</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
            <span class="c1"># bool to tell whether the leading ``a`` in ``a*log(x)``</span>
            <span class="c1"># could appear as log(x**a)</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">a</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">S</span><span class="o">.</span><span class="n">NegativeOne</span> <span class="ow">and</span>  <span class="c1"># -1 *could* go, but we disallow</span>
                <span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">is_real</span> <span class="ow">or</span> <span class="n">force</span> <span class="ow">and</span> <span class="n">a</span><span class="o">.</span><span class="n">is_real</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">False</span><span class="p">))</span>

        <span class="k">def</span> <span class="nf">goodlog</span><span class="p">(</span><span class="n">l</span><span class="p">):</span>
            <span class="c1"># bool to tell whether log ``l``&#39;s argument can combine with others</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">l</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">a</span><span class="o">.</span><span class="n">is_positive</span> <span class="ow">or</span> <span class="n">force</span> <span class="ow">and</span> <span class="n">a</span><span class="o">.</span><span class="n">is_nonpositive</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">False</span>

        <span class="n">other</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">logs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">log1</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">Add</span><span class="o">.</span><span class="n">make_args</span><span class="p">(</span><span class="n">rv</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">func</span> <span class="ow">is</span> <span class="n">log</span> <span class="ow">and</span> <span class="n">goodlog</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
                <span class="n">log1</span><span class="p">[()]</span><span class="o">.</span><span class="n">append</span><span class="p">(([],</span> <span class="n">a</span><span class="p">))</span>
            <span class="k">elif</span> <span class="ow">not</span> <span class="n">a</span><span class="o">.</span><span class="n">is_Mul</span><span class="p">:</span>
                <span class="n">other</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ot</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">co</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">lo</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">ai</span> <span class="ow">in</span> <span class="n">a</span><span class="o">.</span><span class="n">args</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">ai</span><span class="o">.</span><span class="n">is_Rational</span> <span class="ow">and</span> <span class="n">ai</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">ot</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">NegativeOne</span><span class="p">)</span>
                        <span class="n">co</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="o">-</span><span class="n">ai</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="n">ai</span><span class="o">.</span><span class="n">func</span> <span class="ow">is</span> <span class="n">log</span> <span class="ow">and</span> <span class="n">goodlog</span><span class="p">(</span><span class="n">ai</span><span class="p">):</span>
                        <span class="n">lo</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ai</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="n">gooda</span><span class="p">(</span><span class="n">ai</span><span class="p">):</span>
                        <span class="n">co</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ai</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">ot</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ai</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">lo</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">logs</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">ot</span><span class="p">,</span> <span class="n">co</span><span class="p">,</span> <span class="n">lo</span><span class="p">))</span>
                <span class="k">elif</span> <span class="n">lo</span><span class="p">:</span>
                    <span class="n">log1</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">ot</span><span class="p">)]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">co</span><span class="p">,</span> <span class="n">lo</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">other</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>

        <span class="c1"># if there is only one log at each coefficient and none have</span>
        <span class="c1"># an exponent to place inside the log then there is nothing to do</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">logs</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">log1</span><span class="p">[</span><span class="n">k</span><span class="p">])</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">log1</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="p">[]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">log1</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">rv</span>

        <span class="c1"># collapse multi-logs as far as possible in a canonical way</span>
        <span class="c1"># TODO: see if x*log(a)+x*log(a)*log(b) -&gt; x*log(a)*(1+log(b))?</span>
        <span class="c1"># -- in this case, it&#39;s unambiguous, but if it were were a log(c) in</span>
        <span class="c1"># each term then it&#39;s arbitrary whether they are grouped by log(a) or</span>
        <span class="c1"># by log(c). So for now, just leave this alone; it&#39;s probably better to</span>
        <span class="c1"># let the user decide</span>
        <span class="k">for</span> <span class="n">o</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">logs</span><span class="p">:</span>
            <span class="n">l</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">ordered</span><span class="p">(</span><span class="n">l</span><span class="p">))</span>
            <span class="n">e</span> <span class="o">=</span> <span class="n">log</span><span class="p">(</span><span class="n">l</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="n">Mul</span><span class="p">(</span><span class="o">*</span><span class="n">e</span><span class="p">))</span>
            <span class="k">while</span> <span class="n">l</span><span class="p">:</span>
                <span class="n">li</span> <span class="o">=</span> <span class="n">l</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">e</span> <span class="o">=</span> <span class="n">log</span><span class="p">(</span><span class="n">li</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="n">e</span><span class="p">)</span>
            <span class="n">c</span><span class="p">,</span> <span class="n">l</span> <span class="o">=</span> <span class="n">Mul</span><span class="p">(</span><span class="o">*</span><span class="n">o</span><span class="p">),</span> <span class="n">e</span>
            <span class="k">if</span> <span class="n">l</span><span class="o">.</span><span class="n">func</span> <span class="ow">is</span> <span class="n">log</span><span class="p">:</span>  <span class="c1"># it should be, but check to be sure</span>
                <span class="n">log1</span><span class="p">[(</span><span class="n">c</span><span class="p">,)]</span><span class="o">.</span><span class="n">append</span><span class="p">(([],</span> <span class="n">l</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">other</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c</span><span class="o">*</span><span class="n">l</span><span class="p">)</span>

        <span class="c1"># logs that have the same coefficient can multiply</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">log1</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
            <span class="n">log1</span><span class="p">[</span><span class="n">Mul</span><span class="p">(</span><span class="o">*</span><span class="n">k</span><span class="p">)]</span> <span class="o">=</span> <span class="n">log</span><span class="p">(</span><span class="n">logcombine</span><span class="p">(</span><span class="n">Mul</span><span class="p">(</span><span class="o">*</span><span class="p">[</span>
                <span class="n">l</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="n">Mul</span><span class="p">(</span><span class="o">*</span><span class="n">c</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span><span class="p">,</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">log1</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">k</span><span class="p">)]),</span>
                <span class="n">force</span><span class="o">=</span><span class="n">force</span><span class="p">))</span>

        <span class="c1"># logs that have oppositely signed coefficients can divide</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">ordered</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">log1</span><span class="o">.</span><span class="n">keys</span><span class="p">())):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">log1</span><span class="p">:</span>  <span class="c1"># already popped as -k</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="o">-</span><span class="n">k</span> <span class="ow">in</span> <span class="n">log1</span><span class="p">:</span>
                <span class="c1"># figure out which has the minus sign; the one with</span>
                <span class="c1"># more op counts should be the one</span>
                <span class="n">num</span><span class="p">,</span> <span class="n">den</span> <span class="o">=</span> <span class="n">k</span><span class="p">,</span> <span class="o">-</span><span class="n">k</span>
                <span class="k">if</span> <span class="n">num</span><span class="o">.</span><span class="n">count_ops</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">den</span><span class="o">.</span><span class="n">count_ops</span><span class="p">():</span>
                    <span class="n">num</span><span class="p">,</span> <span class="n">den</span> <span class="o">=</span> <span class="n">den</span><span class="p">,</span> <span class="n">num</span>
                <span class="n">other</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">num</span><span class="o">*</span><span class="n">log</span><span class="p">(</span><span class="n">log1</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">num</span><span class="p">)</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="n">log1</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">den</span><span class="p">)</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">other</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">k</span><span class="o">*</span><span class="n">log1</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">k</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">Add</span><span class="p">(</span><span class="o">*</span><span class="n">other</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">bottom_up</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span></div>


<span class="k">def</span> <span class="nf">bottom_up</span><span class="p">(</span><span class="n">rv</span><span class="p">,</span> <span class="n">F</span><span class="p">,</span> <span class="n">atoms</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">nonbasic</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Apply ``F`` to all expressions in an expression tree from the</span>
<span class="sd">    bottom up. If ``atoms`` is True, apply ``F`` even if there are no args;</span>
<span class="sd">    if ``nonbasic`` is True, try to apply ``F`` to non-Basic objects.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">rv</span><span class="o">.</span><span class="n">args</span><span class="p">:</span>
            <span class="n">args</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">bottom_up</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">F</span><span class="p">,</span> <span class="n">atoms</span><span class="p">,</span> <span class="n">nonbasic</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">rv</span><span class="o">.</span><span class="n">args</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">args</span> <span class="o">!=</span> <span class="n">rv</span><span class="o">.</span><span class="n">args</span><span class="p">:</span>
                <span class="n">rv</span> <span class="o">=</span> <span class="n">rv</span><span class="o">.</span><span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
            <span class="n">rv</span> <span class="o">=</span> <span class="n">F</span><span class="p">(</span><span class="n">rv</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">atoms</span><span class="p">:</span>
            <span class="n">rv</span> <span class="o">=</span> <span class="n">F</span><span class="p">(</span><span class="n">rv</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">nonbasic</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">rv</span> <span class="o">=</span> <span class="n">F</span><span class="p">(</span><span class="n">rv</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                <span class="k">pass</span>

    <span class="k">return</span> <span class="n">rv</span>


<div class="viewcode-block" id="besselsimp"><a class="viewcode-back" href="../../../modules/simplify/simplify.html#sympy.simplify.simplify.besselsimp">[docs]</a><span class="k">def</span> <span class="nf">besselsimp</span><span class="p">(</span><span class="n">expr</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Simplify bessel-type functions.</span>

<span class="sd">    This routine tries to simplify bessel-type functions. Currently it only</span>
<span class="sd">    works on the Bessel J and I functions, however. It works by looking at all</span>
<span class="sd">    such functions in turn, and eliminating factors of &quot;I&quot; and &quot;-1&quot; (actually</span>
<span class="sd">    their polar equivalents) in front of the argument. Then, functions of</span>
<span class="sd">    half-integer order are rewritten using strigonometric functions and</span>
<span class="sd">    functions of integer order (&gt; 1) are rewritten using functions</span>
<span class="sd">    of low order.  Finally, if the expression was changed, compute</span>
<span class="sd">    factorization of the result with factor().</span>

<span class="sd">    &gt;&gt;&gt; from sympy import besselj, besseli, besselsimp, polar_lift, I, S</span>
<span class="sd">    &gt;&gt;&gt; from sympy.abc import z, nu</span>
<span class="sd">    &gt;&gt;&gt; besselsimp(besselj(nu, z*polar_lift(-1)))</span>
<span class="sd">    exp(I*pi*nu)*besselj(nu, z)</span>
<span class="sd">    &gt;&gt;&gt; besselsimp(besseli(nu, z*polar_lift(-I)))</span>
<span class="sd">    exp(-I*pi*nu/2)*besselj(nu, z)</span>
<span class="sd">    &gt;&gt;&gt; besselsimp(besseli(S(-1)/2, z))</span>
<span class="sd">    sqrt(2)*cosh(z)/(sqrt(pi)*sqrt(z))</span>
<span class="sd">    &gt;&gt;&gt; besselsimp(z*besseli(0, z) + z*(besseli(2, z))/2 + besseli(1, z))</span>
<span class="sd">    3*z*besseli(0, z)/2</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># TODO</span>
    <span class="c1"># - better algorithm?</span>
    <span class="c1"># - simplify (cos(pi*b)*besselj(b,z) - besselj(-b,z))/sin(pi*b) ...</span>
    <span class="c1"># - use contiguity relations?</span>

    <span class="k">def</span> <span class="nf">replacer</span><span class="p">(</span><span class="n">fro</span><span class="p">,</span> <span class="n">to</span><span class="p">,</span> <span class="n">factors</span><span class="p">):</span>
        <span class="n">factors</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">factors</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">repl</span><span class="p">(</span><span class="n">nu</span><span class="p">,</span> <span class="n">z</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">factors</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">Mul</span><span class="o">.</span><span class="n">make_args</span><span class="p">(</span><span class="n">z</span><span class="p">)):</span>
                <span class="k">return</span> <span class="n">to</span><span class="p">(</span><span class="n">nu</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">fro</span><span class="p">(</span><span class="n">nu</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">repl</span>

    <span class="k">def</span> <span class="nf">torewrite</span><span class="p">(</span><span class="n">fro</span><span class="p">,</span> <span class="n">to</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">tofunc</span><span class="p">(</span><span class="n">nu</span><span class="p">,</span> <span class="n">z</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">fro</span><span class="p">(</span><span class="n">nu</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span><span class="o">.</span><span class="n">rewrite</span><span class="p">(</span><span class="n">to</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">tofunc</span>

    <span class="k">def</span> <span class="nf">tominus</span><span class="p">(</span><span class="n">fro</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">tofunc</span><span class="p">(</span><span class="n">nu</span><span class="p">,</span> <span class="n">z</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">exp</span><span class="p">(</span><span class="n">I</span><span class="o">*</span><span class="n">pi</span><span class="o">*</span><span class="n">nu</span><span class="p">)</span><span class="o">*</span><span class="n">fro</span><span class="p">(</span><span class="n">nu</span><span class="p">,</span> <span class="n">exp_polar</span><span class="p">(</span><span class="o">-</span><span class="n">I</span><span class="o">*</span><span class="n">pi</span><span class="p">)</span><span class="o">*</span><span class="n">z</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">tofunc</span>

    <span class="n">orig_expr</span> <span class="o">=</span> <span class="n">expr</span>

    <span class="n">ifactors</span> <span class="o">=</span> <span class="p">[</span><span class="n">I</span><span class="p">,</span> <span class="n">exp_polar</span><span class="p">(</span><span class="n">I</span><span class="o">*</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">),</span> <span class="n">exp_polar</span><span class="p">(</span><span class="o">-</span><span class="n">I</span><span class="o">*</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">)]</span>
    <span class="n">expr</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span>
        <span class="n">besselj</span><span class="p">,</span> <span class="n">replacer</span><span class="p">(</span><span class="n">besselj</span><span class="p">,</span>
        <span class="n">torewrite</span><span class="p">(</span><span class="n">besselj</span><span class="p">,</span> <span class="n">besseli</span><span class="p">),</span> <span class="n">ifactors</span><span class="p">))</span>
    <span class="n">expr</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span>
        <span class="n">besseli</span><span class="p">,</span> <span class="n">replacer</span><span class="p">(</span><span class="n">besseli</span><span class="p">,</span>
        <span class="n">torewrite</span><span class="p">(</span><span class="n">besseli</span><span class="p">,</span> <span class="n">besselj</span><span class="p">),</span> <span class="n">ifactors</span><span class="p">))</span>

    <span class="n">minusfactors</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">exp_polar</span><span class="p">(</span><span class="n">I</span><span class="o">*</span><span class="n">pi</span><span class="p">)]</span>
    <span class="n">expr</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span>
        <span class="n">besselj</span><span class="p">,</span> <span class="n">replacer</span><span class="p">(</span><span class="n">besselj</span><span class="p">,</span> <span class="n">tominus</span><span class="p">(</span><span class="n">besselj</span><span class="p">),</span> <span class="n">minusfactors</span><span class="p">))</span>
    <span class="n">expr</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span>
        <span class="n">besseli</span><span class="p">,</span> <span class="n">replacer</span><span class="p">(</span><span class="n">besseli</span><span class="p">,</span> <span class="n">tominus</span><span class="p">(</span><span class="n">besseli</span><span class="p">),</span> <span class="n">minusfactors</span><span class="p">))</span>

    <span class="n">z0</span> <span class="o">=</span> <span class="n">Dummy</span><span class="p">(</span><span class="s1">&#39;z&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">expander</span><span class="p">(</span><span class="n">fro</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">repl</span><span class="p">(</span><span class="n">nu</span><span class="p">,</span> <span class="n">z</span><span class="p">):</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">nu</span> <span class="o">%</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="n">S</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">exptrigsimp</span><span class="p">(</span><span class="n">trigsimp</span><span class="p">(</span><span class="n">unpolarify</span><span class="p">(</span>
                        <span class="n">fro</span><span class="p">(</span><span class="n">nu</span><span class="p">,</span> <span class="n">z0</span><span class="p">)</span><span class="o">.</span><span class="n">rewrite</span><span class="p">(</span><span class="n">besselj</span><span class="p">)</span><span class="o">.</span><span class="n">rewrite</span><span class="p">(</span><span class="n">jn</span><span class="p">)</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span>
                            <span class="n">func</span><span class="o">=</span><span class="bp">True</span><span class="p">))</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">z0</span><span class="p">,</span> <span class="n">z</span><span class="p">)))</span>
            <span class="k">elif</span> <span class="n">nu</span><span class="o">.</span><span class="n">is_Integer</span> <span class="ow">and</span> <span class="n">nu</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">fro</span><span class="p">(</span><span class="n">nu</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="n">func</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">fro</span><span class="p">(</span><span class="n">nu</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">repl</span>

    <span class="n">expr</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">besselj</span><span class="p">,</span> <span class="n">expander</span><span class="p">(</span><span class="n">besselj</span><span class="p">))</span>
    <span class="n">expr</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">bessely</span><span class="p">,</span> <span class="n">expander</span><span class="p">(</span><span class="n">bessely</span><span class="p">))</span>
    <span class="n">expr</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">besseli</span><span class="p">,</span> <span class="n">expander</span><span class="p">(</span><span class="n">besseli</span><span class="p">))</span>
    <span class="n">expr</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">besselk</span><span class="p">,</span> <span class="n">expander</span><span class="p">(</span><span class="n">besselk</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">expr</span> <span class="o">!=</span> <span class="n">orig_expr</span><span class="p">:</span>
        <span class="n">expr</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">factor</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">expr</span></div>


<div class="viewcode-block" id="nthroot"><a class="viewcode-back" href="../../../modules/simplify/simplify.html#sympy.simplify.simplify.nthroot">[docs]</a><span class="k">def</span> <span class="nf">nthroot</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">max_len</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">prec</span><span class="o">=</span><span class="mi">15</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    compute a real nth-root of a sum of surds</span>

<span class="sd">    Parameters</span>
<span class="sd">    ==========</span>

<span class="sd">    expr : sum of surds</span>
<span class="sd">    n : integer</span>
<span class="sd">    max_len : maximum number of surds passed as constants to ``nsimplify``</span>

<span class="sd">    Algorithm</span>
<span class="sd">    =========</span>

<span class="sd">    First ``nsimplify`` is used to get a candidate root; if it is not a</span>
<span class="sd">    root the minimal polynomial is computed; the answer is one of its</span>
<span class="sd">    roots.</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy.simplify.simplify import nthroot</span>
<span class="sd">    &gt;&gt;&gt; from sympy import Rational, sqrt</span>
<span class="sd">    &gt;&gt;&gt; nthroot(90 + 34*sqrt(7), 3)</span>
<span class="sd">    sqrt(7) + 3</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">expr</span> <span class="o">=</span> <span class="n">sympify</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">sympify</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">expr</span><span class="o">**</span><span class="n">Rational</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">n</span><span class="o">.</span><span class="n">is_integer</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">p</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">_is_sum_surds</span><span class="p">(</span><span class="n">expr</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">p</span>
    <span class="n">surds</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">coeff_muls</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">as_coeff_Mul</span><span class="p">()</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">expr</span><span class="o">.</span><span class="n">args</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">coeff_muls</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">x</span><span class="o">.</span><span class="n">is_rational</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">p</span>
        <span class="k">if</span> <span class="n">y</span> <span class="ow">is</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">y</span><span class="o">.</span><span class="n">is_Pow</span> <span class="ow">and</span> <span class="n">y</span><span class="o">.</span><span class="n">exp</span> <span class="o">==</span> <span class="n">S</span><span class="o">.</span><span class="n">Half</span> <span class="ow">and</span> <span class="n">y</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">is_integer</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">p</span>
        <span class="n">surds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
    <span class="n">surds</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
    <span class="n">surds</span> <span class="o">=</span> <span class="n">surds</span><span class="p">[:</span><span class="n">max_len</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">expr</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">n</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="n">expr</span><span class="p">)</span><span class="o">**</span><span class="n">Rational</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">nsimplify</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">constants</span><span class="o">=</span><span class="n">surds</span><span class="p">)</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">a</span> <span class="k">if</span> <span class="n">_mexpand</span><span class="p">(</span><span class="n">a</span><span class="o">**</span><span class="n">n</span><span class="p">)</span> <span class="o">==</span> <span class="n">_mexpand</span><span class="p">(</span><span class="o">-</span><span class="n">expr</span><span class="p">)</span> <span class="k">else</span> <span class="n">p</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">res</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">nsimplify</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">constants</span><span class="o">=</span><span class="n">surds</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">_mexpand</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">_mexpand</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="ow">and</span> <span class="n">_mexpand</span><span class="p">(</span><span class="n">a</span><span class="o">**</span><span class="n">n</span><span class="p">)</span> <span class="o">==</span> <span class="n">_mexpand</span><span class="p">(</span><span class="n">expr</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">_mexpand</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">expr</span> <span class="o">=</span> <span class="n">_nthroot_solve</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">prec</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">expr</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">p</span>
    <span class="k">return</span> <span class="n">expr</span></div>


<div class="viewcode-block" id="nsimplify"><a class="viewcode-back" href="../../../modules/simplify/simplify.html#sympy.simplify.simplify.nsimplify">[docs]</a><span class="k">def</span> <span class="nf">nsimplify</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">constants</span><span class="o">=</span><span class="p">[],</span> <span class="n">tolerance</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">full</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">rational</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Find a simple representation for a number or, if there are free symbols or</span>
<span class="sd">    if rational=True, then replace Floats with their Rational equivalents. If</span>
<span class="sd">    no change is made and rational is not False then Floats will at least be</span>
<span class="sd">    converted to Rationals.</span>

<span class="sd">    For numerical expressions, a simple formula that numerically matches the</span>
<span class="sd">    given numerical expression is sought (and the input should be possible</span>
<span class="sd">    to evalf to a precision of at least 30 digits).</span>

<span class="sd">    Optionally, a list of (rationally independent) constants to</span>
<span class="sd">    include in the formula may be given.</span>

<span class="sd">    A lower tolerance may be set to find less exact matches. If no tolerance</span>
<span class="sd">    is given then the least precise value will set the tolerance (e.g. Floats</span>
<span class="sd">    default to 15 digits of precision, so would be tolerance=10**-15).</span>

<span class="sd">    With full=True, a more extensive search is performed</span>
<span class="sd">    (this is useful to find simpler numbers when the tolerance</span>
<span class="sd">    is set low).</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy import nsimplify, sqrt, GoldenRatio, exp, I, exp, pi</span>
<span class="sd">    &gt;&gt;&gt; nsimplify(4/(1+sqrt(5)), [GoldenRatio])</span>
<span class="sd">    -2 + 2*GoldenRatio</span>
<span class="sd">    &gt;&gt;&gt; nsimplify((1/(exp(3*pi*I/5)+1)))</span>
<span class="sd">    1/2 - I*sqrt(sqrt(5)/10 + 1/4)</span>
<span class="sd">    &gt;&gt;&gt; nsimplify(I**I, [pi])</span>
<span class="sd">    exp(-pi/2)</span>
<span class="sd">    &gt;&gt;&gt; nsimplify(pi, tolerance=0.01)</span>
<span class="sd">    22/7</span>

<span class="sd">    See Also</span>
<span class="sd">    ========</span>
<span class="sd">    sympy.core.function.nfloat</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">sympify</span><span class="p">(</span><span class="n">as_int</span><span class="p">(</span><span class="n">expr</span><span class="p">))</span>
    <span class="k">except</span> <span class="p">(</span><span class="ne">TypeError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">):</span>
        <span class="k">pass</span>
    <span class="n">expr</span> <span class="o">=</span> <span class="n">sympify</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span><span class="o">.</span><span class="n">xreplace</span><span class="p">({</span>
        <span class="n">Float</span><span class="p">(</span><span class="s1">&#39;inf&#39;</span><span class="p">):</span> <span class="n">S</span><span class="o">.</span><span class="n">Infinity</span><span class="p">,</span>
        <span class="n">Float</span><span class="p">(</span><span class="s1">&#39;-inf&#39;</span><span class="p">):</span> <span class="n">S</span><span class="o">.</span><span class="n">NegativeInfinity</span><span class="p">,</span>
        <span class="p">})</span>
    <span class="k">if</span> <span class="n">expr</span> <span class="ow">is</span> <span class="n">S</span><span class="o">.</span><span class="n">Infinity</span> <span class="ow">or</span> <span class="n">expr</span> <span class="ow">is</span> <span class="n">S</span><span class="o">.</span><span class="n">NegativeInfinity</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">expr</span>
    <span class="k">if</span> <span class="n">rational</span> <span class="ow">or</span> <span class="n">expr</span><span class="o">.</span><span class="n">free_symbols</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_real_to_rational</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">)</span>

    <span class="c1"># SymPy&#39;s default tolerance for Rationals is 15; other numbers may have</span>
    <span class="c1"># lower tolerances set, so use them to pick the largest tolerance if None</span>
    <span class="c1"># was given</span>
    <span class="k">if</span> <span class="n">tolerance</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">tolerance</span> <span class="o">=</span> <span class="mi">10</span><span class="o">**-</span><span class="nb">min</span><span class="p">([</span><span class="mi">15</span><span class="p">]</span> <span class="o">+</span>
             <span class="p">[</span><span class="n">mpmath</span><span class="o">.</span><span class="n">libmp</span><span class="o">.</span><span class="n">libmpf</span><span class="o">.</span><span class="n">prec_to_dps</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">_prec</span><span class="p">)</span>
             <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">expr</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">Float</span><span class="p">)])</span>
    <span class="c1"># XXX should prec be set independent of tolerance or should it be computed</span>
    <span class="c1"># from tolerance?</span>
    <span class="n">prec</span> <span class="o">=</span> <span class="mi">30</span>
    <span class="n">bprec</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">prec</span><span class="o">*</span><span class="mf">3.33</span><span class="p">)</span>

    <span class="n">constants_dict</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">constant</span> <span class="ow">in</span> <span class="n">constants</span><span class="p">:</span>
        <span class="n">constant</span> <span class="o">=</span> <span class="n">sympify</span><span class="p">(</span><span class="n">constant</span><span class="p">)</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">constant</span><span class="o">.</span><span class="n">evalf</span><span class="p">(</span><span class="n">prec</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">v</span><span class="o">.</span><span class="n">is_Float</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;constants must be real-valued&quot;</span><span class="p">)</span>
        <span class="n">constants_dict</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">constant</span><span class="p">)]</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">_to_mpmath</span><span class="p">(</span><span class="n">bprec</span><span class="p">)</span>

    <span class="n">exprval</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">evalf</span><span class="p">(</span><span class="n">prec</span><span class="p">,</span> <span class="n">chop</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="n">re</span><span class="p">,</span> <span class="n">im</span> <span class="o">=</span> <span class="n">exprval</span><span class="o">.</span><span class="n">as_real_imag</span><span class="p">()</span>

    <span class="c1"># safety check to make sure that this evaluated to a number</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">is_Number</span> <span class="ow">and</span> <span class="n">im</span><span class="o">.</span><span class="n">is_Number</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">expr</span>

    <span class="k">def</span> <span class="nf">nsimplify_real</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="n">orig</span> <span class="o">=</span> <span class="n">mpmath</span><span class="o">.</span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span>
        <span class="n">xv</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">_to_mpmath</span><span class="p">(</span><span class="n">bprec</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># We&#39;ll be happy with low precision if a simple fraction</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">tolerance</span> <span class="ow">or</span> <span class="n">full</span><span class="p">):</span>
                <span class="n">mpmath</span><span class="o">.</span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span> <span class="o">=</span> <span class="mi">15</span>
                <span class="n">rat</span> <span class="o">=</span> <span class="n">mpmath</span><span class="o">.</span><span class="n">pslq</span><span class="p">([</span><span class="n">xv</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">rat</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">Rational</span><span class="p">(</span><span class="o">-</span><span class="nb">int</span><span class="p">(</span><span class="n">rat</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="nb">int</span><span class="p">(</span><span class="n">rat</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
            <span class="n">mpmath</span><span class="o">.</span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span> <span class="o">=</span> <span class="n">prec</span>
            <span class="n">newexpr</span> <span class="o">=</span> <span class="n">mpmath</span><span class="o">.</span><span class="n">identify</span><span class="p">(</span><span class="n">xv</span><span class="p">,</span> <span class="n">constants</span><span class="o">=</span><span class="n">constants_dict</span><span class="p">,</span>
                <span class="n">tol</span><span class="o">=</span><span class="n">tolerance</span><span class="p">,</span> <span class="n">full</span><span class="o">=</span><span class="n">full</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">newexpr</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span>
            <span class="k">if</span> <span class="n">full</span><span class="p">:</span>
                <span class="n">newexpr</span> <span class="o">=</span> <span class="n">newexpr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">expr</span> <span class="o">=</span> <span class="n">sympify</span><span class="p">(</span><span class="n">newexpr</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">x</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">expr</span><span class="p">:</span>  <span class="c1"># don&#39;t let x become 0</span>
                <span class="k">raise</span> <span class="ne">ValueError</span>
            <span class="k">if</span> <span class="n">expr</span><span class="o">.</span><span class="n">is_finite</span> <span class="ow">is</span> <span class="bp">False</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">xv</span> <span class="ow">in</span> <span class="p">[</span><span class="n">mpmath</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="n">mpmath</span><span class="o">.</span><span class="n">ninf</span><span class="p">]:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span>
            <span class="k">return</span> <span class="n">expr</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="c1"># even though there are returns above, this is executed</span>
            <span class="c1"># before leaving</span>
            <span class="n">mpmath</span><span class="o">.</span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span> <span class="o">=</span> <span class="n">orig</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">re</span><span class="p">:</span>
            <span class="n">re</span> <span class="o">=</span> <span class="n">nsimplify_real</span><span class="p">(</span><span class="n">re</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">im</span><span class="p">:</span>
            <span class="n">im</span> <span class="o">=</span> <span class="n">nsimplify_real</span><span class="p">(</span><span class="n">im</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">rational</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">_real_to_rational</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">expr</span>

    <span class="n">rv</span> <span class="o">=</span> <span class="n">re</span> <span class="o">+</span> <span class="n">im</span><span class="o">*</span><span class="n">S</span><span class="o">.</span><span class="n">ImaginaryUnit</span>
    <span class="c1"># if there was a change or rational is explicitly not wanted</span>
    <span class="c1"># return the value, else return the Rational representation</span>
    <span class="k">if</span> <span class="n">rv</span> <span class="o">!=</span> <span class="n">expr</span> <span class="ow">or</span> <span class="n">rational</span> <span class="ow">is</span> <span class="bp">False</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">rv</span>
    <span class="k">return</span> <span class="n">_real_to_rational</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span></div>


<span class="k">def</span> <span class="nf">_real_to_rational</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Replace all reals in expr with rationals.</span>

<span class="sd">    &gt;&gt;&gt; from sympy import nsimplify</span>
<span class="sd">    &gt;&gt;&gt; from sympy.abc import x</span>

<span class="sd">    &gt;&gt;&gt; nsimplify(.76 + .1*x**.5, rational=True)</span>
<span class="sd">    sqrt(x)/10 + 19/25</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">inf</span> <span class="o">=</span> <span class="n">Float</span><span class="p">(</span><span class="s1">&#39;inf&#39;</span><span class="p">)</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">expr</span>
    <span class="n">reps</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">reduce_num</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="k">if</span> <span class="n">tolerance</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> <span class="n">tolerance</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">reduce_num</span> <span class="o">=</span> <span class="n">ceiling</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">tolerance</span><span class="p">)</span>
    <span class="k">for</span> <span class="nb">float</span> <span class="ow">in</span> <span class="n">p</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">Float</span><span class="p">):</span>
        <span class="n">key</span> <span class="o">=</span> <span class="nb">float</span>
        <span class="k">if</span> <span class="n">reduce_num</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">r</span> <span class="o">=</span> <span class="n">Rational</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">limit_denominator</span><span class="p">(</span><span class="n">reduce_num</span><span class="p">)</span>
        <span class="k">elif</span> <span class="p">(</span><span class="n">tolerance</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> <span class="n">tolerance</span> <span class="o">&gt;=</span> <span class="mi">1</span> <span class="ow">and</span>
                <span class="nb">float</span><span class="o">.</span><span class="n">is_Integer</span> <span class="ow">is</span> <span class="bp">False</span><span class="p">):</span>
            <span class="n">r</span> <span class="o">=</span> <span class="n">Rational</span><span class="p">(</span><span class="n">tolerance</span><span class="o">*</span><span class="nb">round</span><span class="p">(</span><span class="nb">float</span><span class="o">/</span><span class="n">tolerance</span><span class="p">)</span>
                <span class="p">)</span><span class="o">.</span><span class="n">limit_denominator</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">tolerance</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">r</span> <span class="o">=</span> <span class="n">nsimplify</span><span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="n">rational</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
            <span class="c1"># e.g. log(3).n() -&gt; log(3) instead of a Rational</span>
            <span class="k">if</span> <span class="nb">float</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">r</span><span class="p">:</span>
                <span class="n">r</span> <span class="o">=</span> <span class="n">Rational</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
            <span class="k">elif</span> <span class="ow">not</span> <span class="n">r</span><span class="o">.</span><span class="n">is_Rational</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">float</span> <span class="o">==</span> <span class="n">inf</span> <span class="ow">or</span> <span class="nb">float</span> <span class="o">==</span> <span class="o">-</span><span class="n">inf</span><span class="p">:</span>
                    <span class="n">r</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">ComplexInfinity</span>
                <span class="k">elif</span> <span class="nb">float</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="nb">float</span> <span class="o">=</span> <span class="o">-</span><span class="nb">float</span>
                    <span class="n">d</span> <span class="o">=</span> <span class="n">Pow</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="nb">int</span><span class="p">((</span><span class="n">mpmath</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="o">/</span><span class="n">mpmath</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">10</span><span class="p">))))</span>
                    <span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">Rational</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="nb">float</span><span class="o">/</span><span class="n">d</span><span class="p">))</span><span class="o">*</span><span class="n">d</span>
                <span class="k">elif</span> <span class="nb">float</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">d</span> <span class="o">=</span> <span class="n">Pow</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="nb">int</span><span class="p">((</span><span class="n">mpmath</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="o">/</span><span class="n">mpmath</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">10</span><span class="p">))))</span>
                    <span class="n">r</span> <span class="o">=</span> <span class="n">Rational</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="nb">float</span><span class="o">/</span><span class="n">d</span><span class="p">))</span><span class="o">*</span><span class="n">d</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">r</span> <span class="o">=</span> <span class="n">Integer</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">reps</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">r</span>
    <span class="k">return</span> <span class="n">p</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">reps</span><span class="p">,</span> <span class="n">simultaneous</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">clear_coefficients</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">rhs</span><span class="o">=</span><span class="n">S</span><span class="o">.</span><span class="n">Zero</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return `p, r` where `p` is the expression obtained when Rational</span>
<span class="sd">    additive and multiplicative coefficients of `expr` have been stripped</span>
<span class="sd">    away in a naive fashion (i.e. without simplification). The operations</span>
<span class="sd">    needed to remove the coefficients will be applied to `rhs` and returned</span>
<span class="sd">    as `r`.</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy.simplify.simplify import clear_coefficients</span>
<span class="sd">    &gt;&gt;&gt; from sympy.abc import x, y</span>
<span class="sd">    &gt;&gt;&gt; from sympy import Dummy</span>
<span class="sd">    &gt;&gt;&gt; expr = 4*y*(6*x + 3)</span>
<span class="sd">    &gt;&gt;&gt; clear_coefficients(expr - 2)</span>
<span class="sd">    (y*(2*x + 1), 1/6)</span>

<span class="sd">    When solving 2 or more expressions like `expr = a`,</span>
<span class="sd">    `expr = b`, etc..., it is advantageous to provide a Dummy symbol</span>
<span class="sd">    for `rhs` and  simply replace it with `a`, `b`, etc... in `r`.</span>

<span class="sd">    &gt;&gt;&gt; rhs = Dummy(&#39;rhs&#39;)</span>
<span class="sd">    &gt;&gt;&gt; clear_coefficients(expr, rhs)</span>
<span class="sd">    (y*(2*x + 1), _rhs/12)</span>
<span class="sd">    &gt;&gt;&gt; _[1].subs(rhs, 2)</span>
<span class="sd">    1/6</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">was</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="n">free</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">free_symbols</span>
    <span class="k">if</span> <span class="n">expr</span><span class="o">.</span><span class="n">is_Rational</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">Zero</span><span class="p">,</span> <span class="n">rhs</span> <span class="o">-</span> <span class="n">expr</span><span class="p">)</span>
    <span class="k">while</span> <span class="n">expr</span> <span class="ow">and</span> <span class="n">was</span> <span class="o">!=</span> <span class="n">expr</span><span class="p">:</span>
        <span class="n">was</span> <span class="o">=</span> <span class="n">expr</span>
        <span class="n">m</span><span class="p">,</span> <span class="n">expr</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">expr</span><span class="o">.</span><span class="n">as_content_primitive</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">free</span> <span class="k">else</span>
            <span class="n">factor_terms</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span><span class="o">.</span><span class="n">as_coeff_Mul</span><span class="p">(</span><span class="n">rational</span><span class="o">=</span><span class="bp">True</span><span class="p">))</span>
        <span class="n">rhs</span> <span class="o">/=</span> <span class="n">m</span>
        <span class="n">c</span><span class="p">,</span> <span class="n">expr</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">as_coeff_Add</span><span class="p">(</span><span class="n">rational</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="n">rhs</span> <span class="o">-=</span> <span class="n">c</span>
    <span class="n">expr</span> <span class="o">=</span> <span class="n">signsimp</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">evaluate</span> <span class="o">=</span> <span class="bp">False</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">_coeff_isneg</span><span class="p">(</span><span class="n">expr</span><span class="p">):</span>
        <span class="n">expr</span> <span class="o">=</span> <span class="o">-</span><span class="n">expr</span>
        <span class="n">rhs</span> <span class="o">=</span> <span class="o">-</span><span class="n">rhs</span>
    <span class="k">return</span> <span class="n">expr</span><span class="p">,</span> <span class="n">rhs</span>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../../index.html">
              <img class="logo" src="../../../_static/sympylogo.png" alt="Logo"/>
            </a></p><div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../index.html">Documentation overview</a><ul>
  <li><a href="../../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2015 SymPy Development Team.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.4.1</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.7</a>
      
    </div>

    

    
  </body>
</html>