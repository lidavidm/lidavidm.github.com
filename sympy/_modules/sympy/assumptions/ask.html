<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>sympy.assumptions.ask &mdash; SymPy 1.0 documentation</title>
    
    <link rel="stylesheet" href="../../../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="http://95.sympy-live-tests.appspot.com/static/live-core.css" type="text/css" />
    <link rel="stylesheet" href="http://95.sympy-live-tests.appspot.com/static/live-autocomplete.css" type="text/css" />
    <link rel="stylesheet" href="http://95.sympy-live-tests.appspot.com/static/live-sphinx.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="http://95.sympy-live-tests.appspot.com/static/utilities.js"></script>
    <script type="text/javascript" src="http://95.sympy-live-tests.appspot.com/static/external/classy.js"></script>
    <script type="text/javascript" src="http://95.sympy-live-tests.appspot.com/static/live-core.js"></script>
    <script type="text/javascript" src="http://95.sympy-live-tests.appspot.com/static/live-autocomplete.js"></script>
    <script type="text/javascript" src="http://95.sympy-live-tests.appspot.com/static/live-sphinx.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML-full"></script>
    <link rel="shortcut icon" href="../../../_static/sympy-notailtext-favicon.ico"/>
    <link rel="top" title="SymPy 1.0 documentation" href="../../../index.html" />
    <link rel="up" title="Module code" href="../../index.html" />
   
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head>
  <body role="document">  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for sympy.assumptions.ask</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;Module for querying SymPy objects about assumptions.&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">print_function</span><span class="p">,</span> <span class="n">division</span>

<span class="kn">from</span> <span class="nn">sympy.core</span> <span class="kn">import</span> <span class="n">sympify</span>
<span class="kn">from</span> <span class="nn">sympy.core.cache</span> <span class="kn">import</span> <span class="n">cacheit</span>
<span class="kn">from</span> <span class="nn">sympy.core.relational</span> <span class="kn">import</span> <span class="n">Relational</span>
<span class="kn">from</span> <span class="nn">sympy.logic.boolalg</span> <span class="kn">import</span> <span class="p">(</span><span class="n">to_cnf</span><span class="p">,</span> <span class="n">And</span><span class="p">,</span> <span class="n">Not</span><span class="p">,</span> <span class="n">Or</span><span class="p">,</span> <span class="n">Implies</span><span class="p">,</span> <span class="n">Equivalent</span><span class="p">,</span>
    <span class="n">BooleanFunction</span><span class="p">,</span> <span class="n">BooleanAtom</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">sympy.logic.inference</span> <span class="kn">import</span> <span class="n">satisfiable</span>
<span class="kn">from</span> <span class="nn">sympy.assumptions.assume</span> <span class="kn">import</span> <span class="p">(</span><span class="n">global_assumptions</span><span class="p">,</span> <span class="n">Predicate</span><span class="p">,</span>
        <span class="n">AppliedPredicate</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">sympy.core.decorators</span> <span class="kn">import</span> <span class="n">deprecated</span>
<span class="kn">from</span> <span class="nn">sympy.utilities.decorator</span> <span class="kn">import</span> <span class="n">memoize_property</span>


<span class="c1"># Deprecated predicates should be added to this list</span>
<span class="n">deprecated_predicates</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s1">&#39;bounded&#39;</span><span class="p">,</span>
    <span class="s1">&#39;infinity&#39;</span><span class="p">,</span>
    <span class="s1">&#39;infinitesimal&#39;</span>
<span class="p">]</span>

<span class="c1"># Memoization storage for predicates</span>
<span class="n">predicate_storage</span> <span class="o">=</span> <span class="p">{}</span>
<span class="n">predicate_memo</span> <span class="o">=</span> <span class="n">memoize_property</span><span class="p">(</span><span class="n">predicate_storage</span><span class="p">)</span>
<span class="c1"># Memoization is necessary for the properties of AssumptionKeys to</span>
<span class="c1"># ensure that only one object of Predicate objects are created.</span>
<span class="c1"># This is because assumption handlers are registered on those objects.</span>


<div class="viewcode-block" id="AssumptionKeys"><a class="viewcode-back" href="../../../modules/assumptions/ask.html#sympy.assumptions.ask.AssumptionKeys">[docs]</a><span class="k">class</span> <span class="nc">AssumptionKeys</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This class contains all the supported keys by ``ask``.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@predicate_memo</span>
    <span class="k">def</span> <span class="nf">hermitian</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Hermitian predicate.</span>

<span class="sd">        ``ask(Q.hermitian(x))`` is true iff ``x`` belongs to the set of</span>
<span class="sd">        Hermitian operators.</span>

<span class="sd">        References</span>
<span class="sd">        ==========</span>

<span class="sd">        .. [1] http://mathworld.wolfram.com/HermitianOperator.html</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO: Add examples</span>
        <span class="k">return</span> <span class="n">Predicate</span><span class="p">(</span><span class="s1">&#39;hermitian&#39;</span><span class="p">)</span>

    <span class="nd">@predicate_memo</span>
    <span class="k">def</span> <span class="nf">antihermitian</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Antihermitian predicate.</span>

<span class="sd">        ``Q.antihermitian(x)`` is true iff ``x`` belongs to the field of</span>
<span class="sd">        antihermitian operators, i.e., operators in the form ``x*I``, where</span>
<span class="sd">        ``x`` is Hermitian.</span>

<span class="sd">        References</span>
<span class="sd">        ==========</span>

<span class="sd">        .. [1] http://mathworld.wolfram.com/HermitianOperator.html</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO: Add examples</span>
        <span class="k">return</span> <span class="n">Predicate</span><span class="p">(</span><span class="s1">&#39;antihermitian&#39;</span><span class="p">)</span>

    <span class="nd">@predicate_memo</span>
    <span class="k">def</span> <span class="nf">real</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">        Real number predicate.</span>

<span class="sd">        ``Q.real(x)`` is true iff ``x`` is a real number, i.e., it is in the</span>
<span class="sd">        interval `(-\infty, \infty)`.  Note that, in particular the infinities</span>
<span class="sd">        are not real. Use ``Q.extended_real`` if you want to consider those as</span>
<span class="sd">        well.</span>

<span class="sd">        A few important facts about reals:</span>

<span class="sd">        - Every real number is positive, negative, or zero.  Furthermore,</span>
<span class="sd">          because these sets are pairwise disjoint, each real number is exactly</span>
<span class="sd">          one of those three.</span>

<span class="sd">        - Every real number is also complex.</span>

<span class="sd">        - Every real number is finite.</span>

<span class="sd">        - Every real number is either rational or irrational.</span>

<span class="sd">        - Every real number is either algebraic or transcendental.</span>

<span class="sd">        - The facts ``Q.negative``, ``Q.zero``, ``Q.positive``,</span>
<span class="sd">          ``Q.nonnegative``, ``Q.nonpositive``, ``Q.nonzero``, ``Q.integer``,</span>
<span class="sd">          ``Q.rational``, and ``Q.irrational`` all imply ``Q.real``, as do all</span>
<span class="sd">          facts that imply those facts.</span>

<span class="sd">        - The facts ``Q.algebraic``, and ``Q.transcendental`` do not imply</span>
<span class="sd">          ``Q.real``; they imply ``Q.complex``. An algebraic or transcendental</span>
<span class="sd">          number may or may not be real.</span>

<span class="sd">        - The &quot;non&quot; facts (i.e., ``Q.nonnegative``, ``Q.nonzero``,</span>
<span class="sd">          ``Q.nonpositive`` and ``Q.noninteger``) are not equivalent to not the</span>
<span class="sd">          fact, but rather, not the fact *and* ``Q.real``.  For example,</span>
<span class="sd">          ``Q.nonnegative`` means ``~Q.negative &amp; Q.real``. So for example,</span>
<span class="sd">          ``I`` is not nonnegative, nonzero, or nonpositive.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy import Q, ask, symbols</span>
<span class="sd">        &gt;&gt;&gt; x = symbols(&#39;x&#39;)</span>
<span class="sd">        &gt;&gt;&gt; ask(Q.real(x), Q.positive(x))</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; ask(Q.real(0))</span>
<span class="sd">        True</span>

<span class="sd">        References</span>
<span class="sd">        ==========</span>

<span class="sd">        .. [1] https://en.wikipedia.org/wiki/Real_number</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Predicate</span><span class="p">(</span><span class="s1">&#39;real&#39;</span><span class="p">)</span>

    <span class="nd">@predicate_memo</span>
    <span class="k">def</span> <span class="nf">extended_real</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">        Extended real predicate.</span>

<span class="sd">        ``Q.extended_real(x)`` is true iff ``x`` is a real number or</span>
<span class="sd">        `\{-\infty, \infty\}`.</span>

<span class="sd">        See documentation of ``Q.real`` for more information about related facts.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy import ask, Q, oo, I</span>
<span class="sd">        &gt;&gt;&gt; ask(Q.extended_real(1))</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; ask(Q.extended_real(I))</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; ask(Q.extended_real(oo))</span>
<span class="sd">        True</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Predicate</span><span class="p">(</span><span class="s1">&#39;extended_real&#39;</span><span class="p">)</span>

    <span class="nd">@predicate_memo</span>
    <span class="k">def</span> <span class="nf">imaginary</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Imaginary number predicate.</span>

<span class="sd">        ``Q.imaginary(x)`` is true iff ``x`` can be written as a real</span>
<span class="sd">        number multiplied by the imaginary unit ``I``. Please note that ``0``</span>
<span class="sd">        is not considered to be an imaginary number.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy import Q, ask, I</span>
<span class="sd">        &gt;&gt;&gt; ask(Q.imaginary(3*I))</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; ask(Q.imaginary(2 + 3*I))</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; ask(Q.imaginary(0))</span>
<span class="sd">        False</span>

<span class="sd">        References</span>
<span class="sd">        ==========</span>

<span class="sd">        .. [1] https://en.wikipedia.org/wiki/Imaginary_number</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Predicate</span><span class="p">(</span><span class="s1">&#39;imaginary&#39;</span><span class="p">)</span>

    <span class="nd">@predicate_memo</span>
    <span class="k">def</span> <span class="nf">complex</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Complex number predicate.</span>

<span class="sd">        ``Q.complex(x)`` is true iff ``x`` belongs to the set of complex</span>
<span class="sd">        numbers. Note that every complex number is finite.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy import Q, Symbol, ask, I, oo</span>
<span class="sd">        &gt;&gt;&gt; x = Symbol(&#39;x&#39;)</span>
<span class="sd">        &gt;&gt;&gt; ask(Q.complex(0))</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; ask(Q.complex(2 + 3*I))</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; ask(Q.complex(oo))</span>
<span class="sd">        False</span>

<span class="sd">        References</span>
<span class="sd">        ==========</span>

<span class="sd">        .. [1] https://en.wikipedia.org/wiki/Complex_number</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Predicate</span><span class="p">(</span><span class="s1">&#39;complex&#39;</span><span class="p">)</span>

    <span class="nd">@predicate_memo</span>
    <span class="k">def</span> <span class="nf">algebraic</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">        Algebraic number predicate.</span>

<span class="sd">        ``Q.algebraic(x)`` is true iff ``x`` belongs to the set of</span>
<span class="sd">        algebraic numbers. ``x`` is algebraic if there is some polynomial</span>
<span class="sd">        in ``p(x)\in \mathbb\{Q\}[x]`` such that ``p(x) = 0``.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy import ask, Q, sqrt, I, pi</span>
<span class="sd">        &gt;&gt;&gt; ask(Q.algebraic(sqrt(2)))</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; ask(Q.algebraic(I))</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; ask(Q.algebraic(pi))</span>
<span class="sd">        False</span>

<span class="sd">        References</span>
<span class="sd">        ==========</span>

<span class="sd">        .. [1] http://en.wikipedia.org/wiki/Algebraic_number</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Predicate</span><span class="p">(</span><span class="s1">&#39;algebraic&#39;</span><span class="p">)</span>

    <span class="nd">@predicate_memo</span>
    <span class="k">def</span> <span class="nf">transcendental</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Transcedental number predicate.</span>

<span class="sd">        ``Q.transcendental(x)`` is true iff ``x`` belongs to the set of</span>
<span class="sd">        transcendental numbers. A transcendental number is a real</span>
<span class="sd">        or complex number that is not algebraic.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO: Add examples</span>
        <span class="k">return</span> <span class="n">Predicate</span><span class="p">(</span><span class="s1">&#39;transcendental&#39;</span><span class="p">)</span>

    <span class="nd">@predicate_memo</span>
    <span class="k">def</span> <span class="nf">integer</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Integer predicate.</span>

<span class="sd">        ``Q.integer(x)`` is true iff ``x`` belongs to the set of integer numbers.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy import Q, ask, S</span>
<span class="sd">        &gt;&gt;&gt; ask(Q.integer(5))</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; ask(Q.integer(S(1)/2))</span>
<span class="sd">        False</span>

<span class="sd">        References</span>
<span class="sd">        ==========</span>

<span class="sd">        .. [1] https://en.wikipedia.org/wiki/Integer</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Predicate</span><span class="p">(</span><span class="s1">&#39;integer&#39;</span><span class="p">)</span>

    <span class="nd">@predicate_memo</span>
    <span class="k">def</span> <span class="nf">rational</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Rational number predicate.</span>

<span class="sd">        ``Q.rational(x)`` is true iff ``x`` belongs to the set of</span>
<span class="sd">        rational numbers.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy import ask, Q, pi, S</span>
<span class="sd">        &gt;&gt;&gt; ask(Q.rational(0))</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; ask(Q.rational(S(1)/2))</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; ask(Q.rational(pi))</span>
<span class="sd">        False</span>

<span class="sd">        References</span>
<span class="sd">        ==========</span>

<span class="sd">        https://en.wikipedia.org/wiki/Rational_number</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Predicate</span><span class="p">(</span><span class="s1">&#39;rational&#39;</span><span class="p">)</span>

    <span class="nd">@predicate_memo</span>
    <span class="k">def</span> <span class="nf">irrational</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Irrational number predicate.</span>

<span class="sd">        ``Q.irrational(x)`` is true iff ``x``  is any real number that</span>
<span class="sd">        cannot be expressed as a ratio of integers.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy import ask, Q, pi, S, I</span>
<span class="sd">        &gt;&gt;&gt; ask(Q.irrational(0))</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; ask(Q.irrational(S(1)/2))</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; ask(Q.irrational(pi))</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; ask(Q.irrational(I))</span>
<span class="sd">        False</span>

<span class="sd">        References</span>
<span class="sd">        ==========</span>

<span class="sd">        .. [1] https://en.wikipedia.org/wiki/Irrational_number</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Predicate</span><span class="p">(</span><span class="s1">&#39;irrational&#39;</span><span class="p">)</span>

    <span class="nd">@predicate_memo</span>
    <span class="k">def</span> <span class="nf">finite</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Finite predicate.</span>

<span class="sd">        ``Q.finite(x)`` is true if ``x`` is neither an infinity</span>
<span class="sd">        nor a ``NaN``. In other words, ``ask(Q.finite(x))`` is true for all ``x``</span>
<span class="sd">        having a bounded absolute value.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy import Q, ask, Symbol, S, oo, I</span>
<span class="sd">        &gt;&gt;&gt; x = Symbol(&#39;x&#39;)</span>
<span class="sd">        &gt;&gt;&gt; ask(Q.finite(S.NaN))</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; ask(Q.finite(oo))</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; ask(Q.finite(1))</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; ask(Q.finite(2 + 3*I))</span>
<span class="sd">        True</span>

<span class="sd">        References</span>
<span class="sd">        ==========</span>

<span class="sd">        .. [1] https://en.wikipedia.org/wiki/Finite</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Predicate</span><span class="p">(</span><span class="s1">&#39;finite&#39;</span><span class="p">)</span>

    <span class="nd">@predicate_memo</span>
    <span class="nd">@deprecated</span><span class="p">(</span><span class="n">useinstead</span><span class="o">=</span><span class="s2">&quot;finite&quot;</span><span class="p">,</span> <span class="n">issue</span><span class="o">=</span><span class="mi">9425</span><span class="p">,</span> <span class="n">deprecated_since_version</span><span class="o">=</span><span class="s2">&quot;1.0&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">bounded</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        See documentation of ``Q.finite``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Predicate</span><span class="p">(</span><span class="s1">&#39;finite&#39;</span><span class="p">)</span>

    <span class="nd">@predicate_memo</span>
    <span class="k">def</span> <span class="nf">infinite</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Infinite number predicate.</span>

<span class="sd">        ``Q.infinite(x)`` is true iff the absolute value of ``x`` is</span>
<span class="sd">        infinity.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO: Add examples</span>
        <span class="k">return</span> <span class="n">Predicate</span><span class="p">(</span><span class="s1">&#39;infinite&#39;</span><span class="p">)</span>

    <span class="nd">@predicate_memo</span>
    <span class="nd">@deprecated</span><span class="p">(</span><span class="n">useinstead</span><span class="o">=</span><span class="s2">&quot;infinite&quot;</span><span class="p">,</span> <span class="n">issue</span><span class="o">=</span><span class="mi">9426</span><span class="p">,</span> <span class="n">deprecated_since_version</span><span class="o">=</span><span class="s2">&quot;1.0&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">infinity</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        See documentation of ``Q.infinite``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Predicate</span><span class="p">(</span><span class="s1">&#39;infinite&#39;</span><span class="p">)</span>

    <span class="nd">@predicate_memo</span>
    <span class="nd">@deprecated</span><span class="p">(</span><span class="n">useinstead</span><span class="o">=</span><span class="s2">&quot;zero&quot;</span><span class="p">,</span> <span class="n">issue</span><span class="o">=</span><span class="mi">9675</span><span class="p">,</span> <span class="n">deprecated_since_version</span><span class="o">=</span><span class="s2">&quot;1.0&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">infinitesimal</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        See documentation of ``Q.zero``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Predicate</span><span class="p">(</span><span class="s1">&#39;zero&#39;</span><span class="p">)</span>

    <span class="nd">@predicate_memo</span>
    <span class="k">def</span> <span class="nf">positive</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">        Positive real number predicate.</span>

<span class="sd">        ``Q.positive(x)`` is true iff ``x`` is real and `x &gt; 0`, that is if ``x``</span>
<span class="sd">        is in the interval `(0, \infty)`.  In particular, infinity is not</span>
<span class="sd">        positive.</span>

<span class="sd">        A few important facts about positive numbers:</span>

<span class="sd">        - Note that ``Q.nonpositive`` and ``~Q.positive`` are *not* the same</span>
<span class="sd">          thing. ``~Q.positive(x)`` simply means that ``x`` is not positive,</span>
<span class="sd">          whereas ``Q.nonpositive(x)`` means that ``x`` is real and not</span>
<span class="sd">          positive, i.e., ``Q.nonpositive(x)`` is logically equivalent to</span>
<span class="sd">          `Q.negative(x) | Q.zero(x)``.  So for example, ``~Q.positive(I)`` is</span>
<span class="sd">          true, whereas ``Q.nonpositive(I)`` is false.</span>

<span class="sd">        - See the documentation of ``Q.real`` for more information about</span>
<span class="sd">          related facts.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy import Q, ask, symbols, I</span>
<span class="sd">        &gt;&gt;&gt; x = symbols(&#39;x&#39;)</span>
<span class="sd">        &gt;&gt;&gt; ask(Q.positive(x), Q.real(x) &amp; ~Q.negative(x) &amp; ~Q.zero(x))</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; ask(Q.positive(1))</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; ask(Q.nonpositive(I))</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; ask(~Q.positive(I))</span>
<span class="sd">        True</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Predicate</span><span class="p">(</span><span class="s1">&#39;positive&#39;</span><span class="p">)</span>

    <span class="nd">@predicate_memo</span>
    <span class="k">def</span> <span class="nf">negative</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">        Negative number predicate.</span>

<span class="sd">        ``Q.negative(x)`` is true iff ``x`` is a real number and :math:`x &lt; 0`, that is,</span>
<span class="sd">        it is in the interval :math:`(-\infty, 0)`.  Note in particular that negative</span>
<span class="sd">        infinity is not negative.</span>

<span class="sd">        A few important facts about negative numbers:</span>

<span class="sd">        - Note that ``Q.nonnegative`` and ``~Q.negative`` are *not* the same</span>
<span class="sd">          thing. ``~Q.negative(x)`` simply means that ``x`` is not negative,</span>
<span class="sd">          whereas ``Q.nonnegative(x)`` means that ``x`` is real and not</span>
<span class="sd">          negative, i.e., ``Q.nonnegative(x)`` is logically equivalent to</span>
<span class="sd">          ``Q.zero(x) | Q.positive(x)``.  So for example, ``~Q.negative(I)`` is</span>
<span class="sd">          true, whereas ``Q.nonnegative(I)`` is false.</span>

<span class="sd">        - See the documentation of ``Q.real`` for more information about</span>
<span class="sd">          related facts.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy import Q, ask, symbols, I</span>
<span class="sd">        &gt;&gt;&gt; x = symbols(&#39;x&#39;)</span>
<span class="sd">        &gt;&gt;&gt; ask(Q.negative(x), Q.real(x) &amp; ~Q.positive(x) &amp; ~Q.zero(x))</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; ask(Q.negative(-1))</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; ask(Q.nonnegative(I))</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; ask(~Q.negative(I))</span>
<span class="sd">        True</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Predicate</span><span class="p">(</span><span class="s1">&#39;negative&#39;</span><span class="p">)</span>

    <span class="nd">@predicate_memo</span>
    <span class="k">def</span> <span class="nf">zero</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Zero number predicate.</span>

<span class="sd">        ``ask(Q.zero(x))`` is true iff the value of ``x`` is zero.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy import ask, Q, oo, symbols</span>
<span class="sd">        &gt;&gt;&gt; x, y = symbols(&#39;x, y&#39;)</span>
<span class="sd">        &gt;&gt;&gt; ask(Q.zero(0))</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; ask(Q.zero(1/oo))</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; ask(Q.zero(0*oo))</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; ask(Q.zero(1))</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; ask(Q.zero(x*y), Q.zero(x) | Q.zero(y))</span>
<span class="sd">        True</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Predicate</span><span class="p">(</span><span class="s1">&#39;zero&#39;</span><span class="p">)</span>

    <span class="nd">@predicate_memo</span>
    <span class="k">def</span> <span class="nf">nonzero</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Nonzero real number predicate.</span>

<span class="sd">        ``ask(Q.nonzero(x))`` is true iff ``x`` is real and ``x`` is not zero.  Note in</span>
<span class="sd">        particular that ``Q.nonzero(x)`` is false if ``x`` is not real.  Use</span>
<span class="sd">        ``~Q.zero(x)`` if you want the negation of being zero without any real</span>
<span class="sd">        assumptions.</span>

<span class="sd">        A few important facts about nonzero numbers:</span>

<span class="sd">        - ``Q.nonzero`` is logically equivalent to ``Q.positive | Q.negative``.</span>

<span class="sd">        - See the documentation of ``Q.real`` for more information about</span>
<span class="sd">          related facts.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy import Q, ask, symbols, I, oo</span>
<span class="sd">        &gt;&gt;&gt; x = symbols(&#39;x&#39;)</span>
<span class="sd">        &gt;&gt;&gt; print(ask(Q.nonzero(x), ~Q.zero(x)))</span>
<span class="sd">        None</span>
<span class="sd">        &gt;&gt;&gt; ask(Q.nonzero(x), Q.positive(x))</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; ask(Q.nonzero(x), Q.zero(x))</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; ask(Q.nonzero(0))</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; ask(Q.nonzero(I))</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; ask(~Q.zero(I))</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; ask(Q.nonzero(oo))  #doctest: +SKIP</span>
<span class="sd">        False</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Predicate</span><span class="p">(</span><span class="s1">&#39;nonzero&#39;</span><span class="p">)</span>

    <span class="nd">@predicate_memo</span>
    <span class="k">def</span> <span class="nf">nonpositive</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Nonpositive real number predicate.</span>

<span class="sd">        ``ask(Q.nonpositive(x))`` is true iff ``x`` belongs to the set of</span>
<span class="sd">        negative numbers including zero.</span>

<span class="sd">        - Note that ``Q.nonpositive`` and ``~Q.positive`` are *not* the same</span>
<span class="sd">          thing. ``~Q.positive(x)`` simply means that ``x`` is not positive,</span>
<span class="sd">          whereas ``Q.nonpositive(x)`` means that ``x`` is real and not</span>
<span class="sd">          positive, i.e., ``Q.nonpositive(x)`` is logically equivalent to</span>
<span class="sd">          `Q.negative(x) | Q.zero(x)``.  So for example, ``~Q.positive(I)`` is</span>
<span class="sd">          true, whereas ``Q.nonpositive(I)`` is false.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy import Q, ask, I</span>
<span class="sd">        &gt;&gt;&gt; ask(Q.nonpositive(-1))</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; ask(Q.nonpositive(0))</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; ask(Q.nonpositive(1))</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; ask(Q.nonpositive(I))</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; ask(Q.nonpositive(-I))</span>
<span class="sd">        False</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Predicate</span><span class="p">(</span><span class="s1">&#39;nonpositive&#39;</span><span class="p">)</span>

    <span class="nd">@predicate_memo</span>
    <span class="k">def</span> <span class="nf">nonnegative</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Nonnegative real number predicate.</span>

<span class="sd">        ``ask(Q.nonnegative(x))`` is true iff ``x`` belongs to the set of</span>
<span class="sd">        positive numbers including zero.</span>

<span class="sd">        - Note that ``Q.nonnegative`` and ``~Q.negative`` are *not* the same</span>
<span class="sd">          thing. ``~Q.negative(x)`` simply means that ``x`` is not negative,</span>
<span class="sd">          whereas ``Q.nonnegative(x)`` means that ``x`` is real and not</span>
<span class="sd">          negative, i.e., ``Q.nonnegative(x)`` is logically equivalent to</span>
<span class="sd">          ``Q.zero(x) | Q.positive(x)``.  So for example, ``~Q.negative(I)`` is</span>
<span class="sd">          true, whereas ``Q.nonnegative(I)`` is false.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy import Q, ask, I</span>
<span class="sd">        &gt;&gt;&gt; ask(Q.nonnegative(1))</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; ask(Q.nonnegative(0))</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; ask(Q.nonnegative(-1))</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; ask(Q.nonnegative(I))</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; ask(Q.nonnegative(-I))</span>
<span class="sd">        False</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Predicate</span><span class="p">(</span><span class="s1">&#39;nonnegative&#39;</span><span class="p">)</span>

    <span class="nd">@predicate_memo</span>
    <span class="k">def</span> <span class="nf">even</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Even number predicate.</span>

<span class="sd">        ``ask(Q.even(x))`` is true iff ``x`` belongs to the set of even</span>
<span class="sd">        integers.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy import Q, ask, pi</span>
<span class="sd">        &gt;&gt;&gt; ask(Q.even(0))</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; ask(Q.even(2))</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; ask(Q.even(3))</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; ask(Q.even(pi))</span>
<span class="sd">        False</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Predicate</span><span class="p">(</span><span class="s1">&#39;even&#39;</span><span class="p">)</span>

    <span class="nd">@predicate_memo</span>
    <span class="k">def</span> <span class="nf">odd</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Odd number predicate.</span>

<span class="sd">        ``ask(Q.odd(x))`` is true iff ``x`` belongs to the set of odd numbers.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy import Q, ask, pi</span>
<span class="sd">        &gt;&gt;&gt; ask(Q.odd(0))</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; ask(Q.odd(2))</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; ask(Q.odd(3))</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; ask(Q.odd(pi))</span>
<span class="sd">        False</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Predicate</span><span class="p">(</span><span class="s1">&#39;odd&#39;</span><span class="p">)</span>

    <span class="nd">@predicate_memo</span>
    <span class="k">def</span> <span class="nf">prime</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Prime number predicate.</span>

<span class="sd">        ``ask(Q.prime(x))`` is true iff ``x`` is a natural number greater</span>
<span class="sd">        than 1 that has no positive divisors other than ``1`` and the</span>
<span class="sd">        number itself.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy import Q, ask</span>
<span class="sd">        &gt;&gt;&gt; ask(Q.prime(0))</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; ask(Q.prime(1))</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; ask(Q.prime(2))</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; ask(Q.prime(20))</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; ask(Q.prime(-3))</span>
<span class="sd">        False</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Predicate</span><span class="p">(</span><span class="s1">&#39;prime&#39;</span><span class="p">)</span>

    <span class="nd">@predicate_memo</span>
    <span class="k">def</span> <span class="nf">composite</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Composite number predicate.</span>

<span class="sd">        ``ask(Q.composite(x))`` is true iff ``x`` is a positive integer and has</span>
<span class="sd">        at least one positive divisor other than ``1`` and the number itself.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy import Q, ask</span>
<span class="sd">        &gt;&gt;&gt; ask(Q.composite(0))</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; ask(Q.composite(1))</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; ask(Q.composite(2))</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; ask(Q.composite(20))</span>
<span class="sd">        True</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Predicate</span><span class="p">(</span><span class="s1">&#39;composite&#39;</span><span class="p">)</span>

    <span class="nd">@predicate_memo</span>
    <span class="k">def</span> <span class="nf">commutative</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Commutative predicate.</span>

<span class="sd">        ``ask(Q.commutative(x))`` is true iff ``x`` commutes with any other</span>
<span class="sd">        object with respect to multiplication operation.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO: Add examples</span>
        <span class="k">return</span> <span class="n">Predicate</span><span class="p">(</span><span class="s1">&#39;commutative&#39;</span><span class="p">)</span>

    <span class="nd">@predicate_memo</span>
    <span class="k">def</span> <span class="nf">is_true</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generic predicate.</span>

<span class="sd">        ``ask(Q.is_true(x))`` is true iff ``x`` is true. This only makes</span>
<span class="sd">        sense if ``x`` is a predicate.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy import ask, Q, symbols</span>
<span class="sd">        &gt;&gt;&gt; x = symbols(&#39;x&#39;)</span>
<span class="sd">        &gt;&gt;&gt; ask(Q.is_true(True))</span>
<span class="sd">        True</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Predicate</span><span class="p">(</span><span class="s1">&#39;is_true&#39;</span><span class="p">)</span>

    <span class="nd">@predicate_memo</span>
    <span class="k">def</span> <span class="nf">symmetric</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Symmetric matrix predicate.</span>

<span class="sd">        ``Q.symmetric(x)`` is true iff ``x`` is a square matrix and is equal to</span>
<span class="sd">        its transpose. Every square diagonal matrix is a symmetric matrix.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy import Q, ask, MatrixSymbol</span>
<span class="sd">        &gt;&gt;&gt; X = MatrixSymbol(&#39;X&#39;, 2, 2)</span>
<span class="sd">        &gt;&gt;&gt; Y = MatrixSymbol(&#39;Y&#39;, 2, 3)</span>
<span class="sd">        &gt;&gt;&gt; Z = MatrixSymbol(&#39;Z&#39;, 2, 2)</span>
<span class="sd">        &gt;&gt;&gt; ask(Q.symmetric(X*Z), Q.symmetric(X) &amp; Q.symmetric(Z))</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; ask(Q.symmetric(X + Z), Q.symmetric(X) &amp; Q.symmetric(Z))</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; ask(Q.symmetric(Y))</span>
<span class="sd">        False</span>


<span class="sd">        References</span>
<span class="sd">        ==========</span>

<span class="sd">        .. [1] https://en.wikipedia.org/wiki/Symmetric_matrix</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO: Add handlers to make these keys work with</span>
        <span class="c1"># actual matrices and add more examples in the docstring.</span>
        <span class="k">return</span> <span class="n">Predicate</span><span class="p">(</span><span class="s1">&#39;symmetric&#39;</span><span class="p">)</span>

    <span class="nd">@predicate_memo</span>
    <span class="k">def</span> <span class="nf">invertible</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Invertible matrix predicate.</span>

<span class="sd">        ``Q.invertible(x)`` is true iff ``x`` is an invertible matrix.</span>
<span class="sd">        A square matrix is called invertible only if its determinant is 0.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy import Q, ask, MatrixSymbol</span>
<span class="sd">        &gt;&gt;&gt; X = MatrixSymbol(&#39;X&#39;, 2, 2)</span>
<span class="sd">        &gt;&gt;&gt; Y = MatrixSymbol(&#39;Y&#39;, 2, 3)</span>
<span class="sd">        &gt;&gt;&gt; Z = MatrixSymbol(&#39;Z&#39;, 2, 2)</span>
<span class="sd">        &gt;&gt;&gt; ask(Q.invertible(X*Y), Q.invertible(X))</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; ask(Q.invertible(X*Z), Q.invertible(X) &amp; Q.invertible(Z))</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; ask(Q.invertible(X), Q.fullrank(X) &amp; Q.square(X))</span>
<span class="sd">        True</span>

<span class="sd">        References</span>
<span class="sd">        ==========</span>

<span class="sd">        .. [1] https://en.wikipedia.org/wiki/Invertible_matrix</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Predicate</span><span class="p">(</span><span class="s1">&#39;invertible&#39;</span><span class="p">)</span>

    <span class="nd">@predicate_memo</span>
    <span class="k">def</span> <span class="nf">orthogonal</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Orthogonal matrix predicate.</span>

<span class="sd">        ``Q.orthogonal(x)`` is true iff ``x`` is an orthogonal matrix.</span>
<span class="sd">        A square matrix ``M`` is an orthogonal matrix if it satisfies</span>
<span class="sd">        ``M^TM = MM^T = I`` where ``M^T`` is the transpose matrix of</span>
<span class="sd">        ``M`` and ``I`` is an identity matrix. Note that an orthogonal</span>
<span class="sd">        matrix is necessarily invertible.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy import Q, ask, MatrixSymbol, Identity</span>
<span class="sd">        &gt;&gt;&gt; X = MatrixSymbol(&#39;X&#39;, 2, 2)</span>
<span class="sd">        &gt;&gt;&gt; Y = MatrixSymbol(&#39;Y&#39;, 2, 3)</span>
<span class="sd">        &gt;&gt;&gt; Z = MatrixSymbol(&#39;Z&#39;, 2, 2)</span>
<span class="sd">        &gt;&gt;&gt; ask(Q.orthogonal(Y))</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; ask(Q.orthogonal(X*Z*X), Q.orthogonal(X) &amp; Q.orthogonal(Z))</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; ask(Q.orthogonal(Identity(3)))</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; ask(Q.invertible(X), Q.orthogonal(X))</span>
<span class="sd">        True</span>

<span class="sd">        References</span>
<span class="sd">        ==========</span>

<span class="sd">        .. [1] https://en.wikipedia.org/wiki/Orthogonal_matrix</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Predicate</span><span class="p">(</span><span class="s1">&#39;orthogonal&#39;</span><span class="p">)</span>

    <span class="nd">@predicate_memo</span>
    <span class="k">def</span> <span class="nf">unitary</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Unitary matrix predicate.</span>

<span class="sd">        ``Q.unitary(x)`` is true iff ``x`` is a unitary matrix.</span>
<span class="sd">        Unitary matrix is an analogue to orthogonal matrix. A square</span>
<span class="sd">        matrix ``M`` with complex elements is unitary if :math:``M^TM = MM^T= I``</span>
<span class="sd">        where :math:``M^T`` is the conjugate transpose matrix of ``M``.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy import Q, ask, MatrixSymbol, Identity</span>
<span class="sd">        &gt;&gt;&gt; X = MatrixSymbol(&#39;X&#39;, 2, 2)</span>
<span class="sd">        &gt;&gt;&gt; Y = MatrixSymbol(&#39;Y&#39;, 2, 3)</span>
<span class="sd">        &gt;&gt;&gt; Z = MatrixSymbol(&#39;Z&#39;, 2, 2)</span>
<span class="sd">        &gt;&gt;&gt; ask(Q.unitary(Y))</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; ask(Q.unitary(X*Z*X), Q.unitary(X) &amp; Q.unitary(Z))</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; ask(Q.unitary(Identity(3)))</span>
<span class="sd">        True</span>

<span class="sd">        References</span>
<span class="sd">        ==========</span>

<span class="sd">        .. [1] https://en.wikipedia.org/wiki/Unitary_matrix</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Predicate</span><span class="p">(</span><span class="s1">&#39;unitary&#39;</span><span class="p">)</span>

    <span class="nd">@predicate_memo</span>
    <span class="k">def</span> <span class="nf">positive_definite</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">        Positive definite matrix predicate.</span>

<span class="sd">        If ``M`` is a :math:``n \times n`` symmetric real matrix, it is said</span>
<span class="sd">        to be positive definite if :math:`Z^TMZ` is positive for</span>
<span class="sd">        every non-zero column vector ``Z`` of ``n`` real numbers.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy import Q, ask, MatrixSymbol, Identity</span>
<span class="sd">        &gt;&gt;&gt; X = MatrixSymbol(&#39;X&#39;, 2, 2)</span>
<span class="sd">        &gt;&gt;&gt; Y = MatrixSymbol(&#39;Y&#39;, 2, 3)</span>
<span class="sd">        &gt;&gt;&gt; Z = MatrixSymbol(&#39;Z&#39;, 2, 2)</span>
<span class="sd">        &gt;&gt;&gt; ask(Q.positive_definite(Y))</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; ask(Q.positive_definite(Identity(3)))</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; ask(Q.positive_definite(X + Z), Q.positive_definite(X) &amp;</span>
<span class="sd">        ...     Q.positive_definite(Z))</span>
<span class="sd">        True</span>

<span class="sd">        References</span>
<span class="sd">        ==========</span>

<span class="sd">        .. [1] https://en.wikipedia.org/wiki/Positive-definite_matrix</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Predicate</span><span class="p">(</span><span class="s1">&#39;positive_definite&#39;</span><span class="p">)</span>

    <span class="nd">@predicate_memo</span>
    <span class="k">def</span> <span class="nf">upper_triangular</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Upper triangular matrix predicate.</span>

<span class="sd">        A matrix ``M`` is called upper triangular matrix if :math:`M_{ij}=0`</span>
<span class="sd">        for :math:`i&lt;j`.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy import Q, ask, ZeroMatrix, Identity</span>
<span class="sd">        &gt;&gt;&gt; ask(Q.upper_triangular(Identity(3)))</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; ask(Q.upper_triangular(ZeroMatrix(3, 3)))</span>
<span class="sd">        True</span>

<span class="sd">        References</span>
<span class="sd">        ==========</span>

<span class="sd">        .. [1] http://mathworld.wolfram.com/UpperTriangularMatrix.html</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Predicate</span><span class="p">(</span><span class="s1">&#39;upper_triangular&#39;</span><span class="p">)</span>

    <span class="nd">@predicate_memo</span>
    <span class="k">def</span> <span class="nf">lower_triangular</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Lower triangular matrix predicate.</span>

<span class="sd">        A matrix ``M`` is called lower triangular matrix if :math:`a_{ij}=0`</span>
<span class="sd">        for :math:`i&gt;j`.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy import Q, ask, ZeroMatrix, Identity</span>
<span class="sd">        &gt;&gt;&gt; ask(Q.lower_triangular(Identity(3)))</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; ask(Q.lower_triangular(ZeroMatrix(3, 3)))</span>
<span class="sd">        True</span>

<span class="sd">        References</span>
<span class="sd">        ==========</span>

<span class="sd">        .. [1] http://mathworld.wolfram.com/LowerTriangularMatrix.html</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Predicate</span><span class="p">(</span><span class="s1">&#39;lower_triangular&#39;</span><span class="p">)</span>

    <span class="nd">@predicate_memo</span>
    <span class="k">def</span> <span class="nf">diagonal</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Diagonal matrix predicate.</span>

<span class="sd">        ``Q.diagonal(x)`` is true iff ``x`` is a diagonal matrix. A diagonal</span>
<span class="sd">        matrix is a matrix in which the entries outside the main diagonal</span>
<span class="sd">        are all zero.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy import Q, ask, MatrixSymbol, ZeroMatrix</span>
<span class="sd">        &gt;&gt;&gt; X = MatrixSymbol(&#39;X&#39;, 2, 2)</span>
<span class="sd">        &gt;&gt;&gt; ask(Q.diagonal(ZeroMatrix(3, 3)))</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; ask(Q.diagonal(X), Q.lower_triangular(X) &amp;</span>
<span class="sd">        ...     Q.upper_triangular(X))</span>
<span class="sd">        True</span>

<span class="sd">        References</span>
<span class="sd">        ==========</span>

<span class="sd">        .. [1] https://en.wikipedia.org/wiki/Diagonal_matrix</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Predicate</span><span class="p">(</span><span class="s1">&#39;diagonal&#39;</span><span class="p">)</span>

    <span class="nd">@predicate_memo</span>
    <span class="k">def</span> <span class="nf">fullrank</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fullrank matrix predicate.</span>

<span class="sd">        ``Q.fullrank(x)`` is true iff ``x`` is a full rank matrix.</span>
<span class="sd">        A matrix is full rank if all rows and columns of the matrix</span>
<span class="sd">        are linearly independent. A square matrix is full rank iff</span>
<span class="sd">        its determinant is nonzero.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy import Q, ask, MatrixSymbol, ZeroMatrix, Identity</span>
<span class="sd">        &gt;&gt;&gt; X = MatrixSymbol(&#39;X&#39;, 2, 2)</span>
<span class="sd">        &gt;&gt;&gt; ask(Q.fullrank(X.T), Q.fullrank(X))</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; ask(Q.fullrank(ZeroMatrix(3, 3)))</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; ask(Q.fullrank(Identity(3)))</span>
<span class="sd">        True</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Predicate</span><span class="p">(</span><span class="s1">&#39;fullrank&#39;</span><span class="p">)</span>

    <span class="nd">@predicate_memo</span>
    <span class="k">def</span> <span class="nf">square</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Square matrix predicate.</span>

<span class="sd">        ``Q.square(x)`` is true iff ``x`` is a square matrix. A square matrix</span>
<span class="sd">        is a matrix with the same number of rows and columns.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy import Q, ask, MatrixSymbol, ZeroMatrix, Identity</span>
<span class="sd">        &gt;&gt;&gt; X = MatrixSymbol(&#39;X&#39;, 2, 2)</span>
<span class="sd">        &gt;&gt;&gt; Y = MatrixSymbol(&#39;X&#39;, 2, 3)</span>
<span class="sd">        &gt;&gt;&gt; ask(Q.square(X))</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; ask(Q.square(Y))</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; ask(Q.square(ZeroMatrix(3, 3)))</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; ask(Q.square(Identity(3)))</span>
<span class="sd">        True</span>

<span class="sd">        References</span>
<span class="sd">        ==========</span>

<span class="sd">        .. [1] https://en.wikipedia.org/wiki/Square_matrix</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Predicate</span><span class="p">(</span><span class="s1">&#39;square&#39;</span><span class="p">)</span>

    <span class="nd">@predicate_memo</span>
    <span class="k">def</span> <span class="nf">integer_elements</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Integer elements matrix predicate.</span>

<span class="sd">        ``Q.integer_elements(x)`` is true iff all the elements of ``x``</span>
<span class="sd">        are integers.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy import Q, ask, MatrixSymbol</span>
<span class="sd">        &gt;&gt;&gt; X = MatrixSymbol(&#39;X&#39;, 4, 4)</span>
<span class="sd">        &gt;&gt;&gt; ask(Q.integer(X[1, 2]), Q.integer_elements(X))</span>
<span class="sd">        True</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Predicate</span><span class="p">(</span><span class="s1">&#39;integer_elements&#39;</span><span class="p">)</span>

    <span class="nd">@predicate_memo</span>
    <span class="k">def</span> <span class="nf">real_elements</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Real elements matrix predicate.</span>

<span class="sd">        ``Q.real_elements(x)`` is true iff all the elements of ``x``</span>
<span class="sd">        are real numbers.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy import Q, ask, MatrixSymbol</span>
<span class="sd">        &gt;&gt;&gt; X = MatrixSymbol(&#39;X&#39;, 4, 4)</span>
<span class="sd">        &gt;&gt;&gt; ask(Q.real(X[1, 2]), Q.real_elements(X))</span>
<span class="sd">        True</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Predicate</span><span class="p">(</span><span class="s1">&#39;real_elements&#39;</span><span class="p">)</span>

    <span class="nd">@predicate_memo</span>
    <span class="k">def</span> <span class="nf">complex_elements</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Complex elements matrix predicate.</span>

<span class="sd">        ``Q.complex_elements(x)`` is true iff all the elements of ``x``</span>
<span class="sd">        are complex numbers.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy import Q, ask, MatrixSymbol</span>
<span class="sd">        &gt;&gt;&gt; X = MatrixSymbol(&#39;X&#39;, 4, 4)</span>
<span class="sd">        &gt;&gt;&gt; ask(Q.complex(X[1, 2]), Q.complex_elements(X))</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; ask(Q.complex_elements(X), Q.integer_elements(X))</span>
<span class="sd">        True</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Predicate</span><span class="p">(</span><span class="s1">&#39;complex_elements&#39;</span><span class="p">)</span>

    <span class="nd">@predicate_memo</span>
    <span class="k">def</span> <span class="nf">singular</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Singular matrix predicate.</span>

<span class="sd">        A matrix is singular iff the value of its determinant is 0.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy import Q, ask, MatrixSymbol</span>
<span class="sd">        &gt;&gt;&gt; X = MatrixSymbol(&#39;X&#39;, 4, 4)</span>
<span class="sd">        &gt;&gt;&gt; ask(Q.singular(X), Q.invertible(X))</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; ask(Q.singular(X), ~Q.invertible(X))</span>
<span class="sd">        True</span>

<span class="sd">        References</span>
<span class="sd">        ==========</span>

<span class="sd">        .. [1] http://mathworld.wolfram.com/SingularMatrix.html</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Predicate</span><span class="p">(</span><span class="s1">&#39;singular&#39;</span><span class="p">)</span>

    <span class="nd">@predicate_memo</span>
    <span class="k">def</span> <span class="nf">normal</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Normal matrix predicate.</span>

<span class="sd">        A matrix is normal if it commutes with its conjugate transpose.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy import Q, ask, MatrixSymbol</span>
<span class="sd">        &gt;&gt;&gt; X = MatrixSymbol(&#39;X&#39;, 4, 4)</span>
<span class="sd">        &gt;&gt;&gt; ask(Q.normal(X), Q.unitary(X))</span>
<span class="sd">        True</span>

<span class="sd">        References</span>
<span class="sd">        ==========</span>

<span class="sd">        .. [1] https://en.wikipedia.org/wiki/Normal_matrix</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Predicate</span><span class="p">(</span><span class="s1">&#39;normal&#39;</span><span class="p">)</span>

    <span class="nd">@predicate_memo</span>
    <span class="k">def</span> <span class="nf">triangular</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Triangular matrix predicate.</span>

<span class="sd">        ``Q.triangular(X)`` is true if ``X`` is one that is either lower</span>
<span class="sd">        triangular or upper triangular.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>
<span class="sd">        &gt;&gt;&gt; from sympy import Q, ask, MatrixSymbol</span>
<span class="sd">        &gt;&gt;&gt; X = MatrixSymbol(&#39;X&#39;, 4, 4)</span>
<span class="sd">        &gt;&gt;&gt; ask(Q.triangular(X), Q.upper_triangular(X))</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; ask(Q.triangular(X), Q.lower_triangular(X))</span>
<span class="sd">        True</span>

<span class="sd">        References</span>
<span class="sd">        ==========</span>

<span class="sd">        .. [1] https://en.wikipedia.org/wiki/Triangular_matrix</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Predicate</span><span class="p">(</span><span class="s1">&#39;triangular&#39;</span><span class="p">)</span>

    <span class="nd">@predicate_memo</span>
    <span class="k">def</span> <span class="nf">unit_triangular</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Unit triangular matrix predicate.</span>

<span class="sd">        A unit triangular matrix is a triangular matrix with 1s</span>
<span class="sd">        on the diagonal.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy import Q, ask, MatrixSymbol</span>
<span class="sd">        &gt;&gt;&gt; X = MatrixSymbol(&#39;X&#39;, 4, 4)</span>
<span class="sd">        &gt;&gt;&gt; ask(Q.triangular(X), Q.unit_triangular(X))</span>
<span class="sd">        True</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Predicate</span><span class="p">(</span><span class="s1">&#39;unit_triangular&#39;</span><span class="p">)</span></div>


<span class="n">Q</span> <span class="o">=</span> <span class="n">AssumptionKeys</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">_extract_facts</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">symbol</span><span class="p">,</span> <span class="n">check_reversed_rel</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Helper for ask().</span>

<span class="sd">    Extracts the facts relevant to the symbol from an assumption.</span>
<span class="sd">    Returns None if there is nothing to extract.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">symbol</span><span class="p">,</span> <span class="n">Relational</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">check_reversed_rel</span><span class="p">:</span>
            <span class="n">rev</span> <span class="o">=</span> <span class="n">_extract_facts</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">symbol</span><span class="o">.</span><span class="n">reversed</span><span class="p">,</span> <span class="bp">False</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">rev</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">rev</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
        <span class="k">return</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">expr</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">symbol</span><span class="p">):</span>
        <span class="k">return</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">AppliedPredicate</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">expr</span><span class="o">.</span><span class="n">arg</span> <span class="o">==</span> <span class="n">symbol</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">expr</span><span class="o">.</span><span class="n">func</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">Not</span><span class="p">)</span> <span class="ow">and</span> <span class="n">expr</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">func</span> <span class="ow">in</span> <span class="p">(</span><span class="n">And</span><span class="p">,</span> <span class="n">Or</span><span class="p">):</span>
        <span class="n">cls</span> <span class="o">=</span> <span class="n">Or</span> <span class="k">if</span> <span class="n">expr</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">And</span> <span class="k">else</span> <span class="n">And</span>
        <span class="n">expr</span> <span class="o">=</span> <span class="n">cls</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="o">~</span><span class="n">arg</span> <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">expr</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">args</span><span class="p">])</span>
    <span class="n">args</span> <span class="o">=</span> <span class="p">[</span><span class="n">_extract_facts</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">symbol</span><span class="p">)</span> <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">expr</span><span class="o">.</span><span class="n">args</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">And</span><span class="p">):</span>
        <span class="n">args</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">args</span> <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">args</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">expr</span><span class="o">.</span><span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">args</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span><span class="n">x</span> <span class="o">!=</span> <span class="bp">None</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">args</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">expr</span><span class="o">.</span><span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>


<div class="viewcode-block" id="ask"><a class="viewcode-back" href="../../../modules/assumptions/index.html#sympy.assumptions.ask.ask">[docs]</a><span class="k">def</span> <span class="nf">ask</span><span class="p">(</span><span class="n">proposition</span><span class="p">,</span> <span class="n">assumptions</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">context</span><span class="o">=</span><span class="n">global_assumptions</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Method for inferring properties about objects.</span>

<span class="sd">    **Syntax**</span>

<span class="sd">        * ask(proposition)</span>

<span class="sd">        * ask(proposition, assumptions)</span>

<span class="sd">            where ``proposition`` is any boolean expression</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy import ask, Q, pi</span>
<span class="sd">    &gt;&gt;&gt; from sympy.abc import x, y</span>
<span class="sd">    &gt;&gt;&gt; ask(Q.rational(pi))</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; ask(Q.even(x*y), Q.even(x) &amp; Q.integer(y))</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; ask(Q.prime(x*y), Q.integer(x) &amp;  Q.integer(y))</span>
<span class="sd">    False</span>

<span class="sd">    **Remarks**</span>
<span class="sd">        Relations in assumptions are not implemented (yet), so the following</span>
<span class="sd">        will not give a meaningful result.</span>

<span class="sd">        &gt;&gt;&gt; ask(Q.positive(x), Q.is_true(x &gt; 0)) # doctest: +SKIP</span>

<span class="sd">        It is however a work in progress.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">sympy.assumptions.satask</span> <span class="kn">import</span> <span class="n">satask</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">proposition</span><span class="p">,</span> <span class="p">(</span><span class="n">BooleanFunction</span><span class="p">,</span> <span class="n">AppliedPredicate</span><span class="p">,</span> <span class="nb">bool</span><span class="p">,</span> <span class="n">BooleanAtom</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;proposition must be a valid logical expression&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">assumptions</span><span class="p">,</span> <span class="p">(</span><span class="n">BooleanFunction</span><span class="p">,</span> <span class="n">AppliedPredicate</span><span class="p">,</span> <span class="nb">bool</span><span class="p">,</span> <span class="n">BooleanAtom</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;assumptions must be a valid logical expression&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">proposition</span><span class="p">,</span> <span class="n">AppliedPredicate</span><span class="p">):</span>
        <span class="n">key</span><span class="p">,</span> <span class="n">expr</span> <span class="o">=</span> <span class="n">proposition</span><span class="o">.</span><span class="n">func</span><span class="p">,</span> <span class="n">sympify</span><span class="p">(</span><span class="n">proposition</span><span class="o">.</span><span class="n">arg</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">key</span><span class="p">,</span> <span class="n">expr</span> <span class="o">=</span> <span class="n">Q</span><span class="o">.</span><span class="n">is_true</span><span class="p">,</span> <span class="n">sympify</span><span class="p">(</span><span class="n">proposition</span><span class="p">)</span>

    <span class="n">assumptions</span> <span class="o">=</span> <span class="n">And</span><span class="p">(</span><span class="n">assumptions</span><span class="p">,</span> <span class="n">And</span><span class="p">(</span><span class="o">*</span><span class="n">context</span><span class="p">))</span>
    <span class="n">assumptions</span> <span class="o">=</span> <span class="n">to_cnf</span><span class="p">(</span><span class="n">assumptions</span><span class="p">)</span>

    <span class="n">local_facts</span> <span class="o">=</span> <span class="n">_extract_facts</span><span class="p">(</span><span class="n">assumptions</span><span class="p">,</span> <span class="n">expr</span><span class="p">)</span>

    <span class="n">known_facts_cnf</span> <span class="o">=</span> <span class="n">get_known_facts_cnf</span><span class="p">()</span>
    <span class="n">known_facts_dict</span> <span class="o">=</span> <span class="n">get_known_facts_dict</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">local_facts</span> <span class="ow">and</span> <span class="n">satisfiable</span><span class="p">(</span><span class="n">And</span><span class="p">(</span><span class="n">local_facts</span><span class="p">,</span> <span class="n">known_facts_cnf</span><span class="p">))</span> <span class="ow">is</span> <span class="bp">False</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;inconsistent assumptions </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">assumptions</span><span class="p">)</span>

    <span class="c1"># direct resolution method, no logic</span>
    <span class="n">res</span> <span class="o">=</span> <span class="n">key</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span><span class="o">.</span><span class="n">_eval_ask</span><span class="p">(</span><span class="n">assumptions</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">res</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">bool</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">local_facts</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">satask</span><span class="p">(</span><span class="n">proposition</span><span class="p">,</span> <span class="n">assumptions</span><span class="o">=</span><span class="n">assumptions</span><span class="p">,</span> <span class="n">context</span><span class="o">=</span><span class="n">context</span><span class="p">)</span>


    <span class="c1"># See if there&#39;s a straight-forward conclusion we can make for the inference</span>
    <span class="k">if</span> <span class="n">local_facts</span><span class="o">.</span><span class="n">is_Atom</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">known_facts_dict</span><span class="p">[</span><span class="n">local_facts</span><span class="p">]:</span>
            <span class="k">return</span> <span class="bp">True</span>
        <span class="k">if</span> <span class="n">Not</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="ow">in</span> <span class="n">known_facts_dict</span><span class="p">[</span><span class="n">local_facts</span><span class="p">]:</span>
            <span class="k">return</span> <span class="bp">False</span>
    <span class="k">elif</span> <span class="p">(</span><span class="n">local_facts</span><span class="o">.</span><span class="n">func</span> <span class="ow">is</span> <span class="n">And</span> <span class="ow">and</span>
            <span class="nb">all</span><span class="p">(</span><span class="n">k</span> <span class="ow">in</span> <span class="n">known_facts_dict</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">local_facts</span><span class="o">.</span><span class="n">args</span><span class="p">)):</span>
        <span class="k">for</span> <span class="n">assum</span> <span class="ow">in</span> <span class="n">local_facts</span><span class="o">.</span><span class="n">args</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">assum</span><span class="o">.</span><span class="n">is_Atom</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">known_facts_dict</span><span class="p">[</span><span class="n">assum</span><span class="p">]:</span>
                    <span class="k">return</span> <span class="bp">True</span>
                <span class="k">if</span> <span class="n">Not</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="ow">in</span> <span class="n">known_facts_dict</span><span class="p">[</span><span class="n">assum</span><span class="p">]:</span>
                    <span class="k">return</span> <span class="bp">False</span>
            <span class="k">elif</span> <span class="n">assum</span><span class="o">.</span><span class="n">func</span> <span class="ow">is</span> <span class="n">Not</span> <span class="ow">and</span> <span class="n">assum</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">is_Atom</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">known_facts_dict</span><span class="p">[</span><span class="n">assum</span><span class="p">]:</span>
                    <span class="k">return</span> <span class="bp">False</span>
                <span class="k">if</span> <span class="n">Not</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="ow">in</span> <span class="n">known_facts_dict</span><span class="p">[</span><span class="n">assum</span><span class="p">]:</span>
                    <span class="k">return</span> <span class="bp">True</span>
    <span class="k">elif</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">Predicate</span><span class="p">)</span> <span class="ow">and</span>
            <span class="n">local_facts</span><span class="o">.</span><span class="n">func</span> <span class="ow">is</span> <span class="n">Not</span> <span class="ow">and</span> <span class="n">local_facts</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">is_Atom</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">local_facts</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="n">known_facts_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]:</span>
            <span class="k">return</span> <span class="bp">False</span>

    <span class="c1"># Failing all else, we do a full logical inference</span>
    <span class="n">res</span> <span class="o">=</span> <span class="n">ask_full_inference</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">local_facts</span><span class="p">,</span> <span class="n">known_facts_cnf</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">res</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">satask</span><span class="p">(</span><span class="n">proposition</span><span class="p">,</span> <span class="n">assumptions</span><span class="o">=</span><span class="n">assumptions</span><span class="p">,</span> <span class="n">context</span><span class="o">=</span><span class="n">context</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">res</span></div>


<div class="viewcode-block" id="ask_full_inference"><a class="viewcode-back" href="../../../modules/assumptions/ask.html#sympy.assumptions.ask.ask_full_inference">[docs]</a><span class="k">def</span> <span class="nf">ask_full_inference</span><span class="p">(</span><span class="n">proposition</span><span class="p">,</span> <span class="n">assumptions</span><span class="p">,</span> <span class="n">known_facts_cnf</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Method for inferring properties about objects.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">satisfiable</span><span class="p">(</span><span class="n">And</span><span class="p">(</span><span class="n">known_facts_cnf</span><span class="p">,</span> <span class="n">assumptions</span><span class="p">,</span> <span class="n">proposition</span><span class="p">)):</span>
        <span class="k">return</span> <span class="bp">False</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">satisfiable</span><span class="p">(</span><span class="n">And</span><span class="p">(</span><span class="n">known_facts_cnf</span><span class="p">,</span> <span class="n">assumptions</span><span class="p">,</span> <span class="n">Not</span><span class="p">(</span><span class="n">proposition</span><span class="p">))):</span>
        <span class="k">return</span> <span class="bp">True</span>
    <span class="k">return</span> <span class="bp">None</span></div>


<div class="viewcode-block" id="register_handler"><a class="viewcode-back" href="../../../modules/assumptions/index.html#sympy.assumptions.ask.register_handler">[docs]</a><span class="k">def</span> <span class="nf">register_handler</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">handler</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Register a handler in the ask system. key must be a string and handler a</span>
<span class="sd">    class inheriting from AskHandler::</span>

<span class="sd">        &gt;&gt;&gt; from sympy.assumptions import register_handler, ask, Q</span>
<span class="sd">        &gt;&gt;&gt; from sympy.assumptions.handlers import AskHandler</span>
<span class="sd">        &gt;&gt;&gt; class MersenneHandler(AskHandler):</span>
<span class="sd">        ...     # Mersenne numbers are in the form 2**n + 1, n integer</span>
<span class="sd">        ...     @staticmethod</span>
<span class="sd">        ...     def Integer(expr, assumptions):</span>
<span class="sd">        ...         from sympy import log</span>
<span class="sd">        ...         return ask(Q.integer(log(expr + 1, 2)))</span>
<span class="sd">        &gt;&gt;&gt; register_handler(&#39;mersenne&#39;, MersenneHandler)</span>
<span class="sd">        &gt;&gt;&gt; ask(Q.mersenne(7))</span>
<span class="sd">        True</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="ow">is</span> <span class="n">Predicate</span><span class="p">:</span>
        <span class="n">key</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="n">name</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="nb">getattr</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span><span class="o">.</span><span class="n">add_handler</span><span class="p">(</span><span class="n">handler</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
        <span class="nb">setattr</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">Predicate</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">handlers</span><span class="o">=</span><span class="p">[</span><span class="n">handler</span><span class="p">]))</span></div>


<div class="viewcode-block" id="remove_handler"><a class="viewcode-back" href="../../../modules/assumptions/index.html#sympy.assumptions.ask.remove_handler">[docs]</a><span class="k">def</span> <span class="nf">remove_handler</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">handler</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Removes a handler from the ask system. Same syntax as register_handler&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="ow">is</span> <span class="n">Predicate</span><span class="p">:</span>
        <span class="n">key</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="n">name</span>
    <span class="nb">getattr</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span><span class="o">.</span><span class="n">remove_handler</span><span class="p">(</span><span class="n">handler</span><span class="p">)</span></div>


<span class="k">def</span> <span class="nf">single_fact_lookup</span><span class="p">(</span><span class="n">known_facts_keys</span><span class="p">,</span> <span class="n">known_facts_cnf</span><span class="p">):</span>
    <span class="c1"># Compute the quick lookup for single facts</span>
    <span class="n">mapping</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">known_facts_keys</span><span class="p">:</span>
        <span class="n">mapping</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="n">key</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">other_key</span> <span class="ow">in</span> <span class="n">known_facts_keys</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">other_key</span> <span class="o">!=</span> <span class="n">key</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">ask_full_inference</span><span class="p">(</span><span class="n">other_key</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">known_facts_cnf</span><span class="p">):</span>
                    <span class="n">mapping</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">other_key</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">mapping</span>


<div class="viewcode-block" id="compute_known_facts"><a class="viewcode-back" href="../../../modules/assumptions/ask.html#sympy.assumptions.ask.compute_known_facts">[docs]</a><span class="k">def</span> <span class="nf">compute_known_facts</span><span class="p">(</span><span class="n">known_facts</span><span class="p">,</span> <span class="n">known_facts_keys</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute the various forms of knowledge compilation used by the</span>
<span class="sd">    assumptions system.</span>

<span class="sd">    This function is typically applied to the results of the ``get_known_facts``</span>
<span class="sd">    and ``get_known_facts_keys`` functions defined at the bottom of</span>
<span class="sd">    this file.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">textwrap</span> <span class="kn">import</span> <span class="n">dedent</span><span class="p">,</span> <span class="n">wrap</span>

    <span class="n">fact_string</span> <span class="o">=</span> <span class="n">dedent</span><span class="p">(</span><span class="s1">&#39;&#39;&#39;</span><span class="se">\</span>
<span class="s1">    &quot;&quot;&quot;</span>
<span class="s1">    The contents of this file are the return value of</span>
<span class="s1">    ``sympy.assumptions.ask.compute_known_facts``.</span>

<span class="s1">    Do NOT manually edit this file.</span>
<span class="s1">    Instead, run ./bin/ask_update.py.</span>
<span class="s1">    &quot;&quot;&quot;</span>

<span class="s1">    from sympy.core.cache import cacheit</span>
<span class="s1">    from sympy.logic.boolalg import And, Not, Or</span>
<span class="s1">    from sympy.assumptions.ask import Q</span>

<span class="s1">    # -{ Known facts in Conjunctive Normal Form }-</span>
<span class="s1">    @cacheit</span>
<span class="s1">    def get_known_facts_cnf():</span>
<span class="s1">        return And(</span>
<span class="s1">            </span><span class="si">%s</span><span class="s1"></span>
<span class="s1">        )</span>

<span class="s1">    # -{ Known facts in compressed sets }-</span>
<span class="s1">    @cacheit</span>
<span class="s1">    def get_known_facts_dict():</span>
<span class="s1">        return {</span>
<span class="s1">            </span><span class="si">%s</span><span class="s1"></span>
<span class="s1">        }</span>
<span class="s1">    &#39;&#39;&#39;</span><span class="p">)</span>
    <span class="c1"># Compute the known facts in CNF form for logical inference</span>
    <span class="n">LINE</span> <span class="o">=</span> <span class="s2">&quot;,</span><span class="se">\n</span><span class="s2">        &quot;</span>
    <span class="n">HANG</span> <span class="o">=</span> <span class="s1">&#39; &#39;</span><span class="o">*</span><span class="mi">8</span>
    <span class="n">cnf</span> <span class="o">=</span> <span class="n">to_cnf</span><span class="p">(</span><span class="n">known_facts</span><span class="p">)</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">LINE</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">cnf</span><span class="o">.</span><span class="n">args</span><span class="p">])</span>
    <span class="n">mapping</span> <span class="o">=</span> <span class="n">single_fact_lookup</span><span class="p">(</span><span class="n">known_facts_keys</span><span class="p">,</span> <span class="n">cnf</span><span class="p">)</span>
    <span class="n">items</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">mapping</span><span class="o">.</span><span class="n">items</span><span class="p">(),</span> <span class="n">key</span><span class="o">=</span><span class="nb">str</span><span class="p">)</span>
    <span class="n">keys</span> <span class="o">=</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">items</span><span class="p">]</span>
    <span class="n">values</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;set(</span><span class="si">%s</span><span class="s1">)&#39;</span> <span class="o">%</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">i</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">key</span><span class="o">=</span><span class="nb">str</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">items</span><span class="p">]</span>
    <span class="n">m</span> <span class="o">=</span> <span class="n">LINE</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
        <span class="n">wrap</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">),</span>
            <span class="n">subsequent_indent</span><span class="o">=</span><span class="n">HANG</span><span class="p">,</span>
            <span class="n">break_long_words</span><span class="o">=</span><span class="bp">False</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">keys</span><span class="p">,</span> <span class="n">values</span><span class="p">)])</span> <span class="o">+</span> <span class="s1">&#39;,&#39;</span>
    <span class="k">return</span> <span class="n">fact_string</span> <span class="o">%</span> <span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span></div>

<span class="c1"># handlers tells us what ask handler we should use</span>
<span class="c1"># for a particular key</span>
<span class="n">_val_template</span> <span class="o">=</span> <span class="s1">&#39;sympy.assumptions.handlers.</span><span class="si">%s</span><span class="s1">&#39;</span>
<span class="n">_handlers</span> <span class="o">=</span> <span class="p">[</span>
    <span class="p">(</span><span class="s2">&quot;antihermitian&quot;</span><span class="p">,</span>     <span class="s2">&quot;sets.AskAntiHermitianHandler&quot;</span><span class="p">),</span>
    <span class="p">(</span><span class="s2">&quot;finite&quot;</span><span class="p">,</span>           <span class="s2">&quot;calculus.AskFiniteHandler&quot;</span><span class="p">),</span>
    <span class="p">(</span><span class="s2">&quot;commutative&quot;</span><span class="p">,</span>       <span class="s2">&quot;AskCommutativeHandler&quot;</span><span class="p">),</span>
    <span class="p">(</span><span class="s2">&quot;complex&quot;</span><span class="p">,</span>           <span class="s2">&quot;sets.AskComplexHandler&quot;</span><span class="p">),</span>
    <span class="p">(</span><span class="s2">&quot;composite&quot;</span><span class="p">,</span>         <span class="s2">&quot;ntheory.AskCompositeHandler&quot;</span><span class="p">),</span>
    <span class="p">(</span><span class="s2">&quot;even&quot;</span><span class="p">,</span>              <span class="s2">&quot;ntheory.AskEvenHandler&quot;</span><span class="p">),</span>
    <span class="p">(</span><span class="s2">&quot;extended_real&quot;</span><span class="p">,</span>     <span class="s2">&quot;sets.AskExtendedRealHandler&quot;</span><span class="p">),</span>
    <span class="p">(</span><span class="s2">&quot;hermitian&quot;</span><span class="p">,</span>         <span class="s2">&quot;sets.AskHermitianHandler&quot;</span><span class="p">),</span>
    <span class="p">(</span><span class="s2">&quot;imaginary&quot;</span><span class="p">,</span>         <span class="s2">&quot;sets.AskImaginaryHandler&quot;</span><span class="p">),</span>
    <span class="p">(</span><span class="s2">&quot;integer&quot;</span><span class="p">,</span>           <span class="s2">&quot;sets.AskIntegerHandler&quot;</span><span class="p">),</span>
    <span class="p">(</span><span class="s2">&quot;irrational&quot;</span><span class="p">,</span>        <span class="s2">&quot;sets.AskIrrationalHandler&quot;</span><span class="p">),</span>
    <span class="p">(</span><span class="s2">&quot;rational&quot;</span><span class="p">,</span>          <span class="s2">&quot;sets.AskRationalHandler&quot;</span><span class="p">),</span>
    <span class="p">(</span><span class="s2">&quot;negative&quot;</span><span class="p">,</span>          <span class="s2">&quot;order.AskNegativeHandler&quot;</span><span class="p">),</span>
    <span class="p">(</span><span class="s2">&quot;nonzero&quot;</span><span class="p">,</span>           <span class="s2">&quot;order.AskNonZeroHandler&quot;</span><span class="p">),</span>
    <span class="p">(</span><span class="s2">&quot;nonpositive&quot;</span><span class="p">,</span>       <span class="s2">&quot;order.AskNonPositiveHandler&quot;</span><span class="p">),</span>
    <span class="p">(</span><span class="s2">&quot;nonnegative&quot;</span><span class="p">,</span>       <span class="s2">&quot;order.AskNonNegativeHandler&quot;</span><span class="p">),</span>
    <span class="p">(</span><span class="s2">&quot;zero&quot;</span><span class="p">,</span>              <span class="s2">&quot;order.AskZeroHandler&quot;</span><span class="p">),</span>
    <span class="p">(</span><span class="s2">&quot;positive&quot;</span><span class="p">,</span>          <span class="s2">&quot;order.AskPositiveHandler&quot;</span><span class="p">),</span>
    <span class="p">(</span><span class="s2">&quot;prime&quot;</span><span class="p">,</span>             <span class="s2">&quot;ntheory.AskPrimeHandler&quot;</span><span class="p">),</span>
    <span class="p">(</span><span class="s2">&quot;real&quot;</span><span class="p">,</span>              <span class="s2">&quot;sets.AskRealHandler&quot;</span><span class="p">),</span>
    <span class="p">(</span><span class="s2">&quot;odd&quot;</span><span class="p">,</span>               <span class="s2">&quot;ntheory.AskOddHandler&quot;</span><span class="p">),</span>
    <span class="p">(</span><span class="s2">&quot;algebraic&quot;</span><span class="p">,</span>         <span class="s2">&quot;sets.AskAlgebraicHandler&quot;</span><span class="p">),</span>
    <span class="p">(</span><span class="s2">&quot;is_true&quot;</span><span class="p">,</span>           <span class="s2">&quot;common.TautologicalHandler&quot;</span><span class="p">),</span>
    <span class="p">(</span><span class="s2">&quot;symmetric&quot;</span><span class="p">,</span>         <span class="s2">&quot;matrices.AskSymmetricHandler&quot;</span><span class="p">),</span>
    <span class="p">(</span><span class="s2">&quot;invertible&quot;</span><span class="p">,</span>        <span class="s2">&quot;matrices.AskInvertibleHandler&quot;</span><span class="p">),</span>
    <span class="p">(</span><span class="s2">&quot;orthogonal&quot;</span><span class="p">,</span>        <span class="s2">&quot;matrices.AskOrthogonalHandler&quot;</span><span class="p">),</span>
    <span class="p">(</span><span class="s2">&quot;unitary&quot;</span><span class="p">,</span>           <span class="s2">&quot;matrices.AskUnitaryHandler&quot;</span><span class="p">),</span>
    <span class="p">(</span><span class="s2">&quot;positive_definite&quot;</span><span class="p">,</span> <span class="s2">&quot;matrices.AskPositiveDefiniteHandler&quot;</span><span class="p">),</span>
    <span class="p">(</span><span class="s2">&quot;upper_triangular&quot;</span><span class="p">,</span>  <span class="s2">&quot;matrices.AskUpperTriangularHandler&quot;</span><span class="p">),</span>
    <span class="p">(</span><span class="s2">&quot;lower_triangular&quot;</span><span class="p">,</span>  <span class="s2">&quot;matrices.AskLowerTriangularHandler&quot;</span><span class="p">),</span>
    <span class="p">(</span><span class="s2">&quot;diagonal&quot;</span><span class="p">,</span>          <span class="s2">&quot;matrices.AskDiagonalHandler&quot;</span><span class="p">),</span>
    <span class="p">(</span><span class="s2">&quot;fullrank&quot;</span><span class="p">,</span>          <span class="s2">&quot;matrices.AskFullRankHandler&quot;</span><span class="p">),</span>
    <span class="p">(</span><span class="s2">&quot;square&quot;</span><span class="p">,</span>            <span class="s2">&quot;matrices.AskSquareHandler&quot;</span><span class="p">),</span>
    <span class="p">(</span><span class="s2">&quot;integer_elements&quot;</span><span class="p">,</span>  <span class="s2">&quot;matrices.AskIntegerElementsHandler&quot;</span><span class="p">),</span>
    <span class="p">(</span><span class="s2">&quot;real_elements&quot;</span><span class="p">,</span>     <span class="s2">&quot;matrices.AskRealElementsHandler&quot;</span><span class="p">),</span>
    <span class="p">(</span><span class="s2">&quot;complex_elements&quot;</span><span class="p">,</span>  <span class="s2">&quot;matrices.AskComplexElementsHandler&quot;</span><span class="p">),</span>
<span class="p">]</span>

<span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">_handlers</span><span class="p">:</span>
    <span class="n">register_handler</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">_val_template</span> <span class="o">%</span> <span class="n">value</span><span class="p">)</span>

<span class="nd">@cacheit</span>
<span class="k">def</span> <span class="nf">get_known_facts_keys</span><span class="p">():</span>
    <span class="k">return</span> <span class="p">[</span>
        <span class="nb">getattr</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span> <span class="n">attr</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="n">Q</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__dict__</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">attr</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;__&#39;</span><span class="p">)</span> <span class="ow">or</span>
                <span class="n">attr</span> <span class="ow">in</span> <span class="n">deprecated_predicates</span><span class="p">)]</span>

<span class="nd">@cacheit</span>
<span class="k">def</span> <span class="nf">get_known_facts</span><span class="p">():</span>
    <span class="k">return</span> <span class="n">And</span><span class="p">(</span>
        <span class="n">Implies</span><span class="p">(</span><span class="n">Q</span><span class="o">.</span><span class="n">infinite</span><span class="p">,</span> <span class="o">~</span><span class="n">Q</span><span class="o">.</span><span class="n">finite</span><span class="p">),</span>
        <span class="n">Implies</span><span class="p">(</span><span class="n">Q</span><span class="o">.</span><span class="n">real</span><span class="p">,</span> <span class="n">Q</span><span class="o">.</span><span class="n">complex</span><span class="p">),</span>
        <span class="n">Implies</span><span class="p">(</span><span class="n">Q</span><span class="o">.</span><span class="n">real</span><span class="p">,</span> <span class="n">Q</span><span class="o">.</span><span class="n">hermitian</span><span class="p">),</span>
        <span class="n">Equivalent</span><span class="p">(</span><span class="n">Q</span><span class="o">.</span><span class="n">extended_real</span><span class="p">,</span> <span class="n">Q</span><span class="o">.</span><span class="n">real</span> <span class="o">|</span> <span class="n">Q</span><span class="o">.</span><span class="n">infinite</span><span class="p">),</span>
        <span class="n">Equivalent</span><span class="p">(</span><span class="n">Q</span><span class="o">.</span><span class="n">even</span> <span class="o">|</span> <span class="n">Q</span><span class="o">.</span><span class="n">odd</span><span class="p">,</span> <span class="n">Q</span><span class="o">.</span><span class="n">integer</span><span class="p">),</span>
        <span class="n">Implies</span><span class="p">(</span><span class="n">Q</span><span class="o">.</span><span class="n">even</span><span class="p">,</span> <span class="o">~</span><span class="n">Q</span><span class="o">.</span><span class="n">odd</span><span class="p">),</span>
        <span class="n">Equivalent</span><span class="p">(</span><span class="n">Q</span><span class="o">.</span><span class="n">prime</span><span class="p">,</span> <span class="n">Q</span><span class="o">.</span><span class="n">integer</span> <span class="o">&amp;</span> <span class="n">Q</span><span class="o">.</span><span class="n">positive</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">Q</span><span class="o">.</span><span class="n">composite</span><span class="p">),</span>
        <span class="n">Implies</span><span class="p">(</span><span class="n">Q</span><span class="o">.</span><span class="n">integer</span><span class="p">,</span> <span class="n">Q</span><span class="o">.</span><span class="n">rational</span><span class="p">),</span>
        <span class="n">Implies</span><span class="p">(</span><span class="n">Q</span><span class="o">.</span><span class="n">rational</span><span class="p">,</span> <span class="n">Q</span><span class="o">.</span><span class="n">algebraic</span><span class="p">),</span>
        <span class="n">Implies</span><span class="p">(</span><span class="n">Q</span><span class="o">.</span><span class="n">algebraic</span><span class="p">,</span> <span class="n">Q</span><span class="o">.</span><span class="n">complex</span><span class="p">),</span>
        <span class="n">Equivalent</span><span class="p">(</span><span class="n">Q</span><span class="o">.</span><span class="n">transcendental</span> <span class="o">|</span> <span class="n">Q</span><span class="o">.</span><span class="n">algebraic</span><span class="p">,</span> <span class="n">Q</span><span class="o">.</span><span class="n">complex</span><span class="p">),</span>
        <span class="n">Implies</span><span class="p">(</span><span class="n">Q</span><span class="o">.</span><span class="n">transcendental</span><span class="p">,</span> <span class="o">~</span><span class="n">Q</span><span class="o">.</span><span class="n">algebraic</span><span class="p">),</span>
        <span class="n">Implies</span><span class="p">(</span><span class="n">Q</span><span class="o">.</span><span class="n">imaginary</span><span class="p">,</span> <span class="n">Q</span><span class="o">.</span><span class="n">complex</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">Q</span><span class="o">.</span><span class="n">real</span><span class="p">),</span>
        <span class="n">Implies</span><span class="p">(</span><span class="n">Q</span><span class="o">.</span><span class="n">imaginary</span><span class="p">,</span> <span class="n">Q</span><span class="o">.</span><span class="n">antihermitian</span><span class="p">),</span>
        <span class="n">Implies</span><span class="p">(</span><span class="n">Q</span><span class="o">.</span><span class="n">antihermitian</span><span class="p">,</span> <span class="o">~</span><span class="n">Q</span><span class="o">.</span><span class="n">hermitian</span><span class="p">),</span>
        <span class="n">Equivalent</span><span class="p">(</span><span class="n">Q</span><span class="o">.</span><span class="n">irrational</span> <span class="o">|</span> <span class="n">Q</span><span class="o">.</span><span class="n">rational</span><span class="p">,</span> <span class="n">Q</span><span class="o">.</span><span class="n">real</span><span class="p">),</span>
        <span class="n">Implies</span><span class="p">(</span><span class="n">Q</span><span class="o">.</span><span class="n">irrational</span><span class="p">,</span> <span class="o">~</span><span class="n">Q</span><span class="o">.</span><span class="n">rational</span><span class="p">),</span>
        <span class="n">Implies</span><span class="p">(</span><span class="n">Q</span><span class="o">.</span><span class="n">zero</span><span class="p">,</span> <span class="n">Q</span><span class="o">.</span><span class="n">even</span><span class="p">),</span>

        <span class="n">Equivalent</span><span class="p">(</span><span class="n">Q</span><span class="o">.</span><span class="n">real</span><span class="p">,</span> <span class="n">Q</span><span class="o">.</span><span class="n">negative</span> <span class="o">|</span> <span class="n">Q</span><span class="o">.</span><span class="n">zero</span> <span class="o">|</span> <span class="n">Q</span><span class="o">.</span><span class="n">positive</span><span class="p">),</span>
        <span class="n">Implies</span><span class="p">(</span><span class="n">Q</span><span class="o">.</span><span class="n">zero</span><span class="p">,</span> <span class="o">~</span><span class="n">Q</span><span class="o">.</span><span class="n">negative</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">Q</span><span class="o">.</span><span class="n">positive</span><span class="p">),</span>
        <span class="n">Implies</span><span class="p">(</span><span class="n">Q</span><span class="o">.</span><span class="n">negative</span><span class="p">,</span> <span class="o">~</span><span class="n">Q</span><span class="o">.</span><span class="n">positive</span><span class="p">),</span>
        <span class="n">Equivalent</span><span class="p">(</span><span class="n">Q</span><span class="o">.</span><span class="n">nonnegative</span><span class="p">,</span> <span class="n">Q</span><span class="o">.</span><span class="n">zero</span> <span class="o">|</span> <span class="n">Q</span><span class="o">.</span><span class="n">positive</span><span class="p">),</span>
        <span class="n">Equivalent</span><span class="p">(</span><span class="n">Q</span><span class="o">.</span><span class="n">nonpositive</span><span class="p">,</span> <span class="n">Q</span><span class="o">.</span><span class="n">zero</span> <span class="o">|</span> <span class="n">Q</span><span class="o">.</span><span class="n">negative</span><span class="p">),</span>
        <span class="n">Equivalent</span><span class="p">(</span><span class="n">Q</span><span class="o">.</span><span class="n">nonzero</span><span class="p">,</span> <span class="n">Q</span><span class="o">.</span><span class="n">negative</span> <span class="o">|</span> <span class="n">Q</span><span class="o">.</span><span class="n">positive</span><span class="p">),</span>

        <span class="n">Implies</span><span class="p">(</span><span class="n">Q</span><span class="o">.</span><span class="n">orthogonal</span><span class="p">,</span> <span class="n">Q</span><span class="o">.</span><span class="n">positive_definite</span><span class="p">),</span>
        <span class="n">Implies</span><span class="p">(</span><span class="n">Q</span><span class="o">.</span><span class="n">orthogonal</span><span class="p">,</span> <span class="n">Q</span><span class="o">.</span><span class="n">unitary</span><span class="p">),</span>
        <span class="n">Implies</span><span class="p">(</span><span class="n">Q</span><span class="o">.</span><span class="n">unitary</span> <span class="o">&amp;</span> <span class="n">Q</span><span class="o">.</span><span class="n">real</span><span class="p">,</span> <span class="n">Q</span><span class="o">.</span><span class="n">orthogonal</span><span class="p">),</span>
        <span class="n">Implies</span><span class="p">(</span><span class="n">Q</span><span class="o">.</span><span class="n">unitary</span><span class="p">,</span> <span class="n">Q</span><span class="o">.</span><span class="n">normal</span><span class="p">),</span>
        <span class="n">Implies</span><span class="p">(</span><span class="n">Q</span><span class="o">.</span><span class="n">unitary</span><span class="p">,</span> <span class="n">Q</span><span class="o">.</span><span class="n">invertible</span><span class="p">),</span>
        <span class="n">Implies</span><span class="p">(</span><span class="n">Q</span><span class="o">.</span><span class="n">normal</span><span class="p">,</span> <span class="n">Q</span><span class="o">.</span><span class="n">square</span><span class="p">),</span>
        <span class="n">Implies</span><span class="p">(</span><span class="n">Q</span><span class="o">.</span><span class="n">diagonal</span><span class="p">,</span> <span class="n">Q</span><span class="o">.</span><span class="n">normal</span><span class="p">),</span>
        <span class="n">Implies</span><span class="p">(</span><span class="n">Q</span><span class="o">.</span><span class="n">positive_definite</span><span class="p">,</span> <span class="n">Q</span><span class="o">.</span><span class="n">invertible</span><span class="p">),</span>
        <span class="n">Implies</span><span class="p">(</span><span class="n">Q</span><span class="o">.</span><span class="n">diagonal</span><span class="p">,</span> <span class="n">Q</span><span class="o">.</span><span class="n">upper_triangular</span><span class="p">),</span>
        <span class="n">Implies</span><span class="p">(</span><span class="n">Q</span><span class="o">.</span><span class="n">diagonal</span><span class="p">,</span> <span class="n">Q</span><span class="o">.</span><span class="n">lower_triangular</span><span class="p">),</span>
        <span class="n">Implies</span><span class="p">(</span><span class="n">Q</span><span class="o">.</span><span class="n">lower_triangular</span><span class="p">,</span> <span class="n">Q</span><span class="o">.</span><span class="n">triangular</span><span class="p">),</span>
        <span class="n">Implies</span><span class="p">(</span><span class="n">Q</span><span class="o">.</span><span class="n">upper_triangular</span><span class="p">,</span> <span class="n">Q</span><span class="o">.</span><span class="n">triangular</span><span class="p">),</span>
        <span class="n">Implies</span><span class="p">(</span><span class="n">Q</span><span class="o">.</span><span class="n">triangular</span><span class="p">,</span> <span class="n">Q</span><span class="o">.</span><span class="n">upper_triangular</span> <span class="o">|</span> <span class="n">Q</span><span class="o">.</span><span class="n">lower_triangular</span><span class="p">),</span>
        <span class="n">Implies</span><span class="p">(</span><span class="n">Q</span><span class="o">.</span><span class="n">upper_triangular</span> <span class="o">&amp;</span> <span class="n">Q</span><span class="o">.</span><span class="n">lower_triangular</span><span class="p">,</span> <span class="n">Q</span><span class="o">.</span><span class="n">diagonal</span><span class="p">),</span>
        <span class="n">Implies</span><span class="p">(</span><span class="n">Q</span><span class="o">.</span><span class="n">diagonal</span><span class="p">,</span> <span class="n">Q</span><span class="o">.</span><span class="n">symmetric</span><span class="p">),</span>
        <span class="n">Implies</span><span class="p">(</span><span class="n">Q</span><span class="o">.</span><span class="n">unit_triangular</span><span class="p">,</span> <span class="n">Q</span><span class="o">.</span><span class="n">triangular</span><span class="p">),</span>
        <span class="n">Implies</span><span class="p">(</span><span class="n">Q</span><span class="o">.</span><span class="n">invertible</span><span class="p">,</span> <span class="n">Q</span><span class="o">.</span><span class="n">fullrank</span><span class="p">),</span>
        <span class="n">Implies</span><span class="p">(</span><span class="n">Q</span><span class="o">.</span><span class="n">invertible</span><span class="p">,</span> <span class="n">Q</span><span class="o">.</span><span class="n">square</span><span class="p">),</span>
        <span class="n">Implies</span><span class="p">(</span><span class="n">Q</span><span class="o">.</span><span class="n">symmetric</span><span class="p">,</span> <span class="n">Q</span><span class="o">.</span><span class="n">square</span><span class="p">),</span>
        <span class="n">Implies</span><span class="p">(</span><span class="n">Q</span><span class="o">.</span><span class="n">fullrank</span> <span class="o">&amp;</span> <span class="n">Q</span><span class="o">.</span><span class="n">square</span><span class="p">,</span> <span class="n">Q</span><span class="o">.</span><span class="n">invertible</span><span class="p">),</span>
        <span class="n">Equivalent</span><span class="p">(</span><span class="n">Q</span><span class="o">.</span><span class="n">invertible</span><span class="p">,</span> <span class="o">~</span><span class="n">Q</span><span class="o">.</span><span class="n">singular</span><span class="p">),</span>
        <span class="n">Implies</span><span class="p">(</span><span class="n">Q</span><span class="o">.</span><span class="n">integer_elements</span><span class="p">,</span> <span class="n">Q</span><span class="o">.</span><span class="n">real_elements</span><span class="p">),</span>
        <span class="n">Implies</span><span class="p">(</span><span class="n">Q</span><span class="o">.</span><span class="n">real_elements</span><span class="p">,</span> <span class="n">Q</span><span class="o">.</span><span class="n">complex_elements</span><span class="p">),</span>
    <span class="p">)</span>

<span class="kn">from</span> <span class="nn">sympy.assumptions.ask_generated</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">get_known_facts_dict</span><span class="p">,</span> <span class="n">get_known_facts_cnf</span><span class="p">)</span>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../../index.html">
              <img class="logo" src="../../../_static/sympylogo.png" alt="Logo"/>
            </a></p><div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../index.html">Documentation overview</a><ul>
  <li><a href="../../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2015 SymPy Development Team.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.4.1</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.7</a>
      
    </div>

    

    
  </body>
</html>