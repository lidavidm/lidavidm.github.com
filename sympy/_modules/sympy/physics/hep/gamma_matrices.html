<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>sympy.physics.hep.gamma_matrices &mdash; SymPy 1.0 documentation</title>
    
    <link rel="stylesheet" href="../../../../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="http://95.sympy-live-tests.appspot.com/static/live-core.css" type="text/css" />
    <link rel="stylesheet" href="http://95.sympy-live-tests.appspot.com/static/live-autocomplete.css" type="text/css" />
    <link rel="stylesheet" href="http://95.sympy-live-tests.appspot.com/static/live-sphinx.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../../',
        VERSION:     '1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../../_static/doctools.js"></script>
    <script type="text/javascript" src="http://95.sympy-live-tests.appspot.com/static/utilities.js"></script>
    <script type="text/javascript" src="http://95.sympy-live-tests.appspot.com/static/external/classy.js"></script>
    <script type="text/javascript" src="http://95.sympy-live-tests.appspot.com/static/live-core.js"></script>
    <script type="text/javascript" src="http://95.sympy-live-tests.appspot.com/static/live-autocomplete.js"></script>
    <script type="text/javascript" src="http://95.sympy-live-tests.appspot.com/static/live-sphinx.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML-full"></script>
    <link rel="shortcut icon" href="../../../../_static/sympy-notailtext-favicon.ico"/>
    <link rel="top" title="SymPy 1.0 documentation" href="../../../../index.html" />
    <link rel="up" title="Module code" href="../../../index.html" />
   
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head>
  <body role="document">  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for sympy.physics.hep.gamma_matrices</h1><div class="highlight"><pre>
<span></span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">S</span>
<span class="kn">from</span> <span class="nn">sympy.tensor.tensor</span> <span class="kn">import</span> <span class="n">TensorIndexType</span><span class="p">,</span> <span class="n">TensorIndex</span><span class="p">,</span>\
    <span class="n">TensMul</span><span class="p">,</span> <span class="n">TensorHead</span><span class="p">,</span> <span class="n">tensorsymmetry</span><span class="p">,</span> <span class="n">TensorType</span><span class="p">,</span>\
    <span class="n">TensAdd</span><span class="p">,</span> <span class="n">tensor_mul</span><span class="p">,</span> <span class="n">get_lines</span><span class="p">,</span> <span class="n">Tensor</span>
<span class="kn">from</span> <span class="nn">sympy.core.containers</span> <span class="kn">import</span> <span class="n">Tuple</span>
<span class="kn">from</span> <span class="nn">sympy.core.compatibility</span> <span class="kn">import</span> <span class="nb">range</span>


<span class="n">DiracSpinorIndex</span> <span class="o">=</span> <span class="n">TensorIndexType</span><span class="p">(</span><span class="s1">&#39;DiracSpinorIndex&#39;</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">dummy_fmt</span><span class="o">=</span><span class="s2">&quot;S&quot;</span><span class="p">)</span>


<div class="viewcode-block" id="_LorentzContainer"><a class="viewcode-back" href="../../../../modules/physics/hep/gamma_matrices.html#sympy.physics.hep.gamma_matrices._LorentzContainer">[docs]</a><span class="k">class</span> <span class="nc">_LorentzContainer</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Helper to collect LorentzIndex indices in various dimensions.</span>

<span class="sd">    It collects LorentzIndex TensorIndexType that have been implemented in the code,</span>
<span class="sd">    and stores them in a dict()</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">lorentz_types</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">eps_dim</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">dummy_fmt</span><span class="o">=</span><span class="s2">&quot;L&quot;</span><span class="p">):</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">eps_dim</span><span class="p">)</span> <span class="ow">in</span> <span class="n">_LorentzContainer</span><span class="o">.</span><span class="n">lorentz_types</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">_LorentzContainer</span><span class="o">.</span><span class="n">lorentz_types</span><span class="p">[(</span><span class="n">dim</span><span class="p">,</span> <span class="n">eps_dim</span><span class="p">)]</span>

        <span class="n">new_L</span> <span class="o">=</span> <span class="n">TensorIndexType</span><span class="p">(</span><span class="s2">&quot;LorentzIndex&quot;</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="n">dim</span><span class="p">,</span> <span class="n">eps_dim</span><span class="o">=</span><span class="n">eps_dim</span><span class="p">,</span> <span class="n">dummy_fmt</span><span class="o">=</span><span class="n">dummy_fmt</span><span class="p">)</span>
        <span class="n">_LorentzContainer</span><span class="o">.</span><span class="n">lorentz_types</span><span class="p">[(</span><span class="n">dim</span><span class="p">,</span> <span class="n">eps_dim</span><span class="p">)]</span> <span class="o">=</span> <span class="n">new_L</span>
        <span class="k">return</span> <span class="n">new_L</span></div>


<div class="viewcode-block" id="GammaMatrixHead"><a class="viewcode-back" href="../../../../modules/physics/hep/gamma_matrices.html#sympy.physics.hep.gamma_matrices.GammaMatrixHead">[docs]</a><span class="k">class</span> <span class="nc">GammaMatrixHead</span><span class="p">(</span><span class="n">TensorHead</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    Class to wrap a ``TensorHead`` for gamma matrices.</span>

<span class="sd">    ``dim``       dimension of the gamma matrix.</span>
<span class="sd">    ``eps_dim``   correction for dimensional regularization, use None if not needed.</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy.physics.hep.gamma_matrices import GammaMatrixHead</span>
<span class="sd">    &gt;&gt;&gt; from sympy.tensor.tensor import tensor_indices</span>
<span class="sd">    &gt;&gt;&gt; G = GammaMatrixHead()</span>
<span class="sd">    &gt;&gt;&gt; i = tensor_indices(&#39;i&#39;, G.LorentzIndex)</span>
<span class="sd">    &gt;&gt;&gt; G(i)</span>
<span class="sd">    gamma(i, auto_left, -auto_right)</span>

<span class="sd">    Note that there is already an instance of GammaMatrixHead in four dimensions:</span>
<span class="sd">    GammaMatrix, which is simply declare as</span>

<span class="sd">    ``GammaMatrix = GammaMatrixHead()``</span>

<span class="sd">    &gt;&gt;&gt; from sympy.physics.hep.gamma_matrices import GammaMatrix</span>
<span class="sd">    &gt;&gt;&gt; from sympy.tensor.tensor import tensor_indices</span>
<span class="sd">    &gt;&gt;&gt; i = tensor_indices(&#39;i&#39;, GammaMatrix.LorentzIndex)</span>
<span class="sd">    &gt;&gt;&gt; GammaMatrix(i)</span>
<span class="sd">    gamma(i, auto_left, -auto_right)</span>

<span class="sd">    To access the metric tensor</span>

<span class="sd">    &gt;&gt;&gt; GammaMatrix.LorentzIndex.metric</span>
<span class="sd">    metric(LorentzIndex,LorentzIndex)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_gmhd</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">eps_dim</span><span class="o">=</span><span class="mi">4</span><span class="p">):</span>
        <span class="n">key</span> <span class="o">=</span> <span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">eps_dim</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">GammaMatrixHead</span><span class="o">.</span><span class="n">_gmhd</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">GammaMatrixHead</span><span class="o">.</span><span class="n">_gmhd</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

        <span class="n">lorentz</span> <span class="o">=</span> <span class="n">_LorentzContainer</span><span class="p">(</span><span class="o">*</span><span class="n">key</span><span class="p">)</span>

        <span class="n">gmh</span> <span class="o">=</span> <span class="n">TensorHead</span><span class="o">.</span><span class="n">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="s2">&quot;gamma&quot;</span><span class="p">,</span> <span class="n">TensorType</span><span class="p">(</span><span class="n">Tuple</span><span class="p">(</span><span class="n">lorentz</span><span class="p">,</span> <span class="n">DiracSpinorIndex</span><span class="p">,</span> <span class="n">DiracSpinorIndex</span><span class="p">),</span> <span class="n">tensorsymmetry</span><span class="p">([</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">])),</span> <span class="n">comm</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">matrix_behavior</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="n">GammaMatrixHead</span><span class="o">.</span><span class="n">_gmhd</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">gmh</span>
        <span class="n">gmh</span><span class="o">.</span><span class="n">LorentzIndex</span> <span class="o">=</span> <span class="n">lorentz</span>
        <span class="k">return</span> <span class="n">gmh</span>

    <span class="nd">@staticmethod</span>
<div class="viewcode-block" id="GammaMatrixHead.extract_type_tens"><a class="viewcode-back" href="../../../../modules/physics/hep/gamma_matrices.html#sympy.physics.hep.gamma_matrices.GammaMatrixHead.extract_type_tens">[docs]</a>    <span class="k">def</span> <span class="nf">extract_type_tens</span><span class="p">(</span><span class="n">expression</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Extract from a ``TensExpr`` all elements of this type.</span>

<span class="sd">        Returns two tensor expressions:</span>

<span class="sd">        * the first contains all ``TensorHead`` of this type.</span>
<span class="sd">        * the second contains all remaining.</span>


<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expression</span><span class="p">,</span> <span class="n">Tensor</span><span class="p">):</span>
            <span class="n">sp</span> <span class="o">=</span> <span class="p">[</span><span class="n">expression</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expression</span><span class="p">,</span> <span class="n">TensMul</span><span class="p">):</span>
            <span class="n">sp</span> <span class="o">=</span> <span class="n">expression</span><span class="o">.</span><span class="n">args</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;wrong type&#39;</span><span class="p">)</span>

        <span class="c1"># Collect all gamma matrices of the same dimension</span>
        <span class="n">new_expr</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span>
        <span class="n">residual_expr</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">sp</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">Tensor</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">GammaMatrixHead</span><span class="p">):</span>
                <span class="n">new_expr</span> <span class="o">*=</span> <span class="n">i</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">residual_expr</span> <span class="o">*=</span> <span class="n">i</span>
        <span class="k">return</span> <span class="n">new_expr</span><span class="p">,</span> <span class="n">residual_expr</span></div>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">simplify_this_type</span><span class="p">(</span><span class="n">expression</span><span class="p">):</span>
        <span class="n">extracted_expr</span><span class="p">,</span> <span class="n">residual_expr</span> <span class="o">=</span> <span class="n">GammaMatrixHead</span><span class="o">.</span><span class="n">extract_type_tens</span><span class="p">(</span><span class="n">expression</span><span class="p">)</span>
        <span class="n">res_expr</span> <span class="o">=</span> <span class="n">GammaMatrixHead</span><span class="o">.</span><span class="n">_simplify_single_line</span><span class="p">(</span><span class="n">extracted_expr</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">res_expr</span> <span class="o">*</span> <span class="n">residual_expr</span>

    <span class="nd">@staticmethod</span>
<div class="viewcode-block" id="GammaMatrixHead.simplify_gpgp"><a class="viewcode-back" href="../../../../modules/physics/hep/gamma_matrices.html#sympy.physics.hep.gamma_matrices.GammaMatrixHead.simplify_gpgp">[docs]</a>    <span class="k">def</span> <span class="nf">simplify_gpgp</span><span class="p">(</span><span class="n">ex</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        simplify products ``G(i)*p(-i)*G(j)*p(-j) -&gt; p(i)*p(-i)``</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.physics.hep.gamma_matrices import GammaMatrix as G</span>
<span class="sd">        &gt;&gt;&gt; from sympy.tensor.tensor import tensor_indices, tensorhead</span>
<span class="sd">        &gt;&gt;&gt; p, q = tensorhead(&#39;p, q&#39;, [G.LorentzIndex], [[1]])</span>
<span class="sd">        &gt;&gt;&gt; i0,i1,i2,i3,i4,i5 = tensor_indices(&#39;i0:6&#39;, G.LorentzIndex)</span>
<span class="sd">        &gt;&gt;&gt; ps = p(i0)*G(-i0)</span>
<span class="sd">        &gt;&gt;&gt; qs = q(i0)*G(-i0)</span>
<span class="sd">        &gt;&gt;&gt; G.simplify_gpgp(ps*qs*qs)</span>
<span class="sd">        gamma(-L_0, auto_left, -auto_right)*p(L_0)*q(L_1)*q(-L_1)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span> <span class="nf">_simplify_gpgp</span><span class="p">(</span><span class="n">ex</span><span class="p">):</span>
            <span class="n">tids</span> <span class="o">=</span> <span class="n">ex</span><span class="o">.</span><span class="n">_tids</span>
            <span class="n">components</span> <span class="o">=</span> <span class="n">tids</span><span class="o">.</span><span class="n">components</span>
            <span class="n">a</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">components</span><span class="p">)):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">components</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">GammaMatrixHead</span><span class="p">):</span>
                    <span class="k">continue</span>
                <span class="n">dum</span> <span class="o">=</span> <span class="n">tids</span><span class="o">.</span><span class="n">dum</span>
                <span class="k">for</span> <span class="n">dx</span> <span class="ow">in</span> <span class="n">dum</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">dx</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="n">i</span><span class="p">:</span>
                        <span class="n">p_pos1</span> <span class="o">=</span> <span class="n">dx</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
                    <span class="k">elif</span> <span class="n">dx</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">==</span> <span class="n">i</span><span class="p">:</span>
                        <span class="n">p_pos1</span> <span class="o">=</span> <span class="n">dx</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="n">comp1</span> <span class="o">=</span> <span class="n">components</span><span class="p">[</span><span class="n">p_pos1</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">comp1</span><span class="o">.</span><span class="n">comm</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">comp1</span><span class="o">.</span><span class="n">rank</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">a</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">i</span><span class="p">,</span> <span class="n">p_pos1</span><span class="p">))</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">a</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">ex</span>
            <span class="n">elim</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
            <span class="n">tv</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">hit</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="n">coeff</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span>
            <span class="n">ta</span> <span class="o">=</span> <span class="bp">None</span>
            <span class="k">while</span> <span class="n">hit</span><span class="p">:</span>
                <span class="n">hit</span> <span class="o">=</span> <span class="bp">False</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">ai</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">a</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]):</span>
                    <span class="k">if</span> <span class="n">ai</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="n">elim</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="k">if</span> <span class="n">ai</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="k">if</span> <span class="n">components</span><span class="p">[</span><span class="n">ai</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">!=</span> <span class="n">components</span><span class="p">[</span><span class="n">a</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]]:</span>
                        <span class="k">continue</span>
                    <span class="n">elim</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">ai</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                    <span class="n">elim</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">ai</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                    <span class="n">elim</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
                    <span class="n">elim</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">ta</span><span class="p">:</span>
                        <span class="n">ta</span> <span class="o">=</span> <span class="n">ex</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
                        <span class="n">mu</span> <span class="o">=</span> <span class="n">TensorIndex</span><span class="p">(</span><span class="s1">&#39;mu&#39;</span><span class="p">,</span> <span class="n">GammaMatrix</span><span class="o">.</span><span class="n">LorentzIndex</span><span class="p">)</span>
                    <span class="n">ind1</span> <span class="o">=</span> <span class="n">ta</span><span class="p">[</span><span class="n">ai</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">get_indices</span><span class="p">()[</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">ind2</span> <span class="o">=</span> <span class="n">ta</span><span class="p">[</span><span class="n">ai</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">get_indices</span><span class="p">()[</span><span class="mi">2</span><span class="p">]</span>
                    <span class="n">hit</span> <span class="o">=</span> <span class="bp">True</span>
                    <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">coeff</span> <span class="o">=</span> <span class="n">ex</span><span class="o">.</span><span class="n">coeff</span>
                    <span class="n">tx</span> <span class="o">=</span> <span class="n">components</span><span class="p">[</span><span class="n">ai</span><span class="p">[</span><span class="mi">1</span><span class="p">]](</span><span class="n">mu</span><span class="p">)</span><span class="o">*</span><span class="n">components</span><span class="p">[</span><span class="n">ai</span><span class="p">[</span><span class="mi">1</span><span class="p">]](</span><span class="o">-</span><span class="n">mu</span><span class="p">)</span>
                    <span class="n">tv</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tx</span><span class="o">*</span><span class="n">DiracSpinorIndex</span><span class="o">.</span><span class="n">delta</span><span class="p">(</span><span class="n">ind1</span><span class="p">,</span> <span class="n">ind2</span><span class="p">))</span>
                    <span class="k">break</span>

            <span class="k">if</span> <span class="n">tv</span><span class="p">:</span>
                <span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ta</span><span class="p">)</span> <span class="k">if</span> <span class="n">j</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">elim</span><span class="p">]</span>
                <span class="n">a</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">tv</span><span class="p">)</span>
                <span class="n">t</span> <span class="o">=</span> <span class="n">tensor_mul</span><span class="p">(</span><span class="o">*</span><span class="n">a</span><span class="p">)</span><span class="o">*</span><span class="n">coeff</span>
                <span class="n">t</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">contract_metric</span><span class="p">(</span><span class="n">DiracSpinorIndex</span><span class="o">.</span><span class="n">delta</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">t</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">ex</span>

        <span class="k">if</span> <span class="n">sort</span><span class="p">:</span>
            <span class="n">ex</span> <span class="o">=</span> <span class="n">ex</span><span class="o">.</span><span class="n">sorted_components</span><span class="p">()</span>
        <span class="k">while</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">t</span> <span class="o">=</span> <span class="n">_simplify_gpgp</span><span class="p">(</span><span class="n">ex</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">t</span> <span class="o">!=</span> <span class="n">ex</span><span class="p">:</span>
                <span class="n">ex</span> <span class="o">=</span> <span class="n">t</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">t</span></div>

    <span class="nd">@staticmethod</span>
<div class="viewcode-block" id="GammaMatrixHead.simplify_lines"><a class="viewcode-back" href="../../../../modules/physics/hep/gamma_matrices.html#sympy.physics.hep.gamma_matrices.GammaMatrixHead.simplify_lines">[docs]</a>    <span class="k">def</span> <span class="nf">simplify_lines</span><span class="p">(</span><span class="n">ex</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        simplify a product of gamma matrices</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.physics.hep.gamma_matrices import GammaMatrix, DiracSpinorIndex</span>
<span class="sd">        &gt;&gt;&gt; from sympy.tensor.tensor import tensor_indices</span>
<span class="sd">        &gt;&gt;&gt; i0,i1,i2,i3,i4,i5 = tensor_indices(&#39;i0:6&#39;, GammaMatrix.LorentzIndex)</span>
<span class="sd">        &gt;&gt;&gt; s0,s1,s2,s3,s4,s5,s6,s7 = tensor_indices(&#39;s0:8&#39;, DiracSpinorIndex)</span>
<span class="sd">        &gt;&gt;&gt; G = GammaMatrix</span>
<span class="sd">        &gt;&gt;&gt; t = G(i1,s1,-s2)*G(i4,s7,-s6)*G(i2,s2,-s3)*G(i3,s4,-s5)*G(i5,s6,-s7)</span>
<span class="sd">        &gt;&gt;&gt; G.simplify_lines(t)</span>
<span class="sd">        4*gamma(i3, s4, -s5)*gamma(i1, s1, -S_0)*gamma(i2, S_0, -s3)*metric(i4, i5)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">lines</span><span class="p">,</span> <span class="n">traces</span><span class="p">,</span> <span class="n">rest</span> <span class="o">=</span> <span class="n">get_lines</span><span class="p">(</span><span class="n">ex</span><span class="p">,</span> <span class="n">DiracSpinorIndex</span><span class="p">)</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">ex</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
        <span class="n">trest</span> <span class="o">=</span> <span class="n">tensor_mul</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">rest</span><span class="p">])</span>
        <span class="n">tlines</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">lines</span><span class="p">:</span>
            <span class="n">first</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">line</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
            <span class="n">last</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">line</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
            <span class="n">first</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">first</span><span class="o">.</span><span class="n">free</span> <span class="k">if</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">last</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">last</span><span class="o">.</span><span class="n">free</span> <span class="k">if</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">tx</span> <span class="o">=</span> <span class="n">tensor_mul</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">if</span> <span class="n">i</span>  <span class="ow">in</span> <span class="n">line</span><span class="p">])</span>
            <span class="n">tx1</span> <span class="o">=</span> <span class="n">GammaMatrixHead</span><span class="o">.</span><span class="n">_simplify_single_line</span><span class="p">(</span><span class="n">tx</span><span class="p">)</span>
            <span class="n">tlines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tx1</span><span class="p">)</span>
        <span class="n">traces</span> <span class="o">=</span> <span class="p">[</span><span class="n">GammaMatrix</span><span class="o">.</span><span class="n">_trace_single_line</span><span class="p">(</span><span class="n">tensor_mul</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">if</span> <span class="n">i</span>  <span class="ow">in</span> <span class="n">line</span><span class="p">]))</span> <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">traces</span><span class="p">]</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">tensor_mul</span><span class="p">(</span><span class="o">*</span><span class="p">([</span><span class="n">trest</span><span class="p">]</span> <span class="o">+</span> <span class="n">tlines</span> <span class="o">+</span> <span class="n">traces</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">res</span></div>

<div class="viewcode-block" id="GammaMatrixHead.gamma_trace"><a class="viewcode-back" href="../../../../modules/physics/hep/gamma_matrices.html#sympy.physics.hep.gamma_matrices.GammaMatrixHead.gamma_trace">[docs]</a>    <span class="k">def</span> <span class="nf">gamma_trace</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        trace of a single line of gamma matrices</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.physics.hep.gamma_matrices import GammaMatrix as G</span>
<span class="sd">        &gt;&gt;&gt; from sympy.tensor.tensor import tensor_indices, tensorhead</span>
<span class="sd">        &gt;&gt;&gt; p, q = tensorhead(&#39;p, q&#39;, [G.LorentzIndex], [[1]])</span>
<span class="sd">        &gt;&gt;&gt; i0,i1,i2,i3,i4,i5 = tensor_indices(&#39;i0:6&#39;, G.LorentzIndex)</span>
<span class="sd">        &gt;&gt;&gt; ps = p(i0)*G(-i0)</span>
<span class="sd">        &gt;&gt;&gt; qs = q(i0)*G(-i0)</span>
<span class="sd">        &gt;&gt;&gt; G.gamma_trace(G(i0)*G(i1))</span>
<span class="sd">        4*metric(i0, i1)</span>
<span class="sd">        &gt;&gt;&gt; G.gamma_trace(ps*ps) - 4*p(i0)*p(-i0)</span>
<span class="sd">        0</span>
<span class="sd">        &gt;&gt;&gt; G.gamma_trace(ps*qs + ps*ps) - 4*p(i0)*p(-i0) - 4*p(i0)*q(-i0)</span>
<span class="sd">        0</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#assert any(x == DiracSpinorIndex.auto_right for x, p, c, in t._tids.free)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">TensAdd</span><span class="p">):</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">TensAdd</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_trace_single_line</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">t</span><span class="o">.</span><span class="n">args</span><span class="p">])</span>
            <span class="k">return</span> <span class="n">res</span>
        <span class="n">t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_simplify_single_line</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
        <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_trace_single_line</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">res</span></div>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_simplify_single_line</span><span class="p">(</span><span class="n">expression</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Simplify single-line product of gamma matrices.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.physics.hep.gamma_matrices import GammaMatrix as G, DiracSpinorIndex as DS</span>
<span class="sd">        &gt;&gt;&gt; from sympy.tensor.tensor import tensor_indices, tensorhead</span>
<span class="sd">        &gt;&gt;&gt; p = tensorhead(&#39;p&#39;, [G.LorentzIndex], [[1]])</span>
<span class="sd">        &gt;&gt;&gt; i0,i1 = tensor_indices(&#39;i0:2&#39;, G.LorentzIndex)</span>
<span class="sd">        &gt;&gt;&gt; G._simplify_single_line(G(i0)*G(i1)*p(-i1)*G(-i0)) + 2*G(i0)*p(-i0)</span>
<span class="sd">        0</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">t1</span><span class="p">,</span> <span class="n">t2</span> <span class="o">=</span> <span class="n">GammaMatrixHead</span><span class="o">.</span><span class="n">extract_type_tens</span><span class="p">(</span><span class="n">expression</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">t1</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">t1</span> <span class="o">=</span> <span class="n">GammaMatrixHead</span><span class="o">.</span><span class="n">_kahane_simplify</span><span class="p">(</span><span class="n">t1</span><span class="o">.</span><span class="n">coeff</span><span class="p">,</span> <span class="n">t1</span><span class="o">.</span><span class="n">_tids</span><span class="p">)</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">t1</span><span class="o">*</span><span class="n">t2</span>
        <span class="k">return</span> <span class="n">res</span>

    <span class="k">def</span> <span class="nf">_trace_single_line</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Evaluate the trace of a single gamma matrix line inside a ``TensExpr``.</span>

<span class="sd">        Notes</span>
<span class="sd">        =====</span>

<span class="sd">        If there are ``DiracSpinorIndex.auto_left`` and ``DiracSpinorIndex.auto_right``</span>
<span class="sd">        indices trace over them; otherwise traces are not implied (explain)</span>


<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.physics.hep.gamma_matrices import GammaMatrix as G</span>
<span class="sd">        &gt;&gt;&gt; from sympy.tensor.tensor import tensor_indices, tensorhead</span>
<span class="sd">        &gt;&gt;&gt; p = tensorhead(&#39;p&#39;, [G.LorentzIndex], [[1]])</span>
<span class="sd">        &gt;&gt;&gt; i0,i1,i2,i3,i4,i5 = tensor_indices(&#39;i0:6&#39;, G.LorentzIndex)</span>
<span class="sd">        &gt;&gt;&gt; G._trace_single_line(G(i0)*G(i1))</span>
<span class="sd">        4*metric(i0, i1)</span>
<span class="sd">        &gt;&gt;&gt; G._trace_single_line(G(i0)*p(-i0)*G(i1)*p(-i1)) - 4*p(i0)*p(-i0)</span>
<span class="sd">        0</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span> <span class="nf">_trace_single_line1</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
            <span class="n">t</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">sorted_components</span><span class="p">()</span>
            <span class="n">components</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">components</span>
            <span class="n">ncomps</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">components</span><span class="p">)</span>
            <span class="n">g</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">LorentzIndex</span><span class="o">.</span><span class="n">metric</span>
            <span class="n">sg</span> <span class="o">=</span> <span class="n">DiracSpinorIndex</span><span class="o">.</span><span class="n">delta</span>
            <span class="c1"># gamma matirices are in a[i:j]</span>
            <span class="n">hit</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ncomps</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">components</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">GammaMatrixHead</span><span class="p">):</span>
                    <span class="n">hit</span> <span class="o">=</span> <span class="mi">1</span>
                    <span class="k">break</span>

            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="n">hit</span><span class="p">,</span> <span class="n">ncomps</span><span class="p">):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">components</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">GammaMatrixHead</span><span class="p">):</span>
                    <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">j</span> <span class="o">=</span> <span class="n">ncomps</span>
            <span class="n">numG</span> <span class="o">=</span> <span class="n">j</span> <span class="o">-</span> <span class="n">i</span>
            <span class="k">if</span> <span class="n">numG</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">spinor_free</span> <span class="o">=</span> <span class="p">[</span><span class="n">_</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">t</span><span class="o">.</span><span class="n">_tids</span><span class="o">.</span><span class="n">free</span> <span class="k">if</span> <span class="n">_</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">tensortype</span> <span class="ow">is</span> <span class="n">DiracSpinorIndex</span><span class="p">]</span>
                <span class="n">tcoeff</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">coeff</span>
                <span class="k">if</span> <span class="n">spinor_free</span> <span class="o">==</span> <span class="p">[</span><span class="n">DiracSpinorIndex</span><span class="o">.</span><span class="n">auto_left</span><span class="p">,</span> <span class="o">-</span><span class="n">DiracSpinorIndex</span><span class="o">.</span><span class="n">auto_right</span><span class="p">]:</span>
                    <span class="n">t</span> <span class="o">=</span> <span class="n">t</span><span class="o">*</span><span class="n">DiracSpinorIndex</span><span class="o">.</span><span class="n">delta</span><span class="p">(</span><span class="o">-</span><span class="n">DiracSpinorIndex</span><span class="o">.</span><span class="n">auto_left</span><span class="p">,</span> <span class="n">DiracSpinorIndex</span><span class="o">.</span><span class="n">auto_right</span><span class="p">)</span>
                    <span class="n">t</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">contract_metric</span><span class="p">(</span><span class="n">sg</span><span class="p">)</span>
                    <span class="k">return</span> <span class="n">t</span><span class="o">/</span><span class="n">tcoeff</span> <span class="k">if</span> <span class="n">tcoeff</span> <span class="k">else</span> <span class="n">t</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">t</span><span class="o">/</span><span class="n">tcoeff</span> <span class="k">if</span> <span class="n">tcoeff</span> <span class="k">else</span> <span class="n">t</span>
            <span class="k">if</span> <span class="n">numG</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">TensMul</span><span class="o">.</span><span class="n">from_data</span><span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">Zero</span><span class="p">,</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[])</span>
            <span class="k">elif</span> <span class="n">numG</span> <span class="o">&gt;</span> <span class="mi">4</span><span class="p">:</span>
                <span class="n">t</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">substitute_indices</span><span class="p">((</span><span class="o">-</span><span class="n">DiracSpinorIndex</span><span class="o">.</span><span class="n">auto_right</span><span class="p">,</span> <span class="o">-</span><span class="n">DiracSpinorIndex</span><span class="o">.</span><span class="n">auto_index</span><span class="p">),</span> <span class="p">(</span><span class="n">DiracSpinorIndex</span><span class="o">.</span><span class="n">auto_left</span><span class="p">,</span> <span class="n">DiracSpinorIndex</span><span class="o">.</span><span class="n">auto_index</span><span class="p">))</span>
                <span class="n">a</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
                <span class="n">ind1</span><span class="p">,</span> <span class="n">lind1</span><span class="p">,</span> <span class="n">rind1</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">ind2</span><span class="p">,</span> <span class="n">lind2</span><span class="p">,</span> <span class="n">rind2</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">aa</span> <span class="o">=</span> <span class="n">a</span><span class="p">[:</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">:]</span>
                <span class="n">t1</span> <span class="o">=</span> <span class="n">tensor_mul</span><span class="p">(</span><span class="o">*</span><span class="n">aa</span><span class="p">)</span><span class="o">*</span><span class="n">g</span><span class="p">(</span><span class="n">ind1</span><span class="p">,</span> <span class="n">ind2</span><span class="p">)</span><span class="o">*</span><span class="n">sg</span><span class="p">(</span><span class="n">lind1</span><span class="p">,</span> <span class="n">rind1</span><span class="p">)</span><span class="o">*</span><span class="n">sg</span><span class="p">(</span><span class="n">lind2</span><span class="p">,</span> <span class="n">rind2</span><span class="p">)</span>
                <span class="n">t1</span> <span class="o">=</span> <span class="n">t1</span><span class="o">.</span><span class="n">contract_metric</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
                <span class="n">t1</span> <span class="o">=</span> <span class="n">t1</span><span class="o">.</span><span class="n">contract_metric</span><span class="p">(</span><span class="n">sg</span><span class="p">)</span>
                <span class="n">args</span> <span class="o">=</span> <span class="p">[</span><span class="n">t1</span><span class="p">]</span>
                <span class="n">sign</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="n">j</span><span class="p">):</span>
                    <span class="n">sign</span> <span class="o">=</span> <span class="o">-</span><span class="n">sign</span>
                    <span class="n">ind2</span><span class="p">,</span> <span class="n">lind2</span><span class="p">,</span> <span class="n">rind2</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">aa</span> <span class="o">=</span> <span class="n">a</span><span class="p">[:</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span><span class="n">k</span><span class="p">]</span> <span class="o">+</span> <span class="n">a</span><span class="p">[</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:]</span>
                    <span class="n">t2</span> <span class="o">=</span> <span class="n">sign</span><span class="o">*</span><span class="n">tensor_mul</span><span class="p">(</span><span class="o">*</span><span class="n">aa</span><span class="p">)</span><span class="o">*</span><span class="n">g</span><span class="p">(</span><span class="n">ind1</span><span class="p">,</span> <span class="n">ind2</span><span class="p">)</span><span class="o">*</span><span class="n">sg</span><span class="p">(</span><span class="n">lind1</span><span class="p">,</span> <span class="n">rind1</span><span class="p">)</span><span class="o">*</span><span class="n">sg</span><span class="p">(</span><span class="n">lind2</span><span class="p">,</span> <span class="n">rind2</span><span class="p">)</span>
                    <span class="n">t2</span> <span class="o">=</span> <span class="n">t2</span><span class="o">.</span><span class="n">contract_metric</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
                    <span class="n">t2</span> <span class="o">=</span> <span class="n">t2</span><span class="o">.</span><span class="n">contract_metric</span><span class="p">(</span><span class="n">sg</span><span class="p">)</span>

                    <span class="n">t2</span> <span class="o">=</span> <span class="n">GammaMatrixHead</span><span class="o">.</span><span class="n">simplify_gpgp</span><span class="p">(</span><span class="n">t2</span><span class="p">,</span> <span class="bp">False</span><span class="p">)</span>
                    <span class="n">args</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">t2</span><span class="p">)</span>
                <span class="n">t3</span> <span class="o">=</span> <span class="n">TensAdd</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

                <span class="c1">#aa = _tensorlist_contract_metric(aa, g(ind1, ind2))</span>
                <span class="c1">#t3 = t3.canon_bp()</span>
                <span class="n">t3</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_trace_single_line</span><span class="p">(</span><span class="n">t3</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">t3</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">a</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">components</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">t</span><span class="o">.</span><span class="n">components</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="n">DiracSpinorIndex</span><span class="o">.</span><span class="n">delta</span><span class="p">:</span>
                        <span class="k">return</span> <span class="mi">4</span>  <span class="c1"># FIXME only for D=4</span>
                <span class="n">t1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_gamma_trace1</span><span class="p">(</span><span class="o">*</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">j</span><span class="p">])</span>
                <span class="n">a2</span> <span class="o">=</span> <span class="n">a</span><span class="p">[:</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="p">:]</span>
                <span class="n">t2</span> <span class="o">=</span> <span class="n">tensor_mul</span><span class="p">(</span><span class="o">*</span><span class="n">a2</span><span class="p">)</span>
                <span class="n">t3</span> <span class="o">=</span> <span class="n">t1</span><span class="o">*</span><span class="n">t2</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">t3</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">t3</span>
                <span class="n">t3</span> <span class="o">=</span> <span class="n">t3</span><span class="o">.</span><span class="n">contract_metric</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">t3</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">TensAdd</span><span class="p">):</span>
            <span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">coeff</span><span class="o">*</span><span class="n">_trace_single_line1</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">t</span><span class="o">.</span><span class="n">args</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">TensAdd</span><span class="p">(</span><span class="o">*</span><span class="n">a</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="p">(</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">TensMul</span><span class="p">)):</span>
            <span class="n">r</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">coeff</span><span class="o">*</span><span class="n">_trace_single_line1</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">r</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">t</span>

    <span class="k">def</span> <span class="nf">_gamma_trace1</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">a</span><span class="p">):</span>
        <span class="n">gctr</span> <span class="o">=</span> <span class="mi">4</span>  <span class="c1"># FIXME specific for d=4</span>
        <span class="n">g</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">LorentzIndex</span><span class="o">.</span><span class="n">metric</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">a</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">gctr</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">n</span><span class="o">%</span><span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1">#return TensMul.from_data(S.Zero, [], [], [])</span>
            <span class="k">return</span> <span class="n">S</span><span class="o">.</span><span class="n">Zero</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">ind0</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">get_indices</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">ind1</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">get_indices</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">gctr</span><span class="o">*</span><span class="n">g</span><span class="p">(</span><span class="n">ind0</span><span class="p">,</span> <span class="n">ind1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
            <span class="n">ind0</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">get_indices</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">ind1</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">get_indices</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">ind2</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">get_indices</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">ind3</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">get_indices</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>

            <span class="k">return</span> <span class="n">gctr</span><span class="o">*</span><span class="p">(</span><span class="n">g</span><span class="p">(</span><span class="n">ind0</span><span class="p">,</span> <span class="n">ind1</span><span class="p">)</span><span class="o">*</span><span class="n">g</span><span class="p">(</span><span class="n">ind2</span><span class="p">,</span> <span class="n">ind3</span><span class="p">)</span> <span class="o">-</span> \
               <span class="n">g</span><span class="p">(</span><span class="n">ind0</span><span class="p">,</span> <span class="n">ind2</span><span class="p">)</span><span class="o">*</span><span class="n">g</span><span class="p">(</span><span class="n">ind1</span><span class="p">,</span> <span class="n">ind3</span><span class="p">)</span> <span class="o">+</span> <span class="n">g</span><span class="p">(</span><span class="n">ind0</span><span class="p">,</span> <span class="n">ind3</span><span class="p">)</span><span class="o">*</span><span class="n">g</span><span class="p">(</span><span class="n">ind1</span><span class="p">,</span> <span class="n">ind2</span><span class="p">))</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_kahane_simplify</span><span class="p">(</span><span class="n">coeff</span><span class="p">,</span> <span class="n">tids</span><span class="p">):</span>
        <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">        This function cancels contracted elements in a product of four</span>
<span class="sd">        dimensional gamma matrices, resulting in an expression equal to the given</span>
<span class="sd">        one, without the contracted gamma matrices.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ==========</span>

<span class="sd">        `coeff`     the coefficient of the tensor expression.</span>
<span class="sd">        `tids`      TIDS object representing the gamma matrix expression to simplify.</span>

<span class="sd">        Notes</span>
<span class="sd">        =====</span>

<span class="sd">        If spinor indices are given, the matrices must be given in</span>
<span class="sd">        the order given in the product.</span>

<span class="sd">        Algorithm</span>
<span class="sd">        =========</span>

<span class="sd">        The idea behind the algorithm is to use some well-known identities,</span>
<span class="sd">        i.e., for contractions enclosing an even number of `\gamma` matrices</span>

<span class="sd">        `\gamma^\mu \gamma_{a_1} \cdots \gamma_{a_{2N}} \gamma_\mu = 2 (\gamma_{a_{2N}} \gamma_{a_1} \cdots \gamma_{a_{2N-1}} + \gamma_{a_{2N-1}} \cdots \gamma_{a_1} \gamma_{a_{2N}} )`</span>

<span class="sd">        for an odd number of `\gamma` matrices</span>

<span class="sd">        `\gamma^\mu \gamma_{a_1} \cdots \gamma_{a_{2N+1}} \gamma_\mu = -2 \gamma_{a_{2N+1}} \gamma_{a_{2N}} \cdots \gamma_{a_{1}}`</span>

<span class="sd">        Instead of repeatedly applying these identities to cancel out all contracted indices,</span>
<span class="sd">        it is possible to recognize the links that would result from such an operation,</span>
<span class="sd">        the problem is thus reduced to a simple rearrangement of free gamma matrices.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        When using, always remember that the original expression coefficient</span>
<span class="sd">        has to be handled separately</span>

<span class="sd">        &gt;&gt;&gt; from sympy.physics.hep.gamma_matrices import GammaMatrix as G, DiracSpinorIndex as DS</span>
<span class="sd">        &gt;&gt;&gt; from sympy.tensor.tensor import tensor_indices, tensorhead, TensMul, TensAdd</span>
<span class="sd">        &gt;&gt;&gt; i0, i1, i2 = tensor_indices(&#39;i0:3&#39;, G.LorentzIndex)</span>
<span class="sd">        &gt;&gt;&gt; s0,s1,s2,s3,s4,s5 = tensor_indices(&#39;s0:6&#39;, DS)</span>
<span class="sd">        &gt;&gt;&gt; ta = G(i0)*G(-i0)</span>
<span class="sd">        &gt;&gt;&gt; G._kahane_simplify(ta.coeff, ta._tids) - 4*DS.delta(DS.auto_left, -DS.auto_right)</span>
<span class="sd">        0</span>
<span class="sd">        &gt;&gt;&gt; tb = G(i0)*G(i1)*G(-i0)</span>
<span class="sd">        &gt;&gt;&gt; G._kahane_simplify(tb.coeff, tb._tids)</span>
<span class="sd">        -2*gamma(i1, auto_left, -auto_right)</span>
<span class="sd">        &gt;&gt;&gt; t = G(i0, s0, -s1)*G(-i0,s1,-s2)</span>
<span class="sd">        &gt;&gt;&gt; G._kahane_simplify(t.coeff, t._tids) - 4*DS.delta(s0, -s2)</span>
<span class="sd">        0</span>
<span class="sd">        &gt;&gt;&gt; t = G(i0, s0, -s1)*G(-i0,s1,-s0)</span>
<span class="sd">        &gt;&gt;&gt; G._kahane_simplify(t.coeff, t._tids)</span>
<span class="sd">        16</span>

<span class="sd">        If there are no contractions, the same expression is returned</span>

<span class="sd">        &gt;&gt;&gt; tc = 3*G(i0)*G(i1)</span>
<span class="sd">        &gt;&gt;&gt; G._kahane_simplify(tc.coeff, tc._tids)</span>
<span class="sd">        3*gamma(i0, auto_left, S_0)*gamma(i1, -S_0, -auto_right)</span>

<span class="sd">        References</span>
<span class="sd">        ==========</span>

<span class="sd">        [1] Algorithm for Reducing Contracted Products of gamma Matrices, Joseph Kahane, Journal of Mathematical Physics, Vol. 9, No. 10, October 1968.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">tids</span><span class="o">.</span><span class="n">components</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">tids</span><span class="o">.</span><span class="n">components</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">GammaMatrixHead</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;use only gamma matrices&#39;</span><span class="p">)</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">tids</span><span class="o">.</span><span class="n">components</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">p0</span><span class="p">,</span> <span class="n">p1</span><span class="p">,</span> <span class="n">c0</span><span class="p">,</span> <span class="n">c1</span> <span class="ow">in</span> <span class="n">tids</span><span class="o">.</span><span class="n">dum</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">p0</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">dc</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">c0</span> <span class="o">-</span> <span class="n">c1</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">dc</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;wrong gamma matrix ordering&#39;</span><span class="p">)</span>
        <span class="n">free</span> <span class="o">=</span> <span class="p">[</span><span class="n">_</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">tids</span><span class="o">.</span><span class="n">free</span> <span class="k">if</span> <span class="n">_</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">spinor_free</span> <span class="o">=</span> <span class="p">[</span><span class="n">_</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">tids</span><span class="o">.</span><span class="n">free</span> <span class="k">if</span> <span class="n">_</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">spinor_free</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">spinor_free</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
            <span class="k">assert</span> <span class="n">spinor_free</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">spinor_free</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span>
            <span class="k">assert</span> <span class="n">spinor_free</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span>
        <span class="k">elif</span> <span class="n">spinor_free</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;spinor indices do not match&#39;</span><span class="p">)</span>

        <span class="n">dum</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">([</span><span class="n">_</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">tids</span><span class="o">.</span><span class="n">dum</span> <span class="k">if</span> <span class="n">_</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">_</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">])</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dum</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># or GammaMatrixHead:</span>
            <span class="c1"># no contractions in `expression`, just return it.</span>
            <span class="k">return</span> <span class="n">TensMul</span><span class="o">.</span><span class="n">from_TIDS</span><span class="p">(</span><span class="n">coeff</span><span class="p">,</span> <span class="n">tids</span><span class="p">)</span>

        <span class="c1"># find the `first_dum_pos`, i.e. the position of the first contracted</span>
        <span class="c1"># gamma matrix, Kahane&#39;s algorithm as described in his paper requires the</span>
        <span class="c1"># gamma matrix expression to start with a contracted gamma matrix, this is</span>
        <span class="c1"># a workaround which ignores possible initial free indices, and re-adds</span>
        <span class="c1"># them later.</span>
        <span class="n">dum_zip</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">dum</span><span class="p">))[</span><span class="mi">2</span><span class="p">:]</span>
        <span class="n">first_dum_pos</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">dum_zip</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="nb">min</span><span class="p">(</span><span class="n">dum_zip</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>

        <span class="n">total_number</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">free</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">dum</span><span class="p">)</span><span class="o">*</span><span class="mi">2</span>
        <span class="n">number_of_contractions</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">dum</span><span class="p">)</span>

        <span class="n">free_pos</span> <span class="o">=</span> <span class="p">[</span><span class="bp">None</span><span class="p">]</span><span class="o">*</span><span class="n">total_number</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">free</span><span class="p">:</span>
            <span class="n">free_pos</span><span class="p">[</span><span class="n">i</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span> <span class="o">=</span> <span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># `index_is_free` is a list of booleans, to identify index position</span>
        <span class="c1"># and whether that index is free or dummy.</span>
        <span class="n">index_is_free</span> <span class="o">=</span> <span class="p">[</span><span class="bp">False</span><span class="p">]</span><span class="o">*</span><span class="n">total_number</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">indx</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">free</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">indx</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;indx[1] should be equal to 0&quot;</span><span class="p">)</span>
            <span class="n">index_is_free</span><span class="p">[</span><span class="n">indx</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span> <span class="o">=</span> <span class="bp">True</span>

        <span class="c1"># `links` is a dictionary containing the graph described in Kahane&#39;s paper,</span>
        <span class="c1"># to every key correspond one or two values, representing the linked indices.</span>
        <span class="c1"># All values in `links` are integers, negative numbers are used in the case</span>
        <span class="c1"># where it is necessary to insert gamma matrices between free indices, in</span>
        <span class="c1"># order to make Kahane&#39;s algorithm work (see paper).</span>
        <span class="n">links</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">first_dum_pos</span><span class="p">,</span> <span class="n">total_number</span><span class="p">):</span>
            <span class="n">links</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># `cum_sign` is a step variable to mark the sign of every index, see paper.</span>
        <span class="n">cum_sign</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="c1"># `cum_sign_list` keeps storage for all `cum_sign` (every index).</span>
        <span class="n">cum_sign_list</span> <span class="o">=</span> <span class="p">[</span><span class="bp">None</span><span class="p">]</span><span class="o">*</span><span class="n">total_number</span>
        <span class="n">block_free_count</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># multiply `resulting_coeff` by the coefficient parameter, the rest</span>
        <span class="c1"># of the algorithm ignores a scalar coefficient.</span>
        <span class="n">resulting_coeff</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span> <span class="o">*</span> <span class="n">coeff</span>

        <span class="c1"># initialize a lisf of lists of indices. The outer list will contain all</span>
        <span class="c1"># additive tensor expressions, while the inner list will contain the</span>
        <span class="c1"># free indices (rearranged according to the algorithm).</span>
        <span class="n">resulting_indices</span> <span class="o">=</span> <span class="p">[[]]</span>

        <span class="c1"># start to count the `connected_components`, which together with the number</span>
        <span class="c1"># of contractions, determines a -1 or +1 factor to be multiplied.</span>
        <span class="n">connected_components</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="c1"># First loop: here we fill `cum_sign_list`, and draw the links</span>
        <span class="c1"># among consecutive indices (they are stored in `links`). Links among</span>
        <span class="c1"># non-consecutive indices will be drawn later.</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">is_free</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">index_is_free</span><span class="p">):</span>
            <span class="c1"># if `expression` starts with free indices, they are ignored here;</span>
            <span class="c1"># they are later added as they are to the beginning of all</span>
            <span class="c1"># `resulting_indices` list of lists of indices.</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">first_dum_pos</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="k">if</span> <span class="n">is_free</span><span class="p">:</span>
                <span class="n">block_free_count</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="c1"># if previous index was free as well, draw an arch in `links`.</span>
                <span class="k">if</span> <span class="n">block_free_count</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">links</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                    <span class="n">links</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Change the sign of the index (`cum_sign`) if the number of free</span>
                <span class="c1"># indices preceding it is even.</span>
                <span class="n">cum_sign</span> <span class="o">*=</span> <span class="mi">1</span> <span class="k">if</span> <span class="p">(</span><span class="n">block_free_count</span> <span class="o">%</span> <span class="mi">2</span><span class="p">)</span> <span class="k">else</span> <span class="o">-</span><span class="mi">1</span>
                <span class="k">if</span> <span class="n">block_free_count</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">first_dum_pos</span><span class="p">:</span>
                    <span class="c1"># check if there are two consecutive dummy indices:</span>
                    <span class="c1"># in this case create virtual indices with negative position,</span>
                    <span class="c1"># these &quot;virtual&quot; indices represent the insertion of two</span>
                    <span class="c1"># gamma^0 matrices to separate consecutive dummy indices, as</span>
                    <span class="c1"># Kahane&#39;s algorithm requires dummy indices to be separated by</span>
                    <span class="c1"># free indices. The product of two gamma^0 matrices is unity,</span>
                    <span class="c1"># so the new expression being examined is the same as the</span>
                    <span class="c1"># original one.</span>
                    <span class="k">if</span> <span class="n">cum_sign</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                        <span class="n">links</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="o">-</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="o">-</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
                        <span class="n">links</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="o">-</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="o">-</span><span class="n">i</span><span class="p">]</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="n">cum_sign</span><span class="p">)</span> <span class="ow">in</span> <span class="n">links</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">first_dum_pos</span><span class="p">:</span>
                        <span class="n">links</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="n">cum_sign</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">block_free_count</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">i</span> <span class="o">-</span> <span class="n">cum_sign</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">index_is_free</span><span class="p">):</span>
                            <span class="k">if</span> <span class="n">index_is_free</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">cum_sign</span><span class="p">]:</span>
                                <span class="n">links</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">cum_sign</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                <span class="n">block_free_count</span> <span class="o">=</span> <span class="mi">0</span>

            <span class="n">cum_sign_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">cum_sign</span>

        <span class="c1"># The previous loop has only created links between consecutive free indices,</span>
        <span class="c1"># it is necessary to properly create links among dummy (contracted) indices,</span>
        <span class="c1"># according to the rules described in Kahane&#39;s paper. There is only one exception</span>
        <span class="c1"># to Kahane&#39;s rules: the negative indices, which handle the case of some</span>
        <span class="c1"># consecutive free indices (Kahane&#39;s paper just describes dummy indices</span>
        <span class="c1"># separated by free indices, hinting that free indices can be added without</span>
        <span class="c1"># altering the expression result).</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">dum</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;i[0] should be 0&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">i</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;i[1] should be 0&quot;</span><span class="p">)</span>
            <span class="c1"># get the positions of the two contracted indices:</span>
            <span class="n">pos1</span> <span class="o">=</span> <span class="n">i</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">pos2</span> <span class="o">=</span> <span class="n">i</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>

            <span class="c1"># create Kahane&#39;s upper links, i.e. the upper arcs between dummy</span>
            <span class="c1"># (i.e. contracted) indices:</span>
            <span class="n">links</span><span class="p">[</span><span class="n">pos1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pos2</span><span class="p">)</span>
            <span class="n">links</span><span class="p">[</span><span class="n">pos2</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pos1</span><span class="p">)</span>

            <span class="c1"># create Kahane&#39;s lower links, this corresponds to the arcs below</span>
            <span class="c1"># the line described in the paper:</span>

            <span class="c1"># first we move `pos1` and `pos2` according to the sign of the indices:</span>
            <span class="n">linkpos1</span> <span class="o">=</span> <span class="n">pos1</span> <span class="o">+</span> <span class="n">cum_sign_list</span><span class="p">[</span><span class="n">pos1</span><span class="p">]</span>
            <span class="n">linkpos2</span> <span class="o">=</span> <span class="n">pos2</span> <span class="o">+</span> <span class="n">cum_sign_list</span><span class="p">[</span><span class="n">pos2</span><span class="p">]</span>

            <span class="c1"># otherwise, perform some checks before creating the lower arcs:</span>

            <span class="c1"># make sure we are not exceeding the total number of indices:</span>
            <span class="k">if</span> <span class="n">linkpos1</span> <span class="o">&gt;=</span> <span class="n">total_number</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="n">linkpos2</span> <span class="o">&gt;=</span> <span class="n">total_number</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="c1"># make sure we are not below the first dummy index in `expression`:</span>
            <span class="k">if</span> <span class="n">linkpos1</span> <span class="o">&lt;</span> <span class="n">first_dum_pos</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="n">linkpos2</span> <span class="o">&lt;</span> <span class="n">first_dum_pos</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="c1"># check if the previous loop created &quot;virtual&quot; indices between dummy</span>
            <span class="c1"># indices, in such a case relink `linkpos1` and `linkpos2`:</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="o">-</span><span class="n">linkpos1</span><span class="p">)</span> <span class="ow">in</span> <span class="n">links</span><span class="p">:</span>
                <span class="n">linkpos1</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">-</span><span class="n">linkpos1</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="o">-</span><span class="n">linkpos2</span><span class="p">)</span> <span class="ow">in</span> <span class="n">links</span><span class="p">:</span>
                <span class="n">linkpos2</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">-</span><span class="n">linkpos2</span>

            <span class="c1"># move only if not next to free index:</span>
            <span class="k">if</span> <span class="n">linkpos1</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">index_is_free</span><span class="p">[</span><span class="n">linkpos1</span><span class="p">]:</span>
                <span class="n">linkpos1</span> <span class="o">=</span> <span class="n">pos1</span>

            <span class="k">if</span> <span class="n">linkpos2</span> <span class="o">&gt;=</span><span class="mi">0</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">index_is_free</span><span class="p">[</span><span class="n">linkpos2</span><span class="p">]:</span>
                <span class="n">linkpos2</span> <span class="o">=</span> <span class="n">pos2</span>

            <span class="c1"># create the lower arcs:</span>
            <span class="k">if</span> <span class="n">linkpos2</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">links</span><span class="p">[</span><span class="n">linkpos1</span><span class="p">]:</span>
                <span class="n">links</span><span class="p">[</span><span class="n">linkpos1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">linkpos2</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">linkpos1</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">links</span><span class="p">[</span><span class="n">linkpos2</span><span class="p">]:</span>
                <span class="n">links</span><span class="p">[</span><span class="n">linkpos2</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">linkpos1</span><span class="p">)</span>

        <span class="c1"># This loop starts from the `first_dum_pos` index (first dummy index)</span>
        <span class="c1"># walks through the graph deleting the visited indices from `links`,</span>
        <span class="c1"># it adds a gamma matrix for every free index in encounters, while it</span>
        <span class="c1"># completely ignores dummy indices and virtual indices.</span>
        <span class="n">pointer</span> <span class="o">=</span> <span class="n">first_dum_pos</span>
        <span class="n">previous_pointer</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">pointer</span> <span class="ow">in</span> <span class="n">links</span><span class="p">:</span>
                <span class="n">next_ones</span> <span class="o">=</span> <span class="n">links</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">pointer</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">break</span>

            <span class="k">if</span> <span class="n">previous_pointer</span> <span class="ow">in</span> <span class="n">next_ones</span><span class="p">:</span>
                <span class="n">next_ones</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">previous_pointer</span><span class="p">)</span>

            <span class="n">previous_pointer</span> <span class="o">=</span> <span class="n">pointer</span>

            <span class="k">if</span> <span class="n">next_ones</span><span class="p">:</span>
                <span class="n">pointer</span> <span class="o">=</span> <span class="n">next_ones</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">break</span>

            <span class="k">if</span> <span class="n">pointer</span> <span class="o">==</span> <span class="n">previous_pointer</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="k">if</span> <span class="n">pointer</span> <span class="o">&gt;=</span><span class="mi">0</span> <span class="ow">and</span> <span class="n">free_pos</span><span class="p">[</span><span class="n">pointer</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">ri</span> <span class="ow">in</span> <span class="n">resulting_indices</span><span class="p">:</span>
                    <span class="n">ri</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">free_pos</span><span class="p">[</span><span class="n">pointer</span><span class="p">])</span>

        <span class="c1"># The following loop removes the remaining connected components in `links`.</span>
        <span class="c1"># If there are free indices inside a connected component, it gives a</span>
        <span class="c1"># contribution to the resulting expression given by the factor</span>
        <span class="c1"># `gamma_a gamma_b ... gamma_z + gamma_z ... gamma_b gamma_a`, in Kahanes&#39;s</span>
        <span class="c1"># paper represented as  {gamma_a, gamma_b, ... , gamma_z},</span>
        <span class="c1"># virtual indices are ignored. The variable `connected_components` is</span>
        <span class="c1"># increased by one for every connected component this loop encounters.</span>

        <span class="c1"># If the connected component has virtual and dummy indices only</span>
        <span class="c1"># (no free indices), it contributes to `resulting_indices` by a factor of two.</span>
        <span class="c1"># The multiplication by two is a result of the</span>
        <span class="c1"># factor {gamma^0, gamma^0} = 2 I, as it appears in Kahane&#39;s paper.</span>
        <span class="c1"># Note: curly brackets are meant as in the paper, as a generalized</span>
        <span class="c1"># multi-element anticommutator!</span>

        <span class="k">while</span> <span class="n">links</span><span class="p">:</span>
            <span class="n">connected_components</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">pointer</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">links</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
            <span class="n">previous_pointer</span> <span class="o">=</span> <span class="n">pointer</span>
            <span class="c1"># the inner loop erases the visited indices from `links`, and it adds</span>
            <span class="c1"># all free indices to `prepend_indices` list, virtual indices are</span>
            <span class="c1"># ignored.</span>
            <span class="n">prepend_indices</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">pointer</span> <span class="ow">in</span> <span class="n">links</span><span class="p">:</span>
                    <span class="n">next_ones</span> <span class="o">=</span> <span class="n">links</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">pointer</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">break</span>

                <span class="k">if</span> <span class="n">previous_pointer</span> <span class="ow">in</span> <span class="n">next_ones</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">next_ones</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">next_ones</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">previous_pointer</span><span class="p">)</span>

                <span class="n">previous_pointer</span> <span class="o">=</span> <span class="n">pointer</span>

                <span class="k">if</span> <span class="n">next_ones</span><span class="p">:</span>
                    <span class="n">pointer</span> <span class="o">=</span> <span class="n">next_ones</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

                <span class="k">if</span> <span class="n">pointer</span> <span class="o">&gt;=</span> <span class="n">first_dum_pos</span> <span class="ow">and</span> <span class="n">free_pos</span><span class="p">[</span><span class="n">pointer</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="n">prepend_indices</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">free_pos</span><span class="p">[</span><span class="n">pointer</span><span class="p">])</span>
            <span class="c1"># if `prepend_indices` is void, it means there are no free indices</span>
            <span class="c1"># in the loop (and it can be shown that there must be a virtual index),</span>
            <span class="c1"># loops of virtual indices only contribute by a factor of two:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">prepend_indices</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">resulting_coeff</span> <span class="o">*=</span> <span class="mi">2</span>
            <span class="c1"># otherwise, add the free indices in `prepend_indices` to</span>
            <span class="c1"># the `resulting_indices`:</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">expr1</span> <span class="o">=</span> <span class="n">prepend_indices</span>
                <span class="n">expr2</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="n">prepend_indices</span><span class="p">))</span>
                <span class="n">resulting_indices</span> <span class="o">=</span> <span class="p">[</span><span class="n">expri</span> <span class="o">+</span> <span class="n">ri</span> <span class="k">for</span> <span class="n">ri</span> <span class="ow">in</span> <span class="n">resulting_indices</span> <span class="k">for</span> <span class="n">expri</span> <span class="ow">in</span> <span class="p">(</span><span class="n">expr1</span><span class="p">,</span> <span class="n">expr2</span><span class="p">)]</span>

        <span class="c1"># sign correction, as described in Kahane&#39;s paper:</span>
        <span class="n">resulting_coeff</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span> <span class="k">if</span> <span class="p">(</span><span class="n">number_of_contractions</span> <span class="o">-</span> <span class="n">connected_components</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span> <span class="k">else</span> <span class="mi">1</span>
        <span class="c1"># power of two factor, as described in Kahane&#39;s paper:</span>
        <span class="n">resulting_coeff</span> <span class="o">*=</span> <span class="mi">2</span><span class="o">**</span><span class="p">(</span><span class="n">number_of_contractions</span><span class="p">)</span>

        <span class="c1"># If `first_dum_pos` is not zero, it means that there are trailing free gamma</span>
        <span class="c1"># matrices in front of `expression`, so multiply by them:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">first_dum_pos</span><span class="p">):</span>
            <span class="p">[</span><span class="n">ri</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">free_pos</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">ri</span> <span class="ow">in</span> <span class="n">resulting_indices</span><span class="p">]</span>

        <span class="n">resulting_expr</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">Zero</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">resulting_indices</span><span class="p">:</span>
            <span class="n">temp_expr</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">i</span><span class="p">:</span>
                <span class="n">temp_expr</span> <span class="o">*=</span> <span class="n">GammaMatrix</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
            <span class="n">resulting_expr</span> <span class="o">+=</span> <span class="n">temp_expr</span>

        <span class="n">t</span> <span class="o">=</span> <span class="n">resulting_coeff</span> <span class="o">*</span> <span class="n">resulting_expr</span>
        <span class="n">t1</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">TensAdd</span><span class="p">):</span>
            <span class="n">t1</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">TensMul</span><span class="p">):</span>
            <span class="n">t1</span> <span class="o">=</span> <span class="n">t</span>
        <span class="k">if</span> <span class="n">t1</span><span class="p">:</span>
            <span class="n">spinor_free1</span> <span class="o">=</span> <span class="p">[</span><span class="n">_</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">t1</span><span class="o">.</span><span class="n">_tids</span><span class="o">.</span><span class="n">free</span> <span class="k">if</span> <span class="n">_</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">spinor_free1</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">spinor_free</span><span class="p">:</span>
                    <span class="n">t</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">substitute_indices</span><span class="p">((</span><span class="n">DiracSpinorIndex</span><span class="o">.</span><span class="n">auto_left</span><span class="p">,</span> <span class="n">spinor_free</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]),</span> <span class="p">(</span><span class="o">-</span><span class="n">DiracSpinorIndex</span><span class="o">.</span><span class="n">auto_right</span><span class="p">,</span> <span class="n">spinor_free</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># FIXME trace</span>
                    <span class="n">t</span> <span class="o">=</span> <span class="n">t</span><span class="o">*</span><span class="n">DiracSpinorIndex</span><span class="o">.</span><span class="n">delta</span><span class="p">(</span><span class="n">DiracSpinorIndex</span><span class="o">.</span><span class="n">auto_right</span><span class="p">,</span> <span class="o">-</span><span class="n">DiracSpinorIndex</span><span class="o">.</span><span class="n">auto_left</span><span class="p">)</span>
                    <span class="n">t</span> <span class="o">=</span> <span class="n">GammaMatrix</span><span class="o">.</span><span class="n">simplify_lines</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">spinor_free</span><span class="p">:</span>
                    <span class="n">t</span> <span class="o">=</span> <span class="n">t</span><span class="o">*</span><span class="n">DiracSpinorIndex</span><span class="o">.</span><span class="n">delta</span><span class="p">(</span><span class="n">spinor_free</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">spinor_free</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">t</span> <span class="o">=</span> <span class="n">t</span><span class="o">*</span><span class="mi">4</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">spinor_free</span><span class="p">:</span>
                <span class="n">t</span> <span class="o">=</span> <span class="n">t</span><span class="o">*</span><span class="n">DiracSpinorIndex</span><span class="o">.</span><span class="n">delta</span><span class="p">(</span><span class="n">spinor_free</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">spinor_free</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">t</span> <span class="o">=</span> <span class="n">t</span><span class="o">*</span><span class="mi">4</span>
        <span class="k">return</span> <span class="n">t</span></div>

<span class="n">GammaMatrix</span> <span class="o">=</span> <span class="n">GammaMatrixHead</span><span class="p">()</span>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../../../index.html">
              <img class="logo" src="../../../../_static/sympylogo.png" alt="Logo"/>
            </a></p><div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../../index.html">Documentation overview</a><ul>
  <li><a href="../../../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../../../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2015 SymPy Development Team.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.4.1</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.7</a>
      
    </div>

    

    
  </body>
</html>