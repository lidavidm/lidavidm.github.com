<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>sympy.calculus.finite_diff &mdash; SymPy 1.0 documentation</title>
    
    <link rel="stylesheet" href="../../../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="http://95.sympy-live-tests.appspot.com/static/live-core.css" type="text/css" />
    <link rel="stylesheet" href="http://95.sympy-live-tests.appspot.com/static/live-autocomplete.css" type="text/css" />
    <link rel="stylesheet" href="http://95.sympy-live-tests.appspot.com/static/live-sphinx.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="http://95.sympy-live-tests.appspot.com/static/utilities.js"></script>
    <script type="text/javascript" src="http://95.sympy-live-tests.appspot.com/static/external/classy.js"></script>
    <script type="text/javascript" src="http://95.sympy-live-tests.appspot.com/static/live-core.js"></script>
    <script type="text/javascript" src="http://95.sympy-live-tests.appspot.com/static/live-autocomplete.js"></script>
    <script type="text/javascript" src="http://95.sympy-live-tests.appspot.com/static/live-sphinx.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML-full"></script>
    <link rel="shortcut icon" href="../../../_static/sympy-notailtext-favicon.ico"/>
    <link rel="top" title="SymPy 1.0 documentation" href="../../../index.html" />
    <link rel="up" title="Module code" href="../../index.html" />
   
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head>
  <body role="document">  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for sympy.calculus.finite_diff</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Finite difference weights</span>
<span class="sd">=========================</span>

<span class="sd">This module implements an algorithm for efficient generation of finite</span>
<span class="sd">difference weights for ordinary differentials of functions for</span>
<span class="sd">derivatives from 0 (interpolation) up to arbitrary order.</span>

<span class="sd">The core algorithm is provided in the finite difference weight generating</span>
<span class="sd">function (finite_diff_weights), and two convenience functions are provided</span>
<span class="sd">for:</span>

<span class="sd">- estimating a derivative (or interpolate) directly from a series of points</span>
<span class="sd">    is also provided (``apply_finite_diff``).</span>
<span class="sd">- making a finite difference approximation of a Derivative instance</span>
<span class="sd">    (``as_finite_diff``).</span>

<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">S</span>
<span class="kn">from</span> <span class="nn">sympy.core.compatibility</span> <span class="kn">import</span> <span class="n">iterable</span><span class="p">,</span> <span class="nb">range</span>


<div class="viewcode-block" id="finite_diff_weights"><a class="viewcode-back" href="../../../modules/calculus/index.html#sympy.calculus.finite_diff.finite_diff_weights">[docs]</a><span class="k">def</span> <span class="nf">finite_diff_weights</span><span class="p">(</span><span class="n">order</span><span class="p">,</span> <span class="n">x_list</span><span class="p">,</span> <span class="n">x0</span><span class="o">=</span><span class="n">S</span><span class="p">(</span><span class="mi">0</span><span class="p">)):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculates the finite difference weights for an arbitrarily</span>
<span class="sd">    spaced one-dimensional grid (x_list) for derivatives at &#39;x0&#39;</span>
<span class="sd">    of order 0, 1, ..., up to &#39;order&#39; using a recursive formula.</span>
<span class="sd">    Order of accuracy is at least len(x_list) - order, if x_list</span>
<span class="sd">    is defined accurately.</span>


<span class="sd">    Parameters</span>
<span class="sd">    ==========</span>

<span class="sd">    order: int</span>
<span class="sd">        Up to what derivative order weights should be calculated.</span>
<span class="sd">        0 corresponds to interpolation.</span>
<span class="sd">    x_list: sequence</span>
<span class="sd">        Sequence of (unique) values for the independent variable.</span>
<span class="sd">        It is usefull (but not necessary) to order x_list from</span>
<span class="sd">        nearest to farest from x0; see examples below.</span>
<span class="sd">    x0: Number or Symbol</span>
<span class="sd">        Root or value of the independent variable for which the finite</span>
<span class="sd">        difference weights should be generated. Defaults to S(0).</span>

<span class="sd">    Returns</span>
<span class="sd">    =======</span>

<span class="sd">    list</span>
<span class="sd">        A list of sublists, each corresponding to coefficients for</span>
<span class="sd">        increasing derivative order, and each containing lists of</span>
<span class="sd">        coefficients for increasing subsets of x_list.</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy import S</span>
<span class="sd">    &gt;&gt;&gt; from sympy.calculus import finite_diff_weights</span>
<span class="sd">    &gt;&gt;&gt; res = finite_diff_weights(1, [-S(1)/2, S(1)/2, S(3)/2, S(5)/2], 0)</span>
<span class="sd">    &gt;&gt;&gt; res</span>
<span class="sd">    [[[1, 0, 0, 0],</span>
<span class="sd">      [1/2, 1/2, 0, 0],</span>
<span class="sd">      [3/8, 3/4, -1/8, 0],</span>
<span class="sd">      [5/16, 15/16, -5/16, 1/16]],</span>
<span class="sd">     [[0, 0, 0, 0],</span>
<span class="sd">      [-1, 1, 0, 0],</span>
<span class="sd">      [-1, 1, 0, 0],</span>
<span class="sd">      [-23/24, 7/8, 1/8, -1/24]]]</span>
<span class="sd">    &gt;&gt;&gt; res[0][-1]  # FD weights for 0th derivative, using full x_list</span>
<span class="sd">    [5/16, 15/16, -5/16, 1/16]</span>
<span class="sd">    &gt;&gt;&gt; res[1][-1]  # FD weights for 1st derivative</span>
<span class="sd">    [-23/24, 7/8, 1/8, -1/24]</span>
<span class="sd">    &gt;&gt;&gt; res[1][-2]  # FD weights for 1st derivative, using x_list[:-1]</span>
<span class="sd">    [-1, 1, 0, 0]</span>
<span class="sd">    &gt;&gt;&gt; res[1][-1][0]  # FD weight for 1st deriv. for x_list[0]</span>
<span class="sd">    -23/24</span>
<span class="sd">    &gt;&gt;&gt; res[1][-1][1]  # FD weight for 1st deriv. for x_list[1], etc.</span>
<span class="sd">    7/8</span>

<span class="sd">    Each sublist contains the most accurate formula at the end.</span>
<span class="sd">    Note, that in the above example res[1][1] is the same as res[1][2].</span>
<span class="sd">    Since res[1][2] has an order of accuracy of</span>
<span class="sd">    len(x_list[:3]) - order = 3 - 1 = 2, the same is true for res[1][1]!</span>

<span class="sd">    &gt;&gt;&gt; from sympy import S</span>
<span class="sd">    &gt;&gt;&gt; from sympy.calculus import finite_diff_weights</span>
<span class="sd">    &gt;&gt;&gt; res = finite_diff_weights(1, [S(0), S(1), -S(1), S(2), -S(2)], 0)[1]</span>
<span class="sd">    &gt;&gt;&gt; res</span>
<span class="sd">    [[0, 0, 0, 0, 0],</span>
<span class="sd">     [-1, 1, 0, 0, 0],</span>
<span class="sd">     [0, 1/2, -1/2, 0, 0],</span>
<span class="sd">     [-1/2, 1, -1/3, -1/6, 0],</span>
<span class="sd">     [0, 2/3, -2/3, -1/12, 1/12]]</span>
<span class="sd">    &gt;&gt;&gt; res[0]  # no approximation possible, using x_list[0] only</span>
<span class="sd">    [0, 0, 0, 0, 0]</span>
<span class="sd">    &gt;&gt;&gt; res[1]  # classic forward step approximation</span>
<span class="sd">    [-1, 1, 0, 0, 0]</span>
<span class="sd">    &gt;&gt;&gt; res[2]  # classic centered approximation</span>
<span class="sd">    [0, 1/2, -1/2, 0, 0]</span>
<span class="sd">    &gt;&gt;&gt; res[3:]  # higher order approximations</span>
<span class="sd">    [[-1/2, 1, -1/3, -1/6, 0], [0, 2/3, -2/3, -1/12, 1/12]]</span>

<span class="sd">    Let us compare this to a differently defined x_list. Pay attention to</span>
<span class="sd">    foo[i][k] corresponding to the gridpoint defined by x_list[k].</span>

<span class="sd">    &gt;&gt;&gt; from sympy import S</span>
<span class="sd">    &gt;&gt;&gt; from sympy.calculus import finite_diff_weights</span>
<span class="sd">    &gt;&gt;&gt; foo = finite_diff_weights(1, [-S(2), -S(1), S(0), S(1), S(2)], 0)[1]</span>
<span class="sd">    &gt;&gt;&gt; foo</span>
<span class="sd">    [[0, 0, 0, 0, 0],</span>
<span class="sd">     [-1, 1, 0, 0, 0],</span>
<span class="sd">     [1/2, -2, 3/2, 0, 0],</span>
<span class="sd">     [1/6, -1, 1/2, 1/3, 0],</span>
<span class="sd">     [1/12, -2/3, 0, 2/3, -1/12]]</span>
<span class="sd">    &gt;&gt;&gt; foo[1]  # not the same and of lower accuracy as res[1]!</span>
<span class="sd">    [-1, 1, 0, 0, 0]</span>
<span class="sd">    &gt;&gt;&gt; foo[2]  # classic double backward step approximation</span>
<span class="sd">    [1/2, -2, 3/2, 0, 0]</span>
<span class="sd">    &gt;&gt;&gt; foo[4]  # the same as res[4]</span>
<span class="sd">    [1/12, -2/3, 0, 2/3, -1/12]</span>

<span class="sd">    Note that, unless you plan on using approximations based on subsets of</span>
<span class="sd">    x_list, the order of gridpoints does not matter.</span>


<span class="sd">    The capability to generate weights at arbitrary points can be</span>
<span class="sd">    used e.g. to minimize Runge&#39;s phenomenon by using Chebyshev nodes:</span>

<span class="sd">    &gt;&gt;&gt; from sympy import cos, symbols, pi, simplify</span>
<span class="sd">    &gt;&gt;&gt; from sympy.calculus import finite_diff_weights</span>
<span class="sd">    &gt;&gt;&gt; N, (h, x) = 4, symbols(&#39;h x&#39;)</span>
<span class="sd">    &gt;&gt;&gt; x_list = [x+h*cos(i*pi/(N)) for i in range(N,-1,-1)] # chebyshev nodes</span>
<span class="sd">    &gt;&gt;&gt; print(x_list)</span>
<span class="sd">    [-h + x, -sqrt(2)*h/2 + x, x, sqrt(2)*h/2 + x, h + x]</span>
<span class="sd">    &gt;&gt;&gt; mycoeffs = finite_diff_weights(1, x_list, 0)[1][4]</span>
<span class="sd">    &gt;&gt;&gt; [simplify(c) for c in  mycoeffs] #doctest: +NORMALIZE_WHITESPACE</span>
<span class="sd">    [(h**3/2 + h**2*x - 3*h*x**2 - 4*x**3)/h**4,</span>
<span class="sd">    (-sqrt(2)*h**3 - 4*h**2*x + 3*sqrt(2)*h*x**2 + 8*x**3)/h**4,</span>
<span class="sd">    6*x/h**2 - 8*x**3/h**4,</span>
<span class="sd">    (sqrt(2)*h**3 - 4*h**2*x - 3*sqrt(2)*h*x**2 + 8*x**3)/h**4,</span>
<span class="sd">    (-h**3/2 + h**2*x + 3*h*x**2 - 4*x**3)/h**4]</span>

<span class="sd">    Notes</span>
<span class="sd">    =====</span>

<span class="sd">    If weights for a finite difference approximation of 3rd order</span>
<span class="sd">    derivative is wanted, weights for 0th, 1st and 2nd order are</span>
<span class="sd">    calculated &quot;for free&quot;, so are formulae using subsets of x_list.</span>
<span class="sd">    This is something one can take advantage of to save computational cost.</span>
<span class="sd">    Be aware that one should define x_list from nearest to farest from</span>
<span class="sd">    x_list. If not, subsets of x_list will yield poorer approximations,</span>
<span class="sd">    which might not grand an order of accuracy of len(x_list) - order.</span>

<span class="sd">    See also</span>
<span class="sd">    ========</span>

<span class="sd">    sympy.calculus.finite_diff.apply_finite_diff</span>


<span class="sd">    References</span>
<span class="sd">    ==========</span>

<span class="sd">    .. [1] Generation of Finite Difference Formulas on Arbitrarily Spaced</span>
<span class="sd">            Grids, Bengt Fornberg; Mathematics of computation; 51; 184;</span>
<span class="sd">            (1988); 699-706; doi:10.1090/S0025-5718-1988-0935077-0</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># The notation below closely corresponds to the one used in the paper.</span>
    <span class="k">if</span> <span class="n">order</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Negative derivative order illegal.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">int</span><span class="p">(</span><span class="n">order</span><span class="p">)</span> <span class="o">!=</span> <span class="n">order</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Non-integer order illegal&quot;</span><span class="p">)</span>
    <span class="n">M</span> <span class="o">=</span> <span class="n">order</span>
    <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x_list</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="n">delta</span> <span class="o">=</span> <span class="p">[[[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">nu</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span> <span class="k">for</span>
             <span class="n">m</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">M</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>
    <span class="n">delta</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">S</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">c1</span> <span class="o">=</span> <span class="n">S</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">c2</span> <span class="o">=</span> <span class="n">S</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">nu</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
            <span class="n">c3</span> <span class="o">=</span> <span class="n">x_list</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="o">-</span><span class="n">x_list</span><span class="p">[</span><span class="n">nu</span><span class="p">]</span>
            <span class="n">c2</span> <span class="o">=</span> <span class="n">c2</span> <span class="o">*</span> <span class="n">c3</span>
            <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="n">M</span><span class="p">:</span>
                <span class="n">delta</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">nu</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">M</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
                <span class="n">delta</span><span class="p">[</span><span class="n">m</span><span class="p">][</span><span class="n">n</span><span class="p">][</span><span class="n">nu</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">x_list</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="o">-</span><span class="n">x0</span><span class="p">)</span><span class="o">*</span><span class="n">delta</span><span class="p">[</span><span class="n">m</span><span class="p">][</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">nu</span><span class="p">]</span> <span class="o">-</span>\
                    <span class="n">m</span><span class="o">*</span><span class="n">delta</span><span class="p">[</span><span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">nu</span><span class="p">]</span>
                <span class="n">delta</span><span class="p">[</span><span class="n">m</span><span class="p">][</span><span class="n">n</span><span class="p">][</span><span class="n">nu</span><span class="p">]</span> <span class="o">/=</span> <span class="n">c3</span>
        <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">M</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">delta</span><span class="p">[</span><span class="n">m</span><span class="p">][</span><span class="n">n</span><span class="p">][</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">c1</span><span class="o">/</span><span class="n">c2</span><span class="o">*</span><span class="p">(</span><span class="n">m</span><span class="o">*</span><span class="n">delta</span><span class="p">[</span><span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span>
                                    <span class="p">(</span><span class="n">x_list</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">x0</span><span class="p">)</span><span class="o">*</span><span class="n">delta</span><span class="p">[</span><span class="n">m</span><span class="p">][</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">c1</span> <span class="o">=</span> <span class="n">c2</span>
    <span class="k">return</span> <span class="n">delta</span></div>


<div class="viewcode-block" id="apply_finite_diff"><a class="viewcode-back" href="../../../modules/calculus/index.html#sympy.calculus.finite_diff.apply_finite_diff">[docs]</a><span class="k">def</span> <span class="nf">apply_finite_diff</span><span class="p">(</span><span class="n">order</span><span class="p">,</span> <span class="n">x_list</span><span class="p">,</span> <span class="n">y_list</span><span class="p">,</span> <span class="n">x0</span><span class="o">=</span><span class="n">S</span><span class="p">(</span><span class="mi">0</span><span class="p">)):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculates the finite difference approximation of</span>
<span class="sd">    the derivative of requested order at x0 from points</span>
<span class="sd">    provided in x_list and y_list.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ==========</span>

<span class="sd">    order: int</span>
<span class="sd">        order of derivative to approximate. 0 corresponds to interpolation.</span>
<span class="sd">    x_list: sequence</span>
<span class="sd">        Sequence of (unique) values for the independent variable.</span>
<span class="sd">    y_list: sequence</span>
<span class="sd">        The function value at corresponding values for the independent</span>
<span class="sd">        variable in x_list.</span>
<span class="sd">    x0: Number or Symbol</span>
<span class="sd">        At what value of the independent variable the derivative should be</span>
<span class="sd">        evaluated. Defaults to S(0).</span>

<span class="sd">    Returns</span>
<span class="sd">    =======</span>

<span class="sd">    sympy.core.add.Add or sympy.core.numbers.Number</span>
<span class="sd">        The finite difference expression approximating the requested</span>
<span class="sd">        derivative order at x0.</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy.calculus import apply_finite_diff</span>
<span class="sd">    &gt;&gt;&gt; cube = lambda arg: (1.0*arg)**3</span>
<span class="sd">    &gt;&gt;&gt; xlist = range(-3,3+1)</span>
<span class="sd">    &gt;&gt;&gt; apply_finite_diff(2, xlist, map(cube, xlist), 2) - 12 # doctest: +SKIP</span>
<span class="sd">    -3.55271367880050e-15</span>

<span class="sd">    we see that the example above only contain rounding errors.</span>
<span class="sd">    apply_finite_diff can also be used on more abstract objects:</span>

<span class="sd">    &gt;&gt;&gt; from sympy import IndexedBase, Idx</span>
<span class="sd">    &gt;&gt;&gt; from sympy.calculus import apply_finite_diff</span>
<span class="sd">    &gt;&gt;&gt; x, y = map(IndexedBase, &#39;xy&#39;)</span>
<span class="sd">    &gt;&gt;&gt; i = Idx(&#39;i&#39;)</span>
<span class="sd">    &gt;&gt;&gt; x_list, y_list = zip(*[(x[i+j], y[i+j]) for j in range(-1,2)])</span>
<span class="sd">    &gt;&gt;&gt; apply_finite_diff(1, x_list, y_list, x[i])</span>
<span class="sd">    (-1 + (x[i + 1] - x[i])/(-x[i - 1] + x[i]))*y[i]/(x[i + 1] - x[i]) + \</span>
<span class="sd">(-x[i - 1] + x[i])*y[i + 1]/((-x[i - 1] + x[i + 1])*(x[i + 1] - x[i])) - \</span>
<span class="sd">(x[i + 1] - x[i])*y[i - 1]/((-x[i - 1] + x[i + 1])*(-x[i - 1] + x[i]))</span>


<span class="sd">    Notes</span>
<span class="sd">    =====</span>

<span class="sd">    Order = 0 corresponds to interpolation.</span>
<span class="sd">    Only supply so many points you think makes sense</span>
<span class="sd">    to around x0 when extracting the derivative (the function</span>
<span class="sd">    need to be well behaved within that region). Also beware</span>
<span class="sd">    of Runge&#39;s phenomenon.</span>

<span class="sd">    See also</span>
<span class="sd">    ========</span>

<span class="sd">    sympy.calculus.finite_diff.finite_diff_weights</span>

<span class="sd">    References</span>
<span class="sd">    ==========</span>

<span class="sd">    Fortran 90 implementation with Python interface for numerics: finitediff_</span>

<span class="sd">    .. _finitediff: https://github.com/bjodah/finitediff</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># In the original paper the following holds for the notation:</span>
    <span class="c1"># M = order</span>
    <span class="c1"># N = len(x_list) - 1</span>

    <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x_list</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x_list</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">y_list</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;x_list and y_list not equal in length.&quot;</span><span class="p">)</span>

    <span class="n">delta</span> <span class="o">=</span> <span class="n">finite_diff_weights</span><span class="p">(</span><span class="n">order</span><span class="p">,</span> <span class="n">x_list</span><span class="p">,</span> <span class="n">x0</span><span class="p">)</span>

    <span class="n">derivative</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">nu</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">x_list</span><span class="p">)):</span>
        <span class="n">derivative</span> <span class="o">+=</span> <span class="n">delta</span><span class="p">[</span><span class="n">order</span><span class="p">][</span><span class="n">N</span><span class="p">][</span><span class="n">nu</span><span class="p">]</span><span class="o">*</span><span class="n">y_list</span><span class="p">[</span><span class="n">nu</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">derivative</span></div>


<div class="viewcode-block" id="as_finite_diff"><a class="viewcode-back" href="../../../modules/calculus/index.html#sympy.calculus.finite_diff.as_finite_diff">[docs]</a><span class="k">def</span> <span class="nf">as_finite_diff</span><span class="p">(</span><span class="n">derivative</span><span class="p">,</span> <span class="n">points</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">x0</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">wrt</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns an approximation of a derivative of a function in</span>
<span class="sd">    the form of a finite difference formula. The expression is a</span>
<span class="sd">    weighted sum of the function at a number of discrete values of</span>
<span class="sd">    (one of) the independent variable(s).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ==========</span>

<span class="sd">    derivative: a Derivative instance (needs to have an variables</span>
<span class="sd">        and expr attribute).</span>

<span class="sd">    points: sequence or coefficient, optional</span>
<span class="sd">        If sequence: discrete values (length &gt;= order+1) of the</span>
<span class="sd">        independent variable used for generating the finite</span>
<span class="sd">        difference weights.</span>
<span class="sd">        If it is a coefficient, it will be used as the step-size</span>
<span class="sd">        for generating an equidistant sequence of length order+1</span>
<span class="sd">        centered around x0. default: 1 (step-size 1)</span>

<span class="sd">    x0: number or Symbol, optional</span>
<span class="sd">        the value of the independent variable (wrt) at which the</span>
<span class="sd">        derivative is to be approximated. default: same as wrt</span>

<span class="sd">    wrt: Symbol, optional</span>
<span class="sd">        &quot;with respect to&quot; the variable for which the (partial)</span>
<span class="sd">        derivative is to be approximated for. If not provided it</span>
<span class="sd">        is required that the Derivative is ordinary. default: None</span>


<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy import symbols, Function, exp, sqrt, Symbol, as_finite_diff</span>
<span class="sd">    &gt;&gt;&gt; x, h = symbols(&#39;x h&#39;)</span>
<span class="sd">    &gt;&gt;&gt; f = Function(&#39;f&#39;)</span>
<span class="sd">    &gt;&gt;&gt; as_finite_diff(f(x).diff(x))</span>
<span class="sd">    -f(x - 1/2) + f(x + 1/2)</span>

<span class="sd">    The default step size and number of points are 1 and ``order + 1``</span>
<span class="sd">    respectively. We can change the step size by passing a symbol</span>
<span class="sd">    as a parameter:</span>

<span class="sd">    &gt;&gt;&gt; as_finite_diff(f(x).diff(x), h)</span>
<span class="sd">    -f(-h/2 + x)/h + f(h/2 + x)/h</span>

<span class="sd">    We can also specify the discretized values to be used in a sequence:</span>

<span class="sd">    &gt;&gt;&gt; as_finite_diff(f(x).diff(x), [x, x+h, x+2*h])</span>
<span class="sd">    -3*f(x)/(2*h) + 2*f(h + x)/h - f(2*h + x)/(2*h)</span>

<span class="sd">    The algorithm is not restricted to use equidistant spacing, nor</span>
<span class="sd">    do we need to make the approximation around x0, but we can get</span>
<span class="sd">    an expression estimating the derivative at an offset:</span>

<span class="sd">    &gt;&gt;&gt; e, sq2 = exp(1), sqrt(2)</span>
<span class="sd">    &gt;&gt;&gt; xl = [x-h, x+h, x+e*h]</span>
<span class="sd">    &gt;&gt;&gt; as_finite_diff(f(x).diff(x, 1), xl, x+h*sq2)</span>
<span class="sd">    2*h*((h + sqrt(2)*h)/(2*h) - (-sqrt(2)*h + h)/(2*h))*f(E*h + x)/\</span>
<span class="sd">((-h + E*h)*(h + E*h)) + (-(-sqrt(2)*h + h)/(2*h) - \</span>
<span class="sd">(-sqrt(2)*h + E*h)/(2*h))*f(-h + x)/(h + E*h) + \</span>
<span class="sd">(-(h + sqrt(2)*h)/(2*h) + (-sqrt(2)*h + E*h)/(2*h))*f(h + x)/(-h + E*h)</span>

<span class="sd">    Partial derivatives are also supported:</span>

<span class="sd">    &gt;&gt;&gt; y = Symbol(&#39;y&#39;)</span>
<span class="sd">    &gt;&gt;&gt; d2fdxdy=f(x,y).diff(x,y)</span>
<span class="sd">    &gt;&gt;&gt; as_finite_diff(d2fdxdy, wrt=x)</span>
<span class="sd">    -f(x - 1/2, y) + f(x + 1/2, y)</span>

<span class="sd">    See also</span>
<span class="sd">    ========</span>

<span class="sd">    sympy.calculus.finite_diff.apply_finite_diff</span>
<span class="sd">    sympy.calculus.finite_diff.finite_diff_weights</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">wrt</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">wrt</span> <span class="o">=</span> <span class="n">derivative</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># we need Derivative to be univariate to guess wrt</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">v</span> <span class="o">!=</span> <span class="n">wrt</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">derivative</span><span class="o">.</span><span class="n">variables</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;if the function is not univariate&#39;</span> <span class="o">+</span>
                             <span class="s1">&#39; then `wrt` must be given&#39;</span><span class="p">)</span>

    <span class="n">order</span> <span class="o">=</span> <span class="n">derivative</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">wrt</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">x0</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">x0</span> <span class="o">=</span> <span class="n">wrt</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">iterable</span><span class="p">(</span><span class="n">points</span><span class="p">):</span>
        <span class="c1"># points is simply the step-size, let&#39;s make it a</span>
        <span class="c1"># equidistant sequence centered around x0</span>
        <span class="k">if</span> <span class="n">order</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># even order =&gt; odd number of points, grid point included</span>
            <span class="n">points</span> <span class="o">=</span> <span class="p">[</span><span class="n">x0</span> <span class="o">+</span> <span class="n">points</span><span class="o">*</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span>
                      <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="n">order</span><span class="o">//</span><span class="mi">2</span><span class="p">,</span> <span class="n">order</span><span class="o">//</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># odd order =&gt; even number of points, half-way wrt grid point</span>
            <span class="n">points</span> <span class="o">=</span> <span class="p">[</span><span class="n">x0</span> <span class="o">+</span> <span class="n">points</span><span class="o">*</span><span class="n">i</span><span class="o">/</span><span class="n">S</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span>
                      <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="n">order</span><span class="p">,</span> <span class="n">order</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)]</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">points</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">order</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Too few points for order </span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">order</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">apply_finite_diff</span><span class="p">(</span><span class="n">order</span><span class="p">,</span> <span class="n">points</span><span class="p">,</span> <span class="p">[</span>
        <span class="n">derivative</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">subs</span><span class="p">({</span><span class="n">wrt</span><span class="p">:</span> <span class="n">x</span><span class="p">})</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">points</span><span class="p">],</span> <span class="n">x0</span><span class="p">)</span></div>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../../index.html">
              <img class="logo" src="../../../_static/sympylogo.png" alt="Logo"/>
            </a></p><div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../index.html">Documentation overview</a><ul>
  <li><a href="../../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2015 SymPy Development Team.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.4.1</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.7</a>
      
    </div>

    

    
  </body>
</html>