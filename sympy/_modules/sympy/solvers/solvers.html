<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>sympy.solvers.solvers &mdash; SymPy 1.0.1.dev documentation</title>
    
    <link rel="stylesheet" href="../../../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="http://96.sympy-live-tests.appspot.com/static/live-core.css" type="text/css" />
    <link rel="stylesheet" href="http://96.sympy-live-tests.appspot.com/static/live-autocomplete.css" type="text/css" />
    <link rel="stylesheet" href="http://96.sympy-live-tests.appspot.com/static/live-sphinx.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '1.0.1.dev',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="http://96.sympy-live-tests.appspot.com/static/utilities.js"></script>
    <script type="text/javascript" src="http://96.sympy-live-tests.appspot.com/static/external/classy.js"></script>
    <script type="text/javascript" src="http://96.sympy-live-tests.appspot.com/static/live-core.js"></script>
    <script type="text/javascript" src="http://96.sympy-live-tests.appspot.com/static/live-autocomplete.js"></script>
    <script type="text/javascript" src="http://96.sympy-live-tests.appspot.com/static/live-sphinx.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML-full"></script>
    <link rel="shortcut icon" href="../../../_static/sympy-notailtext-favicon.ico"/>
    <link rel="top" title="SymPy 1.0.1.dev documentation" href="../../../index.html" />
    <link rel="up" title="Module code" href="../../index.html" />
   
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head>
  <body role="document">  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for sympy.solvers.solvers</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">This module contain solvers for all kinds of equations:</span>

<span class="sd">    - algebraic or transcendental, use solve()</span>

<span class="sd">    - recurrence, use rsolve()</span>

<span class="sd">    - differential, use dsolve()</span>

<span class="sd">    - nonlinear (numerically), use nsolve()</span>
<span class="sd">      (you will need a good starting point)</span>

<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">print_function</span><span class="p">,</span> <span class="n">division</span>

<span class="kn">from</span> <span class="nn">sympy.core.compatibility</span> <span class="kn">import</span> <span class="p">(</span><span class="n">iterable</span><span class="p">,</span> <span class="n">is_sequence</span><span class="p">,</span> <span class="n">ordered</span><span class="p">,</span>
    <span class="n">default_sort_key</span><span class="p">,</span> <span class="nb">range</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">sympy.core.sympify</span> <span class="kn">import</span> <span class="n">sympify</span>
<span class="kn">from</span> <span class="nn">sympy.core</span> <span class="kn">import</span> <span class="n">S</span><span class="p">,</span> <span class="n">Add</span><span class="p">,</span> <span class="n">Symbol</span><span class="p">,</span> <span class="n">Equality</span><span class="p">,</span> <span class="n">Dummy</span><span class="p">,</span> <span class="n">Expr</span><span class="p">,</span> <span class="n">Mul</span><span class="p">,</span> <span class="n">Pow</span>
<span class="kn">from</span> <span class="nn">sympy.core.exprtools</span> <span class="kn">import</span> <span class="n">factor_terms</span>
<span class="kn">from</span> <span class="nn">sympy.core.function</span> <span class="kn">import</span> <span class="p">(</span><span class="n">expand_mul</span><span class="p">,</span> <span class="n">expand_multinomial</span><span class="p">,</span> <span class="n">expand_log</span><span class="p">,</span>
                          <span class="n">Derivative</span><span class="p">,</span> <span class="n">AppliedUndef</span><span class="p">,</span> <span class="n">UndefinedFunction</span><span class="p">,</span> <span class="n">nfloat</span><span class="p">,</span>
                          <span class="n">Function</span><span class="p">,</span> <span class="n">expand_power_exp</span><span class="p">,</span> <span class="n">Lambda</span><span class="p">,</span> <span class="n">_mexpand</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">sympy.integrals.integrals</span> <span class="kn">import</span> <span class="n">Integral</span>
<span class="kn">from</span> <span class="nn">sympy.core.numbers</span> <span class="kn">import</span> <span class="n">ilcm</span><span class="p">,</span> <span class="n">Float</span>
<span class="kn">from</span> <span class="nn">sympy.core.relational</span> <span class="kn">import</span> <span class="n">Relational</span><span class="p">,</span> <span class="n">Ge</span>
<span class="kn">from</span> <span class="nn">sympy.core.logic</span> <span class="kn">import</span> <span class="n">fuzzy_not</span>
<span class="kn">from</span> <span class="nn">sympy.logic.boolalg</span> <span class="kn">import</span> <span class="n">And</span><span class="p">,</span> <span class="n">Or</span><span class="p">,</span> <span class="n">BooleanAtom</span>
<span class="kn">from</span> <span class="nn">sympy.core.basic</span> <span class="kn">import</span> <span class="n">preorder_traversal</span>

<span class="kn">from</span> <span class="nn">sympy.functions</span> <span class="kn">import</span> <span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">exp</span><span class="p">,</span> <span class="n">LambertW</span><span class="p">,</span> <span class="n">cos</span><span class="p">,</span> <span class="n">sin</span><span class="p">,</span> <span class="n">tan</span><span class="p">,</span> <span class="n">acos</span><span class="p">,</span> <span class="n">asin</span><span class="p">,</span> <span class="n">atan</span><span class="p">,</span>
                             <span class="n">Abs</span><span class="p">,</span> <span class="n">re</span><span class="p">,</span> <span class="n">im</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="n">sqrt</span><span class="p">,</span> <span class="n">atan2</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">sympy.functions.elementary.trigonometric</span> <span class="kn">import</span> <span class="p">(</span><span class="n">TrigonometricFunction</span><span class="p">,</span>
                                                      <span class="n">HyperbolicFunction</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">sympy.simplify</span> <span class="kn">import</span> <span class="p">(</span><span class="n">simplify</span><span class="p">,</span> <span class="n">collect</span><span class="p">,</span> <span class="n">powsimp</span><span class="p">,</span> <span class="n">posify</span><span class="p">,</span> <span class="n">powdenest</span><span class="p">,</span>
                            <span class="n">nsimplify</span><span class="p">,</span> <span class="n">denom</span><span class="p">,</span> <span class="n">logcombine</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">sympy.simplify.sqrtdenest</span> <span class="kn">import</span> <span class="n">sqrt_depth</span>
<span class="kn">from</span> <span class="nn">sympy.simplify.fu</span> <span class="kn">import</span> <span class="n">TR1</span>
<span class="kn">from</span> <span class="nn">sympy.matrices</span> <span class="kn">import</span> <span class="n">Matrix</span><span class="p">,</span> <span class="n">zeros</span>
<span class="kn">from</span> <span class="nn">sympy.polys</span> <span class="kn">import</span> <span class="n">roots</span><span class="p">,</span> <span class="n">cancel</span><span class="p">,</span> <span class="n">factor</span><span class="p">,</span> <span class="n">Poly</span><span class="p">,</span> <span class="n">together</span><span class="p">,</span> <span class="n">degree</span>
<span class="kn">from</span> <span class="nn">sympy.polys.polyerrors</span> <span class="kn">import</span> <span class="n">GeneratorsNeeded</span><span class="p">,</span> <span class="n">PolynomialError</span>
<span class="kn">from</span> <span class="nn">sympy.functions.elementary.piecewise</span> <span class="kn">import</span> <span class="n">piecewise_fold</span><span class="p">,</span> <span class="n">Piecewise</span>

<span class="kn">from</span> <span class="nn">sympy.utilities.lambdify</span> <span class="kn">import</span> <span class="n">lambdify</span>
<span class="kn">from</span> <span class="nn">sympy.utilities.misc</span> <span class="kn">import</span> <span class="n">filldedent</span>
<span class="kn">from</span> <span class="nn">sympy.utilities.iterables</span> <span class="kn">import</span> <span class="n">uniq</span><span class="p">,</span> <span class="n">generate_bell</span><span class="p">,</span> <span class="n">flatten</span>

<span class="kn">from</span> <span class="nn">mpmath</span> <span class="kn">import</span> <span class="n">findroot</span>

<span class="kn">from</span> <span class="nn">sympy.solvers.polysys</span> <span class="kn">import</span> <span class="n">solve_poly_system</span>
<span class="kn">from</span> <span class="nn">sympy.solvers.inequalities</span> <span class="kn">import</span> <span class="n">reduce_inequalities</span>

<span class="kn">from</span> <span class="nn">types</span> <span class="kn">import</span> <span class="n">GeneratorType</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span>
<span class="kn">import</span> <span class="nn">warnings</span>


<span class="k">def</span> <span class="nf">_ispow</span><span class="p">(</span><span class="n">e</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return True if e is a Pow or is exp.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">Expr</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">is_Pow</span> <span class="ow">or</span> <span class="n">e</span><span class="o">.</span><span class="n">func</span> <span class="ow">is</span> <span class="n">exp</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_simple_dens</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">symbols</span><span class="p">):</span>
    <span class="c1"># when checking if a denominator is zero, we can just check the</span>
    <span class="c1"># base of powers with nonzero exponents since if the base is zero</span>
    <span class="c1"># the power will be zero, too. To keep it simple and fast, we</span>
    <span class="c1"># limit simplification to exponents that are Numbers</span>
    <span class="n">dens</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">denoms</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">symbols</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">d</span><span class="o">.</span><span class="n">is_Pow</span> <span class="ow">and</span> <span class="n">d</span><span class="o">.</span><span class="n">exp</span><span class="o">.</span><span class="n">is_Number</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">d</span><span class="o">.</span><span class="n">exp</span><span class="o">.</span><span class="n">is_zero</span><span class="p">:</span>
                <span class="k">continue</span>  <span class="c1"># foo**0 is never 0</span>
            <span class="n">d</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">base</span>
        <span class="n">dens</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">dens</span>


<span class="k">def</span> <span class="nf">denoms</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">symbols</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return (recursively) set of all denominators that appear in eq</span>
<span class="sd">    that contain any symbol in iterable ``symbols``; if ``symbols`` is</span>
<span class="sd">    None (default) then all denominators will be returned.</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy.solvers.solvers import denoms</span>
<span class="sd">    &gt;&gt;&gt; from sympy.abc import x, y, z</span>
<span class="sd">    &gt;&gt;&gt; from sympy import sqrt</span>

<span class="sd">    &gt;&gt;&gt; denoms(x/y)</span>
<span class="sd">    set([y])</span>

<span class="sd">    &gt;&gt;&gt; denoms(x/(y*z))</span>
<span class="sd">    set([y, z])</span>

<span class="sd">    &gt;&gt;&gt; denoms(3/x + y/z)</span>
<span class="sd">    set([x, z])</span>

<span class="sd">    &gt;&gt;&gt; denoms(x/2 + y/z)</span>
<span class="sd">    set([2, z])</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">pot</span> <span class="o">=</span> <span class="n">preorder_traversal</span><span class="p">(</span><span class="n">eq</span><span class="p">)</span>
    <span class="n">dens</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">pot</span><span class="p">:</span>
        <span class="n">den</span> <span class="o">=</span> <span class="n">denom</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">den</span> <span class="ow">is</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">Mul</span><span class="o">.</span><span class="n">make_args</span><span class="p">(</span><span class="n">den</span><span class="p">):</span>
            <span class="n">dens</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">symbols</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">dens</span>
    <span class="n">rv</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">dens</span><span class="p">:</span>
        <span class="n">free</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">free_symbols</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">s</span> <span class="ow">in</span> <span class="n">free</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">symbols</span><span class="p">):</span>
            <span class="n">rv</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">set</span><span class="p">(</span><span class="n">rv</span><span class="p">)</span>


<div class="viewcode-block" id="checksol"><a class="viewcode-back" href="../../../modules/solvers/solvers.html#sympy.solvers.solvers.checksol">[docs]</a><span class="k">def</span> <span class="nf">checksol</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">symbol</span><span class="p">,</span> <span class="n">sol</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="o">**</span><span class="n">flags</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Checks whether sol is a solution of equation f == 0.</span>

<span class="sd">    Input can be either a single symbol and corresponding value</span>
<span class="sd">    or a dictionary of symbols and values. When given as a dictionary</span>
<span class="sd">    and flag ``simplify=True``, the values in the dictionary will be</span>
<span class="sd">    simplified. ``f`` can be a single equation or an iterable of equations.</span>
<span class="sd">    A solution must satisfy all equations in ``f`` to be considered valid;</span>
<span class="sd">    if a solution does not satisfy any equation, False is returned; if one or</span>
<span class="sd">    more checks are inconclusive (and none are False) then None</span>
<span class="sd">    is returned.</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy import symbols</span>
<span class="sd">    &gt;&gt;&gt; from sympy.solvers import checksol</span>
<span class="sd">    &gt;&gt;&gt; x, y = symbols(&#39;x,y&#39;)</span>
<span class="sd">    &gt;&gt;&gt; checksol(x**4 - 1, x, 1)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; checksol(x**4 - 1, x, 0)</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; checksol(x**2 + y**2 - 5**2, {x: 3, y: 4})</span>
<span class="sd">    True</span>

<span class="sd">    To check if an expression is zero using checksol, pass it</span>
<span class="sd">    as ``f`` and send an empty dictionary for ``symbol``:</span>

<span class="sd">    &gt;&gt;&gt; checksol(x**2 + x - x*(x + 1), {})</span>
<span class="sd">    True</span>

<span class="sd">    None is returned if checksol() could not conclude.</span>

<span class="sd">    flags:</span>
<span class="sd">        &#39;numerical=True (default)&#39;</span>
<span class="sd">           do a fast numerical check if ``f`` has only one symbol.</span>
<span class="sd">        &#39;minimal=True (default is False)&#39;</span>
<span class="sd">           a very fast, minimal testing.</span>
<span class="sd">        &#39;warn=True (default is False)&#39;</span>
<span class="sd">           show a warning if checksol() could not conclude.</span>
<span class="sd">        &#39;simplify=True (default)&#39;</span>
<span class="sd">           simplify solution before substituting into function and</span>
<span class="sd">           simplify the function before trying specific simplifications</span>
<span class="sd">        &#39;force=True (default is False)&#39;</span>
<span class="sd">           make positive all symbols without assumptions regarding sign.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">sympy.physics.units</span> <span class="kn">import</span> <span class="n">Unit</span>

    <span class="n">minimal</span> <span class="o">=</span> <span class="n">flags</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;minimal&#39;</span><span class="p">,</span> <span class="bp">False</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">sol</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">sol</span> <span class="o">=</span> <span class="p">{</span><span class="n">symbol</span><span class="p">:</span> <span class="n">sol</span><span class="p">}</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">symbol</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
        <span class="n">sol</span> <span class="o">=</span> <span class="n">symbol</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;Expecting (sym, val) or ({sym: val}, None) but got (</span><span class="si">%s</span><span class="s1">, </span><span class="si">%s</span><span class="s1">)&#39;</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span> <span class="o">%</span> <span class="p">(</span><span class="n">symbol</span><span class="p">,</span> <span class="n">sol</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">iterable</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">f</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;no functions to check&#39;</span><span class="p">)</span>
        <span class="n">rv</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">for</span> <span class="n">fi</span> <span class="ow">in</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">check</span> <span class="o">=</span> <span class="n">checksol</span><span class="p">(</span><span class="n">fi</span><span class="p">,</span> <span class="n">sol</span><span class="p">,</span> <span class="o">**</span><span class="n">flags</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">check</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="n">check</span> <span class="ow">is</span> <span class="bp">False</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">False</span>
            <span class="n">rv</span> <span class="o">=</span> <span class="bp">None</span>  <span class="c1"># don&#39;t return, wait to see if there&#39;s a False</span>
        <span class="k">return</span> <span class="n">rv</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">Poly</span><span class="p">):</span>
        <span class="n">f</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">as_expr</span><span class="p">()</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">Equality</span><span class="p">):</span>
        <span class="n">f</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">lhs</span> <span class="o">-</span> <span class="n">f</span><span class="o">.</span><span class="n">rhs</span>


    <span class="k">if</span> <span class="ow">not</span> <span class="n">f</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">True</span>

    <span class="k">if</span> <span class="n">sol</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">f</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="o">*</span><span class="nb">list</span><span class="p">(</span><span class="n">sol</span><span class="o">.</span><span class="n">keys</span><span class="p">())):</span>
        <span class="c1"># if f(y) == 0, x=3 does not set f(y) to zero...nor does it not</span>
        <span class="k">return</span> <span class="bp">None</span>

    <span class="n">illegal</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="n">S</span><span class="o">.</span><span class="n">NaN</span><span class="p">,</span>
               <span class="n">S</span><span class="o">.</span><span class="n">ComplexInfinity</span><span class="p">,</span>
               <span class="n">S</span><span class="o">.</span><span class="n">Infinity</span><span class="p">,</span>
               <span class="n">S</span><span class="o">.</span><span class="n">NegativeInfinity</span><span class="p">])</span>
    <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">sympify</span><span class="p">(</span><span class="n">v</span><span class="p">)</span><span class="o">.</span><span class="n">atoms</span><span class="p">()</span> <span class="o">&amp;</span> <span class="n">illegal</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">sol</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
        <span class="k">return</span> <span class="bp">False</span>

    <span class="n">was</span> <span class="o">=</span> <span class="n">f</span>
    <span class="n">attempt</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
    <span class="n">numerical</span> <span class="o">=</span> <span class="n">flags</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;numerical&#39;</span><span class="p">,</span> <span class="bp">True</span><span class="p">)</span>
    <span class="k">while</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">attempt</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">attempt</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">val</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">sol</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">Mul</span><span class="p">):</span>
                <span class="n">val</span> <span class="o">=</span> <span class="n">val</span><span class="o">.</span><span class="n">as_independent</span><span class="p">(</span><span class="n">Unit</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">val</span><span class="o">.</span><span class="n">atoms</span><span class="p">()</span> <span class="o">&amp;</span> <span class="n">illegal</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">False</span>
        <span class="k">elif</span> <span class="n">attempt</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">val</span><span class="o">.</span><span class="n">free_symbols</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">val</span><span class="o">.</span><span class="n">is_constant</span><span class="p">(</span><span class="o">*</span><span class="nb">list</span><span class="p">(</span><span class="n">sol</span><span class="o">.</span><span class="n">keys</span><span class="p">()),</span> <span class="n">simplify</span><span class="o">=</span><span class="ow">not</span> <span class="n">minimal</span><span class="p">):</span>
                    <span class="k">return</span> <span class="bp">False</span>
                <span class="c1"># there are free symbols -- simple expansion might work</span>
                <span class="n">_</span><span class="p">,</span> <span class="n">val</span> <span class="o">=</span> <span class="n">val</span><span class="o">.</span><span class="n">as_content_primitive</span><span class="p">()</span>
                <span class="n">val</span> <span class="o">=</span> <span class="n">expand_mul</span><span class="p">(</span><span class="n">expand_multinomial</span><span class="p">(</span><span class="n">val</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">attempt</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">minimal</span><span class="p">:</span>
                <span class="k">return</span>
            <span class="k">if</span> <span class="n">flags</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;simplify&#39;</span><span class="p">,</span> <span class="bp">True</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">sol</span><span class="p">:</span>
                    <span class="n">sol</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">simplify</span><span class="p">(</span><span class="n">sol</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
            <span class="c1"># start over without the failed expanded form, possibly</span>
            <span class="c1"># with a simplified solution</span>
            <span class="n">val</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">sol</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">flags</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;force&#39;</span><span class="p">,</span> <span class="bp">True</span><span class="p">):</span>
                <span class="n">val</span><span class="p">,</span> <span class="n">reps</span> <span class="o">=</span> <span class="n">posify</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
                <span class="c1"># expansion may work now, so try again and check</span>
                <span class="n">exval</span> <span class="o">=</span> <span class="n">expand_mul</span><span class="p">(</span><span class="n">expand_multinomial</span><span class="p">(</span><span class="n">val</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">exval</span><span class="o">.</span><span class="n">is_number</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">exval</span><span class="o">.</span><span class="n">free_symbols</span><span class="p">:</span>
                    <span class="c1"># we can decide now</span>
                    <span class="n">val</span> <span class="o">=</span> <span class="n">exval</span>
        <span class="k">elif</span> <span class="n">attempt</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">val</span> <span class="o">=</span> <span class="n">powsimp</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">attempt</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
            <span class="n">val</span> <span class="o">=</span> <span class="n">cancel</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">attempt</span> <span class="o">==</span> <span class="mi">5</span><span class="p">:</span>
            <span class="n">val</span> <span class="o">=</span> <span class="n">val</span><span class="o">.</span><span class="n">expand</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">attempt</span> <span class="o">==</span> <span class="mi">6</span><span class="p">:</span>
            <span class="n">val</span> <span class="o">=</span> <span class="n">together</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">attempt</span> <span class="o">==</span> <span class="mi">7</span><span class="p">:</span>
            <span class="n">val</span> <span class="o">=</span> <span class="n">powsimp</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># if there are no radicals and no functions then this can&#39;t be</span>
            <span class="c1"># zero anymore -- can it?</span>
            <span class="n">pot</span> <span class="o">=</span> <span class="n">preorder_traversal</span><span class="p">(</span><span class="n">expand_mul</span><span class="p">(</span><span class="n">val</span><span class="p">))</span>
            <span class="n">seen</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
            <span class="n">saw_pow_func</span> <span class="o">=</span> <span class="bp">False</span>
            <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">pot</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">seen</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="n">seen</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">p</span><span class="o">.</span><span class="n">is_Pow</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">p</span><span class="o">.</span><span class="n">exp</span><span class="o">.</span><span class="n">is_Integer</span><span class="p">:</span>
                    <span class="n">saw_pow_func</span> <span class="o">=</span> <span class="bp">True</span>
                <span class="k">elif</span> <span class="n">p</span><span class="o">.</span><span class="n">is_Function</span><span class="p">:</span>
                    <span class="n">saw_pow_func</span> <span class="o">=</span> <span class="bp">True</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">UndefinedFunction</span><span class="p">):</span>
                    <span class="n">saw_pow_func</span> <span class="o">=</span> <span class="bp">True</span>
                <span class="k">if</span> <span class="n">saw_pow_func</span><span class="p">:</span>
                    <span class="k">break</span>
            <span class="k">if</span> <span class="n">saw_pow_func</span> <span class="ow">is</span> <span class="bp">False</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">False</span>
            <span class="k">if</span> <span class="n">flags</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;force&#39;</span><span class="p">,</span> <span class="bp">True</span><span class="p">):</span>
                <span class="c1"># don&#39;t do a zero check with the positive assumptions in place</span>
                <span class="n">val</span> <span class="o">=</span> <span class="n">val</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">reps</span><span class="p">)</span>
            <span class="n">nz</span> <span class="o">=</span> <span class="n">fuzzy_not</span><span class="p">(</span><span class="n">val</span><span class="o">.</span><span class="n">is_zero</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">nz</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="c1"># issue 5673: nz may be True even when False</span>
                <span class="c1"># so these are just hacks to keep a false positive</span>
                <span class="c1"># from being returned</span>

                <span class="c1"># HACK 1: LambertW (issue 5673)</span>
                <span class="k">if</span> <span class="n">val</span><span class="o">.</span><span class="n">is_number</span> <span class="ow">and</span> <span class="n">val</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">LambertW</span><span class="p">):</span>
                    <span class="c1"># don&#39;t eval this to verify solution since if we got here,</span>
                    <span class="c1"># numerical must be False</span>
                    <span class="k">return</span> <span class="bp">None</span>

                <span class="c1"># add other HACKs here if necessary, otherwise we assume</span>
                <span class="c1"># the nz value is correct</span>
                <span class="k">return</span> <span class="ow">not</span> <span class="n">nz</span>
            <span class="k">break</span>

        <span class="k">if</span> <span class="n">val</span> <span class="o">==</span> <span class="n">was</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="k">elif</span> <span class="n">val</span><span class="o">.</span><span class="n">is_Rational</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">val</span> <span class="o">==</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">numerical</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">val</span><span class="o">.</span><span class="n">free_symbols</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">bool</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">val</span><span class="o">.</span><span class="n">n</span><span class="p">(</span><span class="mi">18</span><span class="p">)</span><span class="o">.</span><span class="n">n</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="n">chop</span><span class="o">=</span><span class="bp">True</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mf">1e-9</span><span class="p">)</span>
        <span class="n">was</span> <span class="o">=</span> <span class="n">val</span>

    <span class="k">if</span> <span class="n">flags</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;warn&#39;</span><span class="p">,</span> <span class="bp">False</span><span class="p">):</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n\t</span><span class="s2">Warning: could not verify solution </span><span class="si">%s</span><span class="s2">.&quot;</span> <span class="o">%</span> <span class="n">sol</span><span class="p">)</span></div>
    <span class="c1"># returns None if it can&#39;t conclude</span>
    <span class="c1"># TODO: improve solution testing</span>


<div class="viewcode-block" id="check_assumptions"><a class="viewcode-back" href="../../../modules/solvers/solvers.html#sympy.solvers.solvers.check_assumptions">[docs]</a><span class="k">def</span> <span class="nf">check_assumptions</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="o">**</span><span class="n">assumptions</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Checks whether expression `expr` satisfies all assumptions.</span>

<span class="sd">    `assumptions` is a dict of assumptions: {&#39;assumption&#39;: True|False, ...}.</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">       &gt;&gt;&gt; from sympy import Symbol, pi, I, exp</span>
<span class="sd">       &gt;&gt;&gt; from sympy.solvers.solvers import check_assumptions</span>

<span class="sd">       &gt;&gt;&gt; check_assumptions(-5, integer=True)</span>
<span class="sd">       True</span>
<span class="sd">       &gt;&gt;&gt; check_assumptions(pi, real=True, integer=False)</span>
<span class="sd">       True</span>
<span class="sd">       &gt;&gt;&gt; check_assumptions(pi, real=True, negative=True)</span>
<span class="sd">       False</span>
<span class="sd">       &gt;&gt;&gt; check_assumptions(exp(I*pi/7), real=False)</span>
<span class="sd">       True</span>

<span class="sd">       &gt;&gt;&gt; x = Symbol(&#39;x&#39;, real=True, positive=True)</span>
<span class="sd">       &gt;&gt;&gt; check_assumptions(2*x + 1, real=True, positive=True)</span>
<span class="sd">       True</span>
<span class="sd">       &gt;&gt;&gt; check_assumptions(-2*x - 5, real=True, positive=True)</span>
<span class="sd">       False</span>

<span class="sd">       `None` is returned if check_assumptions() could not conclude.</span>

<span class="sd">       &gt;&gt;&gt; check_assumptions(2*x - 1, real=True, positive=True)</span>
<span class="sd">       &gt;&gt;&gt; z = Symbol(&#39;z&#39;)</span>
<span class="sd">       &gt;&gt;&gt; check_assumptions(z, real=True)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">expr</span> <span class="o">=</span> <span class="n">sympify</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>

    <span class="n">result</span> <span class="o">=</span> <span class="bp">True</span>
    <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">expected</span> <span class="ow">in</span> <span class="n">assumptions</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">expected</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="n">test</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="s1">&#39;is_&#39;</span> <span class="o">+</span> <span class="n">key</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">test</span> <span class="ow">is</span> <span class="n">expected</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="k">elif</span> <span class="n">test</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">None</span>  <span class="c1"># Can&#39;t conclude, unless an other test fails.</span>
    <span class="k">return</span> <span class="n">result</span></div>


<div class="viewcode-block" id="solve"><a class="viewcode-back" href="../../../modules/solvers/solvers.html#sympy.solvers.solvers.solve">[docs]</a><span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">symbols</span><span class="p">,</span> <span class="o">**</span><span class="n">flags</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Algebraically solves equations and systems of equations.</span>

<span class="sd">    Currently supported are:</span>
<span class="sd">        - polynomial,</span>
<span class="sd">        - transcendental</span>
<span class="sd">        - piecewise combinations of the above</span>
<span class="sd">        - systems of linear and polynomial equations</span>
<span class="sd">        - sytems containing relational expressions.</span>

<span class="sd">    Input is formed as:</span>

<span class="sd">    * f</span>
<span class="sd">        - a single Expr or Poly that must be zero,</span>
<span class="sd">        - an Equality</span>
<span class="sd">        - a Relational expression or boolean</span>
<span class="sd">        - iterable of one or more of the above</span>

<span class="sd">    * symbols (object(s) to solve for) specified as</span>
<span class="sd">        - none given (other non-numeric objects will be used)</span>
<span class="sd">        - single symbol</span>
<span class="sd">        - denested list of symbols</span>
<span class="sd">          e.g. solve(f, x, y)</span>
<span class="sd">        - ordered iterable of symbols</span>
<span class="sd">          e.g. solve(f, [x, y])</span>

<span class="sd">    * flags</span>
<span class="sd">        &#39;dict&#39;=True (default is False)</span>
<span class="sd">            return list (perhaps empty) of solution mappings</span>
<span class="sd">        &#39;set&#39;=True (default is False)</span>
<span class="sd">            return list of symbols and set of tuple(s) of solution(s)</span>
<span class="sd">        &#39;exclude=[] (default)&#39;</span>
<span class="sd">            don&#39;t try to solve for any of the free symbols in exclude;</span>
<span class="sd">            if expressions are given, the free symbols in them will</span>
<span class="sd">            be extracted automatically.</span>
<span class="sd">        &#39;check=True (default)&#39;</span>
<span class="sd">            If False, don&#39;t do any testing of solutions. This can be</span>
<span class="sd">            useful if one wants to include solutions that make any</span>
<span class="sd">            denominator zero.</span>
<span class="sd">        &#39;numerical=True (default)&#39;</span>
<span class="sd">            do a fast numerical check if ``f`` has only one symbol.</span>
<span class="sd">        &#39;minimal=True (default is False)&#39;</span>
<span class="sd">            a very fast, minimal testing.</span>
<span class="sd">        &#39;warn=True (default is False)&#39;</span>
<span class="sd">            show a warning if checksol() could not conclude.</span>
<span class="sd">        &#39;simplify=True (default)&#39;</span>
<span class="sd">            simplify all but polynomials of order 3 or greater before</span>
<span class="sd">            returning them and (if check is not False) use the</span>
<span class="sd">            general simplify function on the solutions and the</span>
<span class="sd">            expression obtained when they are substituted into the</span>
<span class="sd">            function which should be zero</span>
<span class="sd">        &#39;force=True (default is False)&#39;</span>
<span class="sd">            make positive all symbols without assumptions regarding sign.</span>
<span class="sd">        &#39;rational=True (default)&#39;</span>
<span class="sd">            recast Floats as Rational; if this option is not used, the</span>
<span class="sd">            system containing floats may fail to solve because of issues</span>
<span class="sd">            with polys. If rational=None, Floats will be recast as</span>
<span class="sd">            rationals but the answer will be recast as Floats. If the</span>
<span class="sd">            flag is False then nothing will be done to the Floats.</span>
<span class="sd">        &#39;manual=True (default is False)&#39;</span>
<span class="sd">            do not use the polys/matrix method to solve a system of</span>
<span class="sd">            equations, solve them one at a time as you might &quot;manually&quot;</span>
<span class="sd">        &#39;implicit=True (default is False)&#39;</span>
<span class="sd">            allows solve to return a solution for a pattern in terms of</span>
<span class="sd">            other functions that contain that pattern; this is only</span>
<span class="sd">            needed if the pattern is inside of some invertible function</span>
<span class="sd">            like cos, exp, ....</span>
<span class="sd">        &#39;particular=True (default is False)&#39;</span>
<span class="sd">            instructs solve to try to find a particular solution to a linear</span>
<span class="sd">            system with as many zeros as possible; this is very expensive</span>
<span class="sd">        &#39;quick=True (default is False)&#39;</span>
<span class="sd">            when using particular=True, use a fast heuristic instead to find a</span>
<span class="sd">            solution with many zeros (instead of using the very slow method</span>
<span class="sd">            guaranteed to find the largest number of zeros possible)</span>
<span class="sd">        &#39;cubics=True (default)&#39;</span>
<span class="sd">            return explicit solutions when cubic expressions are encountered</span>
<span class="sd">        &#39;quartics=True (default)&#39;</span>
<span class="sd">            return explicit solutions when quartic expressions are encountered</span>
<span class="sd">        &#39;quintics=True (default)&#39;</span>
<span class="sd">            return explicit solutions (if possible) when quintic expressions</span>
<span class="sd">            are encountered</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    The output varies according to the input and can be seen by example::</span>

<span class="sd">        &gt;&gt;&gt; from sympy import solve, Poly, Eq, Function, exp</span>
<span class="sd">        &gt;&gt;&gt; from sympy.abc import x, y, z, a, b</span>
<span class="sd">        &gt;&gt;&gt; f = Function(&#39;f&#39;)</span>

<span class="sd">    * boolean or univariate Relational</span>

<span class="sd">        &gt;&gt;&gt; solve(x &lt; 3)</span>
<span class="sd">        And(-oo &lt; x, x &lt; 3)</span>

<span class="sd">    * to always get a list of solution mappings, use flag dict=True</span>

<span class="sd">        &gt;&gt;&gt; solve(x - 3, dict=True)</span>
<span class="sd">        [{x: 3}]</span>
<span class="sd">        &gt;&gt;&gt; solve([x - 3, y - 1], dict=True)</span>
<span class="sd">        [{x: 3, y: 1}]</span>

<span class="sd">    * to get a list of symbols and set of solution(s) use flag set=True</span>

<span class="sd">        &gt;&gt;&gt; solve([x**2 - 3, y - 1], set=True)</span>
<span class="sd">        ([x, y], set([(-sqrt(3), 1), (sqrt(3), 1)]))</span>

<span class="sd">    * single expression and single symbol that is in the expression</span>

<span class="sd">        &gt;&gt;&gt; solve(x - y, x)</span>
<span class="sd">        [y]</span>
<span class="sd">        &gt;&gt;&gt; solve(x - 3, x)</span>
<span class="sd">        [3]</span>
<span class="sd">        &gt;&gt;&gt; solve(Eq(x, 3), x)</span>
<span class="sd">        [3]</span>
<span class="sd">        &gt;&gt;&gt; solve(Poly(x - 3), x)</span>
<span class="sd">        [3]</span>
<span class="sd">        &gt;&gt;&gt; solve(x**2 - y**2, x, set=True)</span>
<span class="sd">        ([x], set([(-y,), (y,)]))</span>
<span class="sd">        &gt;&gt;&gt; solve(x**4 - 1, x, set=True)</span>
<span class="sd">        ([x], set([(-1,), (1,), (-I,), (I,)]))</span>

<span class="sd">    * single expression with no symbol that is in the expression</span>

<span class="sd">        &gt;&gt;&gt; solve(3, x)</span>
<span class="sd">        []</span>
<span class="sd">        &gt;&gt;&gt; solve(x - 3, y)</span>
<span class="sd">        []</span>

<span class="sd">    * single expression with no symbol given</span>

<span class="sd">          In this case, all free symbols will be selected as potential</span>
<span class="sd">          symbols to solve for. If the equation is univariate then a list</span>
<span class="sd">          of solutions is returned; otherwise -- as is the case when symbols are</span>
<span class="sd">          given as an iterable of length &gt; 1 -- a list of mappings will be returned.</span>

<span class="sd">            &gt;&gt;&gt; solve(x - 3)</span>
<span class="sd">            [3]</span>
<span class="sd">            &gt;&gt;&gt; solve(x**2 - y**2)</span>
<span class="sd">            [{x: -y}, {x: y}]</span>
<span class="sd">            &gt;&gt;&gt; solve(z**2*x**2 - z**2*y**2)</span>
<span class="sd">            [{x: -y}, {x: y}, {z: 0}]</span>
<span class="sd">            &gt;&gt;&gt; solve(z**2*x - z**2*y**2)</span>
<span class="sd">            [{x: y**2}, {z: 0}]</span>

<span class="sd">    * when an object other than a Symbol is given as a symbol, it is</span>
<span class="sd">      isolated algebraically and an implicit solution may be obtained.</span>
<span class="sd">      This is mostly provided as a convenience to save one from replacing</span>
<span class="sd">      the object with a Symbol and solving for that Symbol. It will only</span>
<span class="sd">      work if the specified object can be replaced with a Symbol using the</span>
<span class="sd">      subs method.</span>

<span class="sd">          &gt;&gt;&gt; solve(f(x) - x, f(x))</span>
<span class="sd">          [x]</span>
<span class="sd">          &gt;&gt;&gt; solve(f(x).diff(x) - f(x) - x, f(x).diff(x))</span>
<span class="sd">          [x + f(x)]</span>
<span class="sd">          &gt;&gt;&gt; solve(f(x).diff(x) - f(x) - x, f(x))</span>
<span class="sd">          [-x + Derivative(f(x), x)]</span>
<span class="sd">          &gt;&gt;&gt; solve(x + exp(x)**2, exp(x), set=True)</span>
<span class="sd">          ([exp(x)], set([(-sqrt(-x),), (sqrt(-x),)]))</span>

<span class="sd">          &gt;&gt;&gt; from sympy import Indexed, IndexedBase, Tuple, sqrt</span>
<span class="sd">          &gt;&gt;&gt; A = IndexedBase(&#39;A&#39;)</span>
<span class="sd">          &gt;&gt;&gt; eqs = Tuple(A[1] + A[2] - 3, A[1] - A[2] + 1)</span>
<span class="sd">          &gt;&gt;&gt; solve(eqs, eqs.atoms(Indexed))</span>
<span class="sd">          {A[1]: 1, A[2]: 2}</span>

<span class="sd">        * To solve for a *symbol* implicitly, use &#39;implicit=True&#39;:</span>

<span class="sd">            &gt;&gt;&gt; solve(x + exp(x), x)</span>
<span class="sd">            [-LambertW(1)]</span>
<span class="sd">            &gt;&gt;&gt; solve(x + exp(x), x, implicit=True)</span>
<span class="sd">            [-exp(x)]</span>

<span class="sd">        * It is possible to solve for anything that can be targeted with</span>
<span class="sd">          subs:</span>

<span class="sd">            &gt;&gt;&gt; solve(x + 2 + sqrt(3), x + 2)</span>
<span class="sd">            [-sqrt(3)]</span>
<span class="sd">            &gt;&gt;&gt; solve((x + 2 + sqrt(3), x + 4 + y), y, x + 2)</span>
<span class="sd">            {y: -2 + sqrt(3), x + 2: -sqrt(3)}</span>

<span class="sd">        * Nothing heroic is done in this implicit solving so you may end up</span>
<span class="sd">          with a symbol still in the solution:</span>

<span class="sd">            &gt;&gt;&gt; eqs = (x*y + 3*y + sqrt(3), x + 4 + y)</span>
<span class="sd">            &gt;&gt;&gt; solve(eqs, y, x + 2)</span>
<span class="sd">            {y: -sqrt(3)/(x + 3), x + 2: (-2*x - 6 + sqrt(3))/(x + 3)}</span>
<span class="sd">            &gt;&gt;&gt; solve(eqs, y*x, x)</span>
<span class="sd">            {x: -y - 4, x*y: -3*y - sqrt(3)}</span>

<span class="sd">        * if you attempt to solve for a number remember that the number</span>
<span class="sd">          you have obtained does not necessarily mean that the value is</span>
<span class="sd">          equivalent to the expression obtained:</span>

<span class="sd">            &gt;&gt;&gt; solve(sqrt(2) - 1, 1)</span>
<span class="sd">            [sqrt(2)]</span>
<span class="sd">            &gt;&gt;&gt; solve(x - y + 1, 1)  # /!\ -1 is targeted, too</span>
<span class="sd">            [x/(y - 1)]</span>
<span class="sd">            &gt;&gt;&gt; [_.subs(z, -1) for _ in solve((x - y + 1).subs(-1, z), 1)]</span>
<span class="sd">            [-x + y]</span>

<span class="sd">        * To solve for a function within a derivative, use dsolve.</span>

<span class="sd">    * single expression and more than 1 symbol</span>

<span class="sd">        * when there is a linear solution</span>

<span class="sd">            &gt;&gt;&gt; solve(x - y**2, x, y)</span>
<span class="sd">            [{x: y**2}]</span>
<span class="sd">            &gt;&gt;&gt; solve(x**2 - y, x, y)</span>
<span class="sd">            [{y: x**2}]</span>

<span class="sd">        * when undetermined coefficients are identified</span>

<span class="sd">            * that are linear</span>

<span class="sd">                &gt;&gt;&gt; solve((a + b)*x - b + 2, a, b)</span>
<span class="sd">                {a: -2, b: 2}</span>

<span class="sd">            * that are nonlinear</span>

<span class="sd">                &gt;&gt;&gt; solve((a + b)*x - b**2 + 2, a, b, set=True)</span>
<span class="sd">                ([a, b], set([(-sqrt(2), sqrt(2)), (sqrt(2), -sqrt(2))]))</span>

<span class="sd">        * if there is no linear solution then the first successful</span>
<span class="sd">          attempt for a nonlinear solution will be returned</span>

<span class="sd">            &gt;&gt;&gt; solve(x**2 - y**2, x, y)</span>
<span class="sd">            [{x: -y}, {x: y}]</span>
<span class="sd">            &gt;&gt;&gt; solve(x**2 - y**2/exp(x), x, y)</span>
<span class="sd">            [{x: 2*LambertW(y/2)}]</span>
<span class="sd">            &gt;&gt;&gt; solve(x**2 - y**2/exp(x), y, x)</span>
<span class="sd">            [{y: -x*sqrt(exp(x))}, {y: x*sqrt(exp(x))}]</span>

<span class="sd">    * iterable of one or more of the above</span>

<span class="sd">        * involving relationals or bools</span>

<span class="sd">            &gt;&gt;&gt; solve([x &lt; 3, x - 2])</span>
<span class="sd">            Eq(x, 2)</span>
<span class="sd">            &gt;&gt;&gt; solve([x &gt; 3, x - 2])</span>
<span class="sd">            False</span>

<span class="sd">        * when the system is linear</span>

<span class="sd">            * with a solution</span>

<span class="sd">                &gt;&gt;&gt; solve([x - 3], x)</span>
<span class="sd">                {x: 3}</span>
<span class="sd">                &gt;&gt;&gt; solve((x + 5*y - 2, -3*x + 6*y - 15), x, y)</span>
<span class="sd">                {x: -3, y: 1}</span>
<span class="sd">                &gt;&gt;&gt; solve((x + 5*y - 2, -3*x + 6*y - 15), x, y, z)</span>
<span class="sd">                {x: -3, y: 1}</span>
<span class="sd">                &gt;&gt;&gt; solve((x + 5*y - 2, -3*x + 6*y - z), z, x, y)</span>
<span class="sd">                {x: -5*y + 2, z: 21*y - 6}</span>

<span class="sd">            * without a solution</span>

<span class="sd">                &gt;&gt;&gt; solve([x + 3, x - 3])</span>
<span class="sd">                []</span>

<span class="sd">        * when the system is not linear</span>

<span class="sd">            &gt;&gt;&gt; solve([x**2 + y -2, y**2 - 4], x, y, set=True)</span>
<span class="sd">            ([x, y], set([(-2, -2), (0, 2), (2, -2)]))</span>

<span class="sd">        * if no symbols are given, all free symbols will be selected and a list</span>
<span class="sd">          of mappings returned</span>

<span class="sd">            &gt;&gt;&gt; solve([x - 2, x**2 + y])</span>
<span class="sd">            [{x: 2, y: -4}]</span>
<span class="sd">            &gt;&gt;&gt; solve([x - 2, x**2 + f(x)], set([f(x), x]))</span>
<span class="sd">            [{x: 2, f(x): -4}]</span>

<span class="sd">        * if any equation doesn&#39;t depend on the symbol(s) given it will be</span>
<span class="sd">          eliminated from the equation set and an answer may be given</span>
<span class="sd">          implicitly in terms of variables that were not of interest</span>

<span class="sd">            &gt;&gt;&gt; solve([x - y, y - 3], x)</span>
<span class="sd">            {x: y}</span>

<span class="sd">    Notes</span>
<span class="sd">    =====</span>

<span class="sd">    solve() with check=True (default) will run through the symbol tags to</span>
<span class="sd">    elimate unwanted solutions.  If no assumptions are included all possible</span>
<span class="sd">    solutions will be returned.</span>

<span class="sd">        &gt;&gt;&gt; from sympy import Symbol, solve</span>
<span class="sd">        &gt;&gt;&gt; x = Symbol(&quot;x&quot;)</span>
<span class="sd">        &gt;&gt;&gt; solve(x**2 - 1)</span>
<span class="sd">        [-1, 1]</span>

<span class="sd">    By using the positive tag only one solution will be returned:</span>

<span class="sd">        &gt;&gt;&gt; pos = Symbol(&quot;pos&quot;, positive=True)</span>
<span class="sd">        &gt;&gt;&gt; solve(pos**2 - 1)</span>
<span class="sd">        [1]</span>


<span class="sd">    Assumptions aren&#39;t checked when `solve()` input involves</span>
<span class="sd">    relationals or bools.</span>

<span class="sd">    When the solutions are checked, those that make any denominator zero</span>
<span class="sd">    are automatically excluded. If you do not want to exclude such solutions</span>
<span class="sd">    then use the check=False option:</span>

<span class="sd">        &gt;&gt;&gt; from sympy import sin, limit</span>
<span class="sd">        &gt;&gt;&gt; solve(sin(x)/x)  # 0 is excluded</span>
<span class="sd">        [pi]</span>

<span class="sd">    If check=False then a solution to the numerator being zero is found: x = 0.</span>
<span class="sd">    In this case, this is a spurious solution since sin(x)/x has the well known</span>
<span class="sd">    limit (without dicontinuity) of 1 at x = 0:</span>

<span class="sd">        &gt;&gt;&gt; solve(sin(x)/x, check=False)</span>
<span class="sd">        [0, pi]</span>

<span class="sd">    In the following case, however, the limit exists and is equal to the the</span>
<span class="sd">    value of x = 0 that is excluded when check=True:</span>

<span class="sd">        &gt;&gt;&gt; eq = x**2*(1/x - z**2/x)</span>
<span class="sd">        &gt;&gt;&gt; solve(eq, x)</span>
<span class="sd">        []</span>
<span class="sd">        &gt;&gt;&gt; solve(eq, x, check=False)</span>
<span class="sd">        [0]</span>
<span class="sd">        &gt;&gt;&gt; limit(eq, x, 0, &#39;-&#39;)</span>
<span class="sd">        0</span>
<span class="sd">        &gt;&gt;&gt; limit(eq, x, 0, &#39;+&#39;)</span>
<span class="sd">        0</span>

<span class="sd">    Disabling high-order, explicit solutions</span>
<span class="sd">    ----------------------------------------</span>

<span class="sd">    When solving polynomial expressions, one might not want explicit solutions</span>
<span class="sd">    (which can be quite long). If the expression is univariate, CRootOf</span>
<span class="sd">    instances will be returned instead:</span>

<span class="sd">        &gt;&gt;&gt; solve(x**3 - x + 1)</span>
<span class="sd">        [-1/((-1/2 - sqrt(3)*I/2)*(3*sqrt(69)/2 + 27/2)**(1/3)) - (-1/2 -</span>
<span class="sd">        sqrt(3)*I/2)*(3*sqrt(69)/2 + 27/2)**(1/3)/3, -(-1/2 +</span>
<span class="sd">        sqrt(3)*I/2)*(3*sqrt(69)/2 + 27/2)**(1/3)/3 - 1/((-1/2 +</span>
<span class="sd">        sqrt(3)*I/2)*(3*sqrt(69)/2 + 27/2)**(1/3)), -(3*sqrt(69)/2 +</span>
<span class="sd">        27/2)**(1/3)/3 - 1/(3*sqrt(69)/2 + 27/2)**(1/3)]</span>
<span class="sd">        &gt;&gt;&gt; solve(x**3 - x + 1, cubics=False)</span>
<span class="sd">        [CRootOf(x**3 - x + 1, 0),</span>
<span class="sd">         CRootOf(x**3 - x + 1, 1),</span>
<span class="sd">         CRootOf(x**3 - x + 1, 2)]</span>

<span class="sd">        If the expression is multivariate, no solution might be returned:</span>

<span class="sd">        &gt;&gt;&gt; solve(x**3 - x + a, x, cubics=False)</span>
<span class="sd">        []</span>

<span class="sd">    Sometimes solutions will be obtained even when a flag is False because the</span>
<span class="sd">    expression could be factored. In the following example, the equation can</span>
<span class="sd">    be factored as the product of a linear and a quadratic factor so explicit</span>
<span class="sd">    solutions (which did not require solving a cubic expression) are obtained:</span>

<span class="sd">        &gt;&gt;&gt; eq = x**3 + 3*x**2 + x - 1</span>
<span class="sd">        &gt;&gt;&gt; solve(eq, cubics=False)</span>
<span class="sd">        [-1, -1 + sqrt(2), -sqrt(2) - 1]</span>

<span class="sd">    Solving equations involving radicals</span>
<span class="sd">    ------------------------------------</span>

<span class="sd">    Because of SymPy&#39;s use of the principle root (issue #8789), some solutions</span>
<span class="sd">    to radical equations will be missed unless check=False:</span>

<span class="sd">        &gt;&gt;&gt; from sympy import root</span>
<span class="sd">        &gt;&gt;&gt; eq = root(x**3 - 3*x**2, 3) + 1 - x</span>
<span class="sd">        &gt;&gt;&gt; solve(eq)</span>
<span class="sd">        []</span>
<span class="sd">        &gt;&gt;&gt; solve(eq, check=False)</span>
<span class="sd">        [1/3]</span>

<span class="sd">    In the above example there is only a single solution to the equation. Other</span>
<span class="sd">    expressions will yield spurious roots which must be checked manually;</span>
<span class="sd">    roots which give a negative argument to odd-powered radicals will also need</span>
<span class="sd">    special checking:</span>

<span class="sd">        &gt;&gt;&gt; from sympy import real_root, S</span>
<span class="sd">        &gt;&gt;&gt; eq = root(x, 3) - root(x, 5) + S(1)/7</span>
<span class="sd">        &gt;&gt;&gt; solve(eq)  # this gives 2 solutions but misses a 3rd</span>
<span class="sd">        [CRootOf(7*_p**5 - 7*_p**3 + 1, 1)**15,</span>
<span class="sd">        CRootOf(7*_p**5 - 7*_p**3 + 1, 2)**15]</span>
<span class="sd">        &gt;&gt;&gt; sol = solve(eq, check=False)</span>
<span class="sd">        &gt;&gt;&gt; [abs(eq.subs(x,i).n(2)) for i in sol]</span>
<span class="sd">        [0.48, 0.e-110, 0.e-110, 0.052, 0.052]</span>

<span class="sd">        The first solution is negative so real_root must be used to see that</span>
<span class="sd">        it satisfies the expression:</span>

<span class="sd">        &gt;&gt;&gt; abs(real_root(eq.subs(x, sol[0])).n(2))</span>
<span class="sd">        0.e-110</span>

<span class="sd">    If the roots of the equation are not real then more care will be necessary</span>
<span class="sd">    to find the roots, especially for higher order equations. Consider the</span>
<span class="sd">    following expression:</span>

<span class="sd">        &gt;&gt;&gt; expr = root(x, 3) - root(x, 5)</span>

<span class="sd">    We will construct a known value for this expression at x = 3 by selecting</span>
<span class="sd">    the 1-th root for each radical:</span>

<span class="sd">        &gt;&gt;&gt; expr1 = root(x, 3, 1) - root(x, 5, 1)</span>
<span class="sd">        &gt;&gt;&gt; v = expr1.subs(x, -3)</span>

<span class="sd">    The solve function is unable to find any exact roots to this equation:</span>

<span class="sd">        &gt;&gt;&gt; eq = Eq(expr, v); eq1 = Eq(expr1, v)</span>
<span class="sd">        &gt;&gt;&gt; solve(eq, check=False), solve(eq1, check=False)</span>
<span class="sd">        ([], [])</span>

<span class="sd">    The function unrad, however, can be used to get a form of the equation for</span>
<span class="sd">    which numerical roots can be found:</span>

<span class="sd">        &gt;&gt;&gt; from sympy.solvers.solvers import unrad</span>
<span class="sd">        &gt;&gt;&gt; from sympy import nroots</span>
<span class="sd">        &gt;&gt;&gt; e, (p, cov) = unrad(eq)</span>
<span class="sd">        &gt;&gt;&gt; pvals = nroots(e)</span>
<span class="sd">        &gt;&gt;&gt; inversion = solve(cov, x)[0]</span>
<span class="sd">        &gt;&gt;&gt; xvals = [inversion.subs(p, i) for i in pvals]</span>

<span class="sd">    Although eq or eq1 could have been used to find xvals, the solution can</span>
<span class="sd">    only be verified with expr1:</span>

<span class="sd">        &gt;&gt;&gt; z = expr - v</span>
<span class="sd">        &gt;&gt;&gt; [xi.n(chop=1e-9) for xi in xvals if abs(z.subs(x, xi).n()) &lt; 1e-9]</span>
<span class="sd">        []</span>
<span class="sd">        &gt;&gt;&gt; z1 = expr1 - v</span>
<span class="sd">        &gt;&gt;&gt; [xi.n(chop=1e-9) for xi in xvals if abs(z1.subs(x, xi).n()) &lt; 1e-9]</span>
<span class="sd">        [-3.0]</span>

<span class="sd">    See Also</span>
<span class="sd">    ========</span>

<span class="sd">        - rsolve() for solving recurrence relationships</span>
<span class="sd">        - dsolve() for solving differential equations</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># keeping track of how f was passed since if it is a list</span>
    <span class="c1"># a dictionary of results will be returned.</span>
    <span class="c1">###########################################################################</span>

    <span class="k">def</span> <span class="nf">_sympified_list</span><span class="p">(</span><span class="n">w</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">sympify</span><span class="p">,</span> <span class="n">w</span> <span class="k">if</span> <span class="n">iterable</span><span class="p">(</span><span class="n">w</span><span class="p">)</span> <span class="k">else</span> <span class="p">[</span><span class="n">w</span><span class="p">]))</span>
    <span class="n">bare_f</span> <span class="o">=</span> <span class="ow">not</span> <span class="n">iterable</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
    <span class="n">ordered_symbols</span> <span class="o">=</span> <span class="p">(</span><span class="n">symbols</span> <span class="ow">and</span>
                       <span class="n">symbols</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">and</span>
                       <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">symbols</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Symbol</span><span class="p">)</span> <span class="ow">or</span>
                        <span class="n">is_sequence</span><span class="p">(</span><span class="n">symbols</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                        <span class="n">include</span><span class="o">=</span><span class="n">GeneratorType</span><span class="p">)</span>
                       <span class="p">)</span>
                      <span class="p">)</span>
    <span class="n">f</span><span class="p">,</span> <span class="n">symbols</span> <span class="o">=</span> <span class="p">(</span><span class="n">_sympified_list</span><span class="p">(</span><span class="n">w</span><span class="p">)</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="p">[</span><span class="n">f</span><span class="p">,</span> <span class="n">symbols</span><span class="p">])</span>

    <span class="n">implicit</span> <span class="o">=</span> <span class="n">flags</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;implicit&#39;</span><span class="p">,</span> <span class="bp">False</span><span class="p">)</span>

    <span class="c1"># preprocess equation(s)</span>
    <span class="c1">###########################################################################</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">fi</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fi</span><span class="p">,</span> <span class="n">Equality</span><span class="p">):</span>
            <span class="k">if</span> <span class="s1">&#39;ImmutableMatrix&#39;</span> <span class="ow">in</span> <span class="p">[</span><span class="nb">type</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">.</span><span class="n">__name__</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">fi</span><span class="o">.</span><span class="n">args</span><span class="p">]:</span>
                <span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">fi</span><span class="o">.</span><span class="n">lhs</span> <span class="o">-</span> <span class="n">fi</span><span class="o">.</span><span class="n">rhs</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">Add</span><span class="p">(</span><span class="n">fi</span><span class="o">.</span><span class="n">lhs</span><span class="p">,</span> <span class="o">-</span><span class="n">fi</span><span class="o">.</span><span class="n">rhs</span><span class="p">,</span> <span class="n">evaluate</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fi</span><span class="p">,</span> <span class="n">Poly</span><span class="p">):</span>
            <span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">fi</span><span class="o">.</span><span class="n">as_expr</span><span class="p">()</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fi</span><span class="p">,</span> <span class="p">(</span><span class="nb">bool</span><span class="p">,</span> <span class="n">BooleanAtom</span><span class="p">))</span> <span class="ow">or</span> <span class="n">fi</span><span class="o">.</span><span class="n">is_Relational</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">reduce_inequalities</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">symbols</span><span class="o">=</span><span class="n">symbols</span><span class="p">)</span>

        <span class="c1"># rewrite hyperbolics in terms of exp</span>
        <span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="k">lambda</span> <span class="n">w</span><span class="p">:</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">HyperbolicFunction</span><span class="p">),</span>
                <span class="k">lambda</span> <span class="n">w</span><span class="p">:</span> <span class="n">w</span><span class="o">.</span><span class="n">rewrite</span><span class="p">(</span><span class="n">exp</span><span class="p">))</span>

        <span class="c1"># if we have a Matrix, we need to iterate over its elements again</span>
        <span class="k">if</span> <span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">is_Matrix</span><span class="p">:</span>
            <span class="n">bare_f</span> <span class="o">=</span> <span class="bp">False</span>
            <span class="n">f</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
            <span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">Zero</span>

        <span class="c1"># if we can split it into real and imaginary parts then do so</span>
        <span class="n">freei</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">free_symbols</span>
        <span class="k">if</span> <span class="n">freei</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">is_real</span> <span class="ow">or</span> <span class="n">s</span><span class="o">.</span><span class="n">is_imaginary</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">freei</span><span class="p">):</span>
            <span class="n">fr</span><span class="p">,</span> <span class="n">fi</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">as_real_imag</span><span class="p">()</span>
            <span class="c1"># accept as long as new re, im, arg or atan2 are not introduced</span>
            <span class="n">had</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">re</span><span class="p">,</span> <span class="n">im</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="n">atan2</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">fr</span> <span class="ow">and</span> <span class="n">fi</span> <span class="ow">and</span> <span class="n">fr</span> <span class="o">!=</span> <span class="n">fi</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">(</span>
                    <span class="n">i</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">re</span><span class="p">,</span> <span class="n">im</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="n">atan2</span><span class="p">)</span> <span class="o">-</span> <span class="n">had</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">(</span><span class="n">fr</span><span class="p">,</span> <span class="n">fi</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">bare_f</span><span class="p">:</span>
                    <span class="n">bare_f</span> <span class="o">=</span> <span class="bp">False</span>
                <span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">:</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">fr</span><span class="p">,</span> <span class="n">fi</span><span class="p">]</span>

    <span class="c1"># preprocess symbol(s)</span>
    <span class="c1">###########################################################################</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">symbols</span><span class="p">:</span>
        <span class="c1"># get symbols from equations</span>
        <span class="n">symbols</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">fi</span><span class="o">.</span><span class="n">free_symbols</span> <span class="k">for</span> <span class="n">fi</span> <span class="ow">in</span> <span class="n">f</span><span class="p">])</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">symbols</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">fi</span> <span class="ow">in</span> <span class="n">f</span><span class="p">:</span>
                <span class="n">pot</span> <span class="o">=</span> <span class="n">preorder_traversal</span><span class="p">(</span><span class="n">fi</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">pot</span><span class="p">:</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">is_number</span> <span class="ow">or</span> <span class="n">p</span><span class="o">.</span><span class="n">is_Add</span> <span class="ow">or</span> <span class="n">p</span><span class="o">.</span><span class="n">is_Mul</span><span class="p">)</span> <span class="ow">or</span> \
                            <span class="nb">isinstance</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">AppliedUndef</span><span class="p">):</span>
                        <span class="n">flags</span><span class="p">[</span><span class="s1">&#39;dict&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>  <span class="c1"># better show symbols</span>
                        <span class="n">symbols</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
                        <span class="n">pot</span><span class="o">.</span><span class="n">skip</span><span class="p">()</span>  <span class="c1"># don&#39;t go any deeper</span>
        <span class="n">symbols</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">symbols</span><span class="p">)</span>
        <span class="c1"># supply dummy symbols so solve(3) behaves like solve(3, x)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">symbols</span><span class="p">)):</span>
            <span class="n">symbols</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Dummy</span><span class="p">())</span>

        <span class="n">ordered_symbols</span> <span class="o">=</span> <span class="bp">False</span>
    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">symbols</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">iterable</span><span class="p">(</span><span class="n">symbols</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="n">symbols</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># remove symbols the user is not interested in</span>
    <span class="n">exclude</span> <span class="o">=</span> <span class="n">flags</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;exclude&#39;</span><span class="p">,</span> <span class="nb">set</span><span class="p">())</span>
    <span class="k">if</span> <span class="n">exclude</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">exclude</span><span class="p">,</span> <span class="n">Expr</span><span class="p">):</span>
            <span class="n">exclude</span> <span class="o">=</span> <span class="p">[</span><span class="n">exclude</span><span class="p">]</span>
        <span class="n">exclude</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">e</span><span class="o">.</span><span class="n">free_symbols</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">sympify</span><span class="p">(</span><span class="n">exclude</span><span class="p">)])</span>
    <span class="n">symbols</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">symbols</span> <span class="k">if</span> <span class="n">s</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">exclude</span><span class="p">]</span>

    <span class="c1"># real/imag handling -----------------------------</span>
    <span class="n">w</span> <span class="o">=</span> <span class="n">Dummy</span><span class="p">(</span><span class="s1">&#39;w&#39;</span><span class="p">)</span>
    <span class="n">piece</span> <span class="o">=</span> <span class="n">Lambda</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">Piecewise</span><span class="p">((</span><span class="n">w</span><span class="p">,</span> <span class="n">Ge</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="mi">0</span><span class="p">)),</span> <span class="p">(</span><span class="o">-</span><span class="n">w</span><span class="p">,</span> <span class="bp">True</span><span class="p">)))</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">fi</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
        <span class="c1"># Abs</span>
        <span class="n">reps</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">fi</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">Abs</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">a</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="o">*</span><span class="n">symbols</span><span class="p">):</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">is_real</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;solving </span><span class="si">%s</span><span class="s1"> when the argument &#39;</span>
                    <span class="s1">&#39;is not real or imaginary.&#39;</span> <span class="o">%</span> <span class="n">a</span><span class="p">)</span>
            <span class="n">reps</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">a</span><span class="p">,</span> <span class="n">piece</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">is_real</span> <span class="k">else</span> \
                <span class="n">piece</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">S</span><span class="o">.</span><span class="n">ImaginaryUnit</span><span class="p">)))</span>
        <span class="n">fi</span> <span class="o">=</span> <span class="n">fi</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">reps</span><span class="p">)</span>

        <span class="c1"># arg</span>
        <span class="n">_arg</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">fi</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span> <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="o">*</span><span class="n">symbols</span><span class="p">)]</span>
        <span class="n">fi</span> <span class="o">=</span> <span class="n">fi</span><span class="o">.</span><span class="n">xreplace</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">_arg</span><span class="p">,</span>
            <span class="p">[</span><span class="n">atan</span><span class="p">(</span><span class="n">im</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">/</span><span class="n">re</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">_arg</span><span class="p">]))))</span>

        <span class="c1"># save changes</span>
        <span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">fi</span>

    <span class="c1"># see if re(s) or im(s) appear</span>
    <span class="n">irf</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">symbols</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">s</span><span class="o">.</span><span class="n">is_real</span> <span class="ow">or</span> <span class="n">s</span><span class="o">.</span><span class="n">is_imaginary</span><span class="p">:</span>
            <span class="k">continue</span>  <span class="c1"># neither re(x) nor im(x) will appear</span>
        <span class="c1"># if re(s) or im(s) appear, the auxiliary equation must be present</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">fi</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">re</span><span class="p">(</span><span class="n">s</span><span class="p">),</span> <span class="n">im</span><span class="p">(</span><span class="n">s</span><span class="p">))</span> <span class="k">for</span> <span class="n">fi</span> <span class="ow">in</span> <span class="n">f</span><span class="p">):</span>
            <span class="n">irf</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">s</span><span class="p">,</span> <span class="n">re</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">+</span> <span class="n">S</span><span class="o">.</span><span class="n">ImaginaryUnit</span><span class="o">*</span><span class="n">im</span><span class="p">(</span><span class="n">s</span><span class="p">)))</span>
    <span class="k">if</span> <span class="n">irf</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">rhs</span> <span class="ow">in</span> <span class="n">irf</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">fi</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
                <span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">fi</span><span class="o">.</span><span class="n">xreplace</span><span class="p">({</span><span class="n">s</span><span class="p">:</span> <span class="n">rhs</span><span class="p">})</span>
            <span class="n">f</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">s</span> <span class="o">-</span> <span class="n">rhs</span><span class="p">)</span>
            <span class="n">symbols</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">re</span><span class="p">(</span><span class="n">s</span><span class="p">),</span> <span class="n">im</span><span class="p">(</span><span class="n">s</span><span class="p">)])</span>
        <span class="k">if</span> <span class="n">bare_f</span><span class="p">:</span>
            <span class="n">bare_f</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="n">flags</span><span class="p">[</span><span class="s1">&#39;dict&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
    <span class="c1"># end of real/imag handling  -----------------------------</span>

    <span class="n">symbols</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">uniq</span><span class="p">(</span><span class="n">symbols</span><span class="p">))</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">ordered_symbols</span><span class="p">:</span>
        <span class="c1"># we do this to make the results returned canonical in case f</span>
        <span class="c1"># contains a system of nonlinear equations; all other cases should</span>
        <span class="c1"># be unambiguous</span>
        <span class="n">symbols</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">symbols</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">default_sort_key</span><span class="p">)</span>

    <span class="c1"># we can solve for non-symbol entities by replacing them with Dummy symbols</span>
    <span class="n">symbols_new</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">symbol_swapped</span> <span class="o">=</span> <span class="bp">False</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">symbols</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">s</span><span class="o">.</span><span class="n">is_Symbol</span><span class="p">:</span>
            <span class="n">s_new</span> <span class="o">=</span> <span class="n">s</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">symbol_swapped</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="n">s_new</span> <span class="o">=</span> <span class="n">Dummy</span><span class="p">(</span><span class="s1">&#39;X</span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">i</span><span class="p">)</span>
        <span class="n">symbols_new</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">s_new</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">symbol_swapped</span><span class="p">:</span>
        <span class="n">swap_sym</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">symbols</span><span class="p">,</span> <span class="n">symbols_new</span><span class="p">))</span>
        <span class="n">f</span> <span class="o">=</span> <span class="p">[</span><span class="n">fi</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">swap_sym</span><span class="p">)</span> <span class="k">for</span> <span class="n">fi</span> <span class="ow">in</span> <span class="n">f</span><span class="p">]</span>
        <span class="n">symbols</span> <span class="o">=</span> <span class="n">symbols_new</span>
        <span class="n">swap_sym</span> <span class="o">=</span> <span class="p">{</span><span class="n">v</span><span class="p">:</span> <span class="n">k</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">swap_sym</span><span class="p">}</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">swap_sym</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="c1"># this is needed in the next two events</span>
    <span class="n">symset</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">symbols</span><span class="p">)</span>

    <span class="c1"># get rid of equations that have no symbols of interest; we don&#39;t</span>
    <span class="c1"># try to solve them because the user didn&#39;t ask and they might be</span>
    <span class="c1"># hard to solve; this means that solutions may be given in terms</span>
    <span class="c1"># of the eliminated equations e.g. solve((x-y, y-3), x) -&gt; {x: y}</span>
    <span class="n">newf</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">fi</span> <span class="ow">in</span> <span class="n">f</span><span class="p">:</span>
        <span class="c1"># let the solver handle equations that..</span>
        <span class="c1"># - have no symbols but are expressions</span>
        <span class="c1"># - have symbols of interest</span>
        <span class="c1"># - have no symbols of interest but are constant</span>
        <span class="c1"># but when an expression is not constant and has no symbols of</span>
        <span class="c1"># interest, it can&#39;t change what we obtain for a solution from</span>
        <span class="c1"># the remaining equations so we don&#39;t include it; and if it&#39;s</span>
        <span class="c1"># zero it can be removed and if it&#39;s not zero, there is no</span>
        <span class="c1"># solution for the equation set as a whole</span>
        <span class="c1">#</span>
        <span class="c1"># The reason for doing this filtering is to allow an answer</span>
        <span class="c1"># to be obtained to queries like solve((x - y, y), x); without</span>
        <span class="c1"># this mod the return value is []</span>
        <span class="n">ok</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="k">if</span> <span class="n">fi</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="o">*</span><span class="n">symset</span><span class="p">):</span>
            <span class="n">ok</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">free</span> <span class="o">=</span> <span class="n">fi</span><span class="o">.</span><span class="n">free_symbols</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">free</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">fi</span><span class="o">.</span><span class="n">is_Number</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">fi</span><span class="o">.</span><span class="n">is_zero</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="k">return</span> <span class="p">[]</span>
                <span class="n">ok</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">fi</span><span class="o">.</span><span class="n">is_constant</span><span class="p">():</span>
                    <span class="n">ok</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">if</span> <span class="n">ok</span><span class="p">:</span>
            <span class="n">newf</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fi</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">newf</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[]</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">newf</span>
    <span class="k">del</span> <span class="n">newf</span>

    <span class="c1"># mask off any Object that we aren&#39;t going to invert: Derivative,</span>
    <span class="c1"># Integral, etc... so that solving for anything that they contain will</span>
    <span class="c1"># give an implicit solution</span>
    <span class="n">seen</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="n">non_inverts</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">fi</span> <span class="ow">in</span> <span class="n">f</span><span class="p">:</span>
        <span class="n">pot</span> <span class="o">=</span> <span class="n">preorder_traversal</span><span class="p">(</span><span class="n">fi</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">pot</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">Expr</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">Piecewise</span><span class="p">):</span>
                <span class="k">pass</span>
            <span class="k">elif</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)</span> <span class="ow">or</span>
                    <span class="ow">not</span> <span class="n">p</span><span class="o">.</span><span class="n">args</span> <span class="ow">or</span>
                    <span class="n">p</span> <span class="ow">in</span> <span class="n">symset</span> <span class="ow">or</span>
                    <span class="n">p</span><span class="o">.</span><span class="n">is_Add</span> <span class="ow">or</span> <span class="n">p</span><span class="o">.</span><span class="n">is_Mul</span> <span class="ow">or</span>
                    <span class="n">p</span><span class="o">.</span><span class="n">is_Pow</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">implicit</span> <span class="ow">or</span>
                    <span class="n">p</span><span class="o">.</span><span class="n">is_Function</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">implicit</span><span class="p">)</span> <span class="ow">and</span> <span class="n">p</span><span class="o">.</span><span class="n">func</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="n">re</span><span class="p">,</span> <span class="n">im</span><span class="p">):</span>
                <span class="k">continue</span>
            <span class="k">elif</span> <span class="ow">not</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">seen</span><span class="p">:</span>
                <span class="n">seen</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">p</span><span class="o">.</span><span class="n">free_symbols</span> <span class="o">&amp;</span> <span class="n">symset</span><span class="p">:</span>
                    <span class="n">non_inverts</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">continue</span>
            <span class="n">pot</span><span class="o">.</span><span class="n">skip</span><span class="p">()</span>
    <span class="k">del</span> <span class="n">seen</span>
    <span class="n">non_inverts</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">non_inverts</span><span class="p">,</span> <span class="p">[</span><span class="n">Dummy</span><span class="p">()</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">non_inverts</span><span class="p">])))</span>
    <span class="n">f</span> <span class="o">=</span> <span class="p">[</span><span class="n">fi</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">non_inverts</span><span class="p">)</span> <span class="k">for</span> <span class="n">fi</span> <span class="ow">in</span> <span class="n">f</span><span class="p">]</span>

    <span class="n">non_inverts</span> <span class="o">=</span> <span class="p">[(</span><span class="n">v</span><span class="p">,</span> <span class="n">k</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">swap_sym</span><span class="p">))</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">non_inverts</span><span class="o">.</span><span class="n">items</span><span class="p">()]</span>

    <span class="c1"># rationalize Floats</span>
    <span class="n">floats</span> <span class="o">=</span> <span class="bp">False</span>
    <span class="k">if</span> <span class="n">flags</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;rational&#39;</span><span class="p">,</span> <span class="bp">True</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">False</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">fi</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">fi</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">Float</span><span class="p">):</span>
                <span class="n">floats</span> <span class="o">=</span> <span class="bp">True</span>
                <span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">nsimplify</span><span class="p">(</span><span class="n">fi</span><span class="p">,</span> <span class="n">rational</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

    <span class="c1"># Any embedded piecewise functions need to be brought out to the</span>
    <span class="c1"># top level so that the appropriate strategy gets selected.</span>
    <span class="c1"># However, this is necessary only if one of the piecewise</span>
    <span class="c1"># functions depends on one of the symbols we are solving for.</span>
    <span class="k">def</span> <span class="nf">_has_piecewise</span><span class="p">(</span><span class="n">e</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">e</span><span class="o">.</span><span class="n">is_Piecewise</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">e</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="o">*</span><span class="n">symbols</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">any</span><span class="p">([</span><span class="n">_has_piecewise</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">e</span><span class="o">.</span><span class="n">args</span><span class="p">])</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">fi</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">_has_piecewise</span><span class="p">(</span><span class="n">fi</span><span class="p">):</span>
            <span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">piecewise_fold</span><span class="p">(</span><span class="n">fi</span><span class="p">)</span>

    <span class="c1">#</span>
    <span class="c1"># try to get a solution</span>
    <span class="c1">###########################################################################</span>
    <span class="k">if</span> <span class="n">bare_f</span><span class="p">:</span>
        <span class="n">solution</span> <span class="o">=</span> <span class="n">_solve</span><span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">*</span><span class="n">symbols</span><span class="p">,</span> <span class="o">**</span><span class="n">flags</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">solution</span> <span class="o">=</span> <span class="n">_solve_system</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">symbols</span><span class="p">,</span> <span class="o">**</span><span class="n">flags</span><span class="p">)</span>

    <span class="c1">#</span>
    <span class="c1"># postprocessing</span>
    <span class="c1">###########################################################################</span>
    <span class="c1"># Restore masked-off objects</span>
    <span class="k">if</span> <span class="n">non_inverts</span><span class="p">:</span>

        <span class="k">def</span> <span class="nf">_do_dict</span><span class="p">(</span><span class="n">solution</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">dict</span><span class="p">([(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">non_inverts</span><span class="p">))</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span>
                         <span class="n">solution</span><span class="o">.</span><span class="n">items</span><span class="p">()])</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">solution</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">dict</span><span class="p">:</span>
                <span class="n">solution</span> <span class="o">=</span> <span class="n">_do_dict</span><span class="p">(</span><span class="n">solution</span><span class="p">)</span>
                <span class="k">break</span>
            <span class="k">elif</span> <span class="n">solution</span> <span class="ow">and</span> <span class="nb">type</span><span class="p">(</span><span class="n">solution</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">list</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">solution</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">is</span> <span class="nb">dict</span><span class="p">:</span>
                    <span class="n">solution</span> <span class="o">=</span> <span class="p">[</span><span class="n">_do_dict</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">solution</span><span class="p">]</span>
                    <span class="k">break</span>
                <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">solution</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">is</span> <span class="nb">tuple</span><span class="p">:</span>
                    <span class="n">solution</span> <span class="o">=</span> <span class="p">[</span><span class="nb">tuple</span><span class="p">([</span><span class="n">v</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">non_inverts</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">s</span><span class="p">])</span> <span class="k">for</span> <span class="n">s</span>
                                <span class="ow">in</span> <span class="n">solution</span><span class="p">]</span>
                    <span class="k">break</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">solution</span> <span class="o">=</span> <span class="p">[</span><span class="n">v</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">non_inverts</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">solution</span><span class="p">]</span>
                    <span class="k">break</span>
            <span class="k">elif</span> <span class="ow">not</span> <span class="n">solution</span><span class="p">:</span>
                <span class="k">break</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="n">filldedent</span><span class="p">(</span><span class="s1">&#39;&#39;&#39;</span>
<span class="s1">                            no handling of </span><span class="si">%s</span><span class="s1"> was implemented&#39;&#39;&#39;</span> <span class="o">%</span> <span class="n">solution</span><span class="p">))</span>

    <span class="c1"># Restore original &quot;symbols&quot; if a dictionary is returned.</span>
    <span class="c1"># This is not necessary for</span>
    <span class="c1">#   - the single univariate equation case</span>
    <span class="c1">#     since the symbol will have been removed from the solution;</span>
    <span class="c1">#   - the nonlinear poly_system since that only supports zero-dimensional</span>
    <span class="c1">#     systems and those results come back as a list</span>
    <span class="c1">#</span>
    <span class="c1"># ** unless there were Derivatives with the symbols, but those were handled</span>
    <span class="c1">#    above.</span>
    <span class="k">if</span> <span class="n">symbol_swapped</span><span class="p">:</span>
        <span class="n">symbols</span> <span class="o">=</span> <span class="p">[</span><span class="n">swap_sym</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">symbols</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">solution</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">dict</span><span class="p">:</span>
            <span class="n">solution</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">([(</span><span class="n">swap_sym</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">v</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">swap_sym</span><span class="p">))</span>
                             <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">solution</span><span class="o">.</span><span class="n">items</span><span class="p">()])</span>
        <span class="k">elif</span> <span class="n">solution</span> <span class="ow">and</span> <span class="nb">type</span><span class="p">(</span><span class="n">solution</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">list</span> <span class="ow">and</span> <span class="nb">type</span><span class="p">(</span><span class="n">solution</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">is</span> <span class="nb">dict</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">sol</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">solution</span><span class="p">):</span>
                <span class="n">solution</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">([(</span><span class="n">swap_sym</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">v</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">swap_sym</span><span class="p">))</span>
                              <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">sol</span><span class="o">.</span><span class="n">items</span><span class="p">()])</span>

    <span class="c1"># undo the dictionary solutions returned when the system was only partially</span>
    <span class="c1"># solved with poly-system if all symbols are present</span>
    <span class="k">if</span> <span class="p">(</span>
            <span class="ow">not</span> <span class="n">flags</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;dict&#39;</span><span class="p">,</span> <span class="bp">False</span><span class="p">)</span> <span class="ow">and</span>
            <span class="n">solution</span> <span class="ow">and</span>
            <span class="n">ordered_symbols</span> <span class="ow">and</span>
            <span class="nb">type</span><span class="p">(</span><span class="n">solution</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">dict</span> <span class="ow">and</span>
            <span class="nb">type</span><span class="p">(</span><span class="n">solution</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">is</span> <span class="nb">dict</span> <span class="ow">and</span>
            <span class="nb">all</span><span class="p">(</span><span class="n">s</span> <span class="ow">in</span> <span class="n">solution</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">symbols</span><span class="p">)</span>
    <span class="p">):</span>
        <span class="n">solution</span> <span class="o">=</span> <span class="p">[</span><span class="nb">tuple</span><span class="p">([</span><span class="n">r</span><span class="p">[</span><span class="n">s</span><span class="p">]</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">symbols</span><span class="p">])</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">solution</span><span class="p">]</span>

    <span class="c1"># Get assumptions about symbols, to filter solutions.</span>
    <span class="c1"># Note that if assumptions about a solution can&#39;t be verified, it is still</span>
    <span class="c1"># returned.</span>
    <span class="n">check</span> <span class="o">=</span> <span class="n">flags</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;check&#39;</span><span class="p">,</span> <span class="bp">True</span><span class="p">)</span>

    <span class="c1"># restore floats</span>
    <span class="k">if</span> <span class="n">floats</span> <span class="ow">and</span> <span class="n">solution</span> <span class="ow">and</span> <span class="n">flags</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;rational&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">solution</span> <span class="o">=</span> <span class="n">nfloat</span><span class="p">(</span><span class="n">solution</span><span class="p">,</span> <span class="n">exponent</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">check</span> <span class="ow">and</span> <span class="n">solution</span><span class="p">:</span>  <span class="c1"># assumption checking</span>

        <span class="n">warn</span> <span class="o">=</span> <span class="n">flags</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;warn&#39;</span><span class="p">,</span> <span class="bp">False</span><span class="p">)</span>
        <span class="n">got_None</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># solutions for which one or more symbols gave None</span>
        <span class="n">no_False</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># solutions for which no symbols gave False</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">solution</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">tuple</span><span class="p">:</span>
            <span class="c1"># this has already been checked and is in as_set form</span>
            <span class="k">return</span> <span class="n">solution</span>
        <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">solution</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">list</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">solution</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">is</span> <span class="nb">tuple</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">sol</span> <span class="ow">in</span> <span class="n">solution</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">symb</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">symbols</span><span class="p">,</span> <span class="n">sol</span><span class="p">):</span>
                        <span class="n">test</span> <span class="o">=</span> <span class="n">check_assumptions</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="o">**</span><span class="n">symb</span><span class="o">.</span><span class="n">assumptions0</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">test</span> <span class="ow">is</span> <span class="bp">False</span><span class="p">:</span>
                            <span class="k">break</span>
                        <span class="k">if</span> <span class="n">test</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                            <span class="n">got_None</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sol</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">no_False</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sol</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">solution</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">is</span> <span class="nb">dict</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">sol</span> <span class="ow">in</span> <span class="n">solution</span><span class="p">:</span>
                    <span class="n">a_None</span> <span class="o">=</span> <span class="bp">False</span>
                    <span class="k">for</span> <span class="n">symb</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">sol</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                        <span class="n">test</span> <span class="o">=</span> <span class="n">check_assumptions</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="o">**</span><span class="n">symb</span><span class="o">.</span><span class="n">assumptions0</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">test</span><span class="p">:</span>
                            <span class="k">continue</span>
                        <span class="k">if</span> <span class="n">test</span> <span class="ow">is</span> <span class="bp">False</span><span class="p">:</span>
                            <span class="k">break</span>
                        <span class="n">a_None</span> <span class="o">=</span> <span class="bp">True</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">no_False</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sol</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">a_None</span><span class="p">:</span>
                            <span class="n">got_None</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sol</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>  <span class="c1"># list of expressions</span>
                <span class="k">for</span> <span class="n">sol</span> <span class="ow">in</span> <span class="n">solution</span><span class="p">:</span>
                    <span class="n">test</span> <span class="o">=</span> <span class="n">check_assumptions</span><span class="p">(</span><span class="n">sol</span><span class="p">,</span> <span class="o">**</span><span class="n">symbols</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">assumptions0</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">test</span> <span class="ow">is</span> <span class="bp">False</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="n">no_False</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sol</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">test</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                        <span class="n">got_None</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sol</span><span class="p">)</span>

        <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">solution</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">dict</span><span class="p">:</span>
            <span class="n">a_None</span> <span class="o">=</span> <span class="bp">False</span>
            <span class="k">for</span> <span class="n">symb</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">solution</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">test</span> <span class="o">=</span> <span class="n">check_assumptions</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="o">**</span><span class="n">symb</span><span class="o">.</span><span class="n">assumptions0</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">test</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="k">if</span> <span class="n">test</span> <span class="ow">is</span> <span class="bp">False</span><span class="p">:</span>
                    <span class="n">no_False</span> <span class="o">=</span> <span class="bp">None</span>
                    <span class="k">break</span>
                <span class="n">a_None</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">no_False</span> <span class="o">=</span> <span class="n">solution</span>
                <span class="k">if</span> <span class="n">a_None</span><span class="p">:</span>
                    <span class="n">got_None</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">solution</span><span class="p">)</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">solution</span><span class="p">,</span> <span class="p">(</span><span class="n">Relational</span><span class="p">,</span> <span class="n">And</span><span class="p">,</span> <span class="n">Or</span><span class="p">)):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">symbols</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Length should be 1&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">warn</span> <span class="ow">and</span> <span class="n">symbols</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">assumptions0</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">filldedent</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">                    </span><span class="se">\t</span><span class="s2">Warning: assumptions about variable &#39;</span><span class="si">%s</span><span class="s2">&#39; are</span>
<span class="s2">                    not handled currently.&quot;&quot;&quot;</span> <span class="o">%</span> <span class="n">symbols</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
            <span class="c1"># TODO: check also variable assumptions for inequalities</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Unrecognized solution&#39;</span><span class="p">)</span>  <span class="c1"># improve the checker</span>

        <span class="n">solution</span> <span class="o">=</span> <span class="n">no_False</span>
        <span class="k">if</span> <span class="n">warn</span> <span class="ow">and</span> <span class="n">got_None</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">filldedent</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">                </span><span class="se">\t</span><span class="s2">Warning: assumptions concerning following solution(s)</span>
<span class="s2">                can&#39;t be checked:&quot;&quot;&quot;</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n\t</span><span class="s1">&#39;</span> <span class="o">+</span>
                <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">got_None</span><span class="p">)))</span>

    <span class="c1">#</span>
    <span class="c1"># done</span>
    <span class="c1">###########################################################################</span>

    <span class="n">as_dict</span> <span class="o">=</span> <span class="n">flags</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;dict&#39;</span><span class="p">,</span> <span class="bp">False</span><span class="p">)</span>
    <span class="n">as_set</span> <span class="o">=</span> <span class="n">flags</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;set&#39;</span><span class="p">,</span> <span class="bp">False</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">as_set</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">solution</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="c1"># Make sure that a list of solutions is ordered in a canonical way.</span>
        <span class="n">solution</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="n">default_sort_key</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">as_dict</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">as_set</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">solution</span> <span class="ow">or</span> <span class="p">[]</span>

    <span class="c1"># return a list of mappings or []</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">solution</span><span class="p">:</span>
        <span class="n">solution</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">solution</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="n">solution</span> <span class="o">=</span> <span class="p">[</span><span class="n">solution</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">iterable</span><span class="p">(</span><span class="n">solution</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">solution</span> <span class="o">=</span> <span class="p">[</span><span class="nb">dict</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">symbols</span><span class="p">,</span> <span class="n">s</span><span class="p">)))</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">solution</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">solution</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">symbols</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Length should be 1&quot;</span><span class="p">)</span>
            <span class="n">solution</span> <span class="o">=</span> <span class="p">[{</span><span class="n">symbols</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span> <span class="n">s</span><span class="p">}</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">solution</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">as_dict</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">solution</span>
    <span class="k">assert</span> <span class="n">as_set</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">solution</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[],</span> <span class="nb">set</span><span class="p">()</span>
    <span class="n">k</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">ordered</span><span class="p">(</span><span class="n">solution</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>
    <span class="k">return</span> <span class="n">k</span><span class="p">,</span> <span class="p">{</span><span class="nb">tuple</span><span class="p">([</span><span class="n">s</span><span class="p">[</span><span class="n">ki</span><span class="p">]</span> <span class="k">for</span> <span class="n">ki</span> <span class="ow">in</span> <span class="n">k</span><span class="p">])</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">solution</span><span class="p">}</span></div>


<span class="k">def</span> <span class="nf">_solve</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">symbols</span><span class="p">,</span> <span class="o">**</span><span class="n">flags</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return a checked solution for f in terms of one or more of the</span>
<span class="sd">    symbols. A list should be returned except for the case when a linear</span>
<span class="sd">    undetermined-coefficients equation is encountered (in which case</span>
<span class="sd">    a dictionary is returned).</span>

<span class="sd">    If no method is implemented to solve the equation, a NotImplementedError</span>
<span class="sd">    will be raised. In the case that conversion of an expression to a Poly</span>
<span class="sd">    gives None a ValueError will be raised.&quot;&quot;&quot;</span>

    <span class="n">not_impl_msg</span> <span class="o">=</span> <span class="s2">&quot;No algorithms are implemented to solve equation </span><span class="si">%s</span><span class="s2">&quot;</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">symbols</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">soln</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="n">free</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">free_symbols</span>
        <span class="n">ex</span> <span class="o">=</span> <span class="n">free</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="n">symbols</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ex</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">ind</span><span class="p">,</span> <span class="n">dep</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">as_independent</span><span class="p">(</span><span class="o">*</span><span class="n">symbols</span><span class="p">)</span>
            <span class="n">ex</span> <span class="o">=</span> <span class="n">ind</span><span class="o">.</span><span class="n">free_symbols</span> <span class="o">&amp;</span> <span class="n">dep</span><span class="o">.</span><span class="n">free_symbols</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ex</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">ex</span> <span class="o">=</span> <span class="n">ex</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="c1"># soln may come back as dict, list of dicts or tuples, or</span>
                <span class="c1"># tuple of symbol list and set of solution tuples</span>
                <span class="n">soln</span> <span class="o">=</span> <span class="n">solve_undetermined_coeffs</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">symbols</span><span class="p">,</span> <span class="n">ex</span><span class="p">,</span> <span class="o">**</span><span class="n">flags</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">NotImplementedError</span><span class="p">:</span>
                <span class="k">pass</span>
        <span class="k">if</span> <span class="n">soln</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">flags</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;simplify&#39;</span><span class="p">,</span> <span class="bp">True</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">soln</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">dict</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">soln</span><span class="p">:</span>
                        <span class="n">soln</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">simplify</span><span class="p">(</span><span class="n">soln</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
                <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">soln</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">list</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">soln</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">is</span> <span class="nb">dict</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">soln</span><span class="p">:</span>
                            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">d</span><span class="p">:</span>
                                <span class="n">d</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">simplify</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
                    <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">soln</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">is</span> <span class="nb">tuple</span><span class="p">:</span>
                        <span class="n">soln</span> <span class="o">=</span> <span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">simplify</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">j</span><span class="p">)</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">soln</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;unrecognized args in list&#39;</span><span class="p">)</span>
                <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">soln</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">tuple</span><span class="p">:</span>
                    <span class="n">sym</span><span class="p">,</span> <span class="n">sols</span> <span class="o">=</span> <span class="n">soln</span>
                    <span class="n">soln</span> <span class="o">=</span> <span class="n">sym</span><span class="p">,</span> <span class="p">{</span><span class="nb">tuple</span><span class="p">(</span><span class="n">simplify</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">j</span><span class="p">)</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">sols</span><span class="p">}</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;unrecognized solution type&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">soln</span>
        <span class="c1"># find first successful solution</span>
        <span class="n">failed</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">got_s</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([])</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">symbols</span><span class="p">:</span>
            <span class="n">xi</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="n">solve_linear</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">symbols</span><span class="o">=</span><span class="p">[</span><span class="n">s</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">xi</span> <span class="o">==</span> <span class="n">s</span><span class="p">:</span>
                <span class="c1"># no need to check but we should simplify if desired</span>
                <span class="k">if</span> <span class="n">flags</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;simplify&#39;</span><span class="p">,</span> <span class="bp">True</span><span class="p">):</span>
                    <span class="n">v</span> <span class="o">=</span> <span class="n">simplify</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
                <span class="n">vfree</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">free_symbols</span>
                <span class="k">if</span> <span class="n">got_s</span> <span class="ow">and</span> <span class="nb">any</span><span class="p">([</span><span class="n">ss</span> <span class="ow">in</span> <span class="n">vfree</span> <span class="k">for</span> <span class="n">ss</span> <span class="ow">in</span> <span class="n">got_s</span><span class="p">]):</span>
                    <span class="c1"># sol depends on previously solved symbols: discard it</span>
                    <span class="k">continue</span>
                <span class="n">got_s</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">xi</span><span class="p">)</span>
                <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">({</span><span class="n">xi</span><span class="p">:</span> <span class="n">v</span><span class="p">})</span>
            <span class="k">elif</span> <span class="n">xi</span><span class="p">:</span>  <span class="c1"># there might be a non-linear solution if xi is not 0</span>
                <span class="n">failed</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">failed</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">result</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">failed</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">soln</span> <span class="o">=</span> <span class="n">_solve</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="o">**</span><span class="n">flags</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">sol</span> <span class="ow">in</span> <span class="n">soln</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">got_s</span> <span class="ow">and</span> <span class="nb">any</span><span class="p">([</span><span class="n">ss</span> <span class="ow">in</span> <span class="n">sol</span><span class="o">.</span><span class="n">free_symbols</span> <span class="k">for</span> <span class="n">ss</span> <span class="ow">in</span> <span class="n">got_s</span><span class="p">]):</span>
                        <span class="c1"># sol depends on previously solved symbols: discard it</span>
                        <span class="k">continue</span>
                    <span class="n">got_s</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
                    <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">({</span><span class="n">s</span><span class="p">:</span> <span class="n">sol</span><span class="p">})</span>
            <span class="k">except</span> <span class="ne">NotImplementedError</span><span class="p">:</span>
                <span class="k">continue</span>
        <span class="k">if</span> <span class="n">got_s</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">result</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="n">not_impl_msg</span> <span class="o">%</span> <span class="n">f</span><span class="p">)</span>
    <span class="n">symbol</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># /!\ capture this flag then set it to False so that no checking in</span>
    <span class="c1"># recursive calls will be done; only the final answer is checked</span>
    <span class="n">checkdens</span> <span class="o">=</span> <span class="n">check</span> <span class="o">=</span> <span class="n">flags</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;check&#39;</span><span class="p">,</span> <span class="bp">True</span><span class="p">)</span>
    <span class="n">flags</span><span class="p">[</span><span class="s1">&#39;check&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">False</span>

    <span class="c1"># build up solutions if f is a Mul</span>
    <span class="k">if</span> <span class="n">f</span><span class="o">.</span><span class="n">is_Mul</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">f</span><span class="o">.</span><span class="n">args</span><span class="p">:</span>
            <span class="n">soln</span> <span class="o">=</span> <span class="n">_solve</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">symbol</span><span class="p">,</span> <span class="o">**</span><span class="n">flags</span><span class="p">)</span>
            <span class="n">result</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">soln</span><span class="p">))</span>
        <span class="n">result</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">check</span><span class="p">:</span>
            <span class="c1"># all solutions have been checked but now we must</span>
            <span class="c1"># check that the solutions do not set denominators</span>
            <span class="c1"># in any factor to zero</span>
            <span class="n">dens</span> <span class="o">=</span> <span class="n">_simple_dens</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">symbols</span><span class="p">)</span>
            <span class="n">result</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">result</span> <span class="k">if</span>
                <span class="nb">all</span><span class="p">(</span><span class="ow">not</span> <span class="n">checksol</span><span class="p">(</span><span class="n">den</span><span class="p">,</span> <span class="p">{</span><span class="n">symbol</span><span class="p">:</span> <span class="n">s</span><span class="p">},</span> <span class="o">**</span><span class="n">flags</span><span class="p">)</span> <span class="k">for</span> <span class="n">den</span> <span class="ow">in</span>
                <span class="n">dens</span><span class="p">)]</span>
        <span class="c1"># set flags for quick exit at end</span>
        <span class="n">check</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="n">flags</span><span class="p">[</span><span class="s1">&#39;simplify&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">False</span>

    <span class="k">elif</span> <span class="n">f</span><span class="o">.</span><span class="n">is_Piecewise</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">cond</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">args</span><span class="p">):</span>
            <span class="n">candidates</span> <span class="o">=</span> <span class="n">_solve</span><span class="p">(</span><span class="n">piecewise_fold</span><span class="p">(</span><span class="n">expr</span><span class="p">),</span> <span class="n">symbol</span><span class="p">,</span> <span class="o">**</span><span class="n">flags</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">candidate</span> <span class="ow">in</span> <span class="n">candidates</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">candidate</span> <span class="ow">in</span> <span class="n">result</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">v</span> <span class="o">=</span> <span class="p">(</span><span class="n">cond</span> <span class="o">==</span> <span class="bp">True</span><span class="p">)</span> <span class="ow">or</span> <span class="n">cond</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">symbol</span><span class="p">,</span> <span class="n">candidate</span><span class="p">)</span>
                <span class="k">except</span><span class="p">:</span>
                    <span class="n">v</span> <span class="o">=</span> <span class="bp">False</span>
                <span class="k">if</span> <span class="n">v</span> <span class="o">!=</span> <span class="bp">False</span><span class="p">:</span>
                    <span class="c1"># Only include solutions that do not match the condition</span>
                    <span class="c1"># of any previous pieces.</span>
                    <span class="n">matches_other_piece</span> <span class="o">=</span> <span class="bp">False</span>
                    <span class="k">for</span> <span class="n">other_n</span><span class="p">,</span> <span class="p">(</span><span class="n">other_expr</span><span class="p">,</span> <span class="n">other_cond</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">args</span><span class="p">):</span>
                        <span class="k">if</span> <span class="n">other_n</span> <span class="o">==</span> <span class="n">n</span><span class="p">:</span>
                            <span class="k">break</span>
                        <span class="k">if</span> <span class="n">other_cond</span> <span class="o">==</span> <span class="bp">False</span><span class="p">:</span>
                            <span class="k">continue</span>
                        <span class="k">try</span><span class="p">:</span>
                            <span class="k">if</span> <span class="n">other_cond</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">symbol</span><span class="p">,</span> <span class="n">candidate</span><span class="p">)</span> <span class="o">==</span> <span class="bp">True</span><span class="p">:</span>
                                <span class="n">matches_other_piece</span> <span class="o">=</span> <span class="bp">True</span>
                                <span class="k">break</span>
                        <span class="k">except</span><span class="p">:</span>
                            <span class="k">pass</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">matches_other_piece</span><span class="p">:</span>
                        <span class="n">v</span> <span class="o">=</span> <span class="n">v</span> <span class="o">==</span> <span class="bp">True</span> <span class="ow">or</span> <span class="n">v</span><span class="o">.</span><span class="n">doit</span><span class="p">()</span>
                        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">Relational</span><span class="p">):</span>
                            <span class="n">v</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">canonical</span>
                        <span class="n">result</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">Piecewise</span><span class="p">(</span>
                            <span class="p">(</span><span class="n">candidate</span><span class="p">,</span> <span class="n">v</span><span class="p">),</span>
                            <span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">NaN</span><span class="p">,</span> <span class="bp">True</span><span class="p">)</span>
                        <span class="p">))</span>
        <span class="n">check</span> <span class="o">=</span> <span class="bp">False</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># first see if it really depends on symbol and whether there</span>
        <span class="c1"># is only a linear solution</span>
        <span class="n">f_num</span><span class="p">,</span> <span class="n">sol</span> <span class="o">=</span> <span class="n">solve_linear</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">symbols</span><span class="o">=</span><span class="n">symbols</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">f_num</span> <span class="ow">is</span> <span class="n">S</span><span class="o">.</span><span class="n">Zero</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>
        <span class="k">elif</span> <span class="n">f_num</span><span class="o">.</span><span class="n">is_Symbol</span><span class="p">:</span>
            <span class="c1"># no need to check but simplify if desired</span>
            <span class="k">if</span> <span class="n">flags</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;simplify&#39;</span><span class="p">,</span> <span class="bp">True</span><span class="p">):</span>
                <span class="n">sol</span> <span class="o">=</span> <span class="n">simplify</span><span class="p">(</span><span class="n">sol</span><span class="p">)</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">sol</span><span class="p">]</span>

        <span class="n">result</span> <span class="o">=</span> <span class="bp">False</span>  <span class="c1"># no solution was obtained</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>  <span class="c1"># there is no failure message</span>

        <span class="c1"># Poly is generally robust enough to convert anything to</span>
        <span class="c1"># a polynomial and tell us the different generators that it</span>
        <span class="c1"># contains, so we will inspect the generators identified by</span>
        <span class="c1"># polys to figure out what to do.</span>

        <span class="c1"># try to identify a single generator that will allow us to solve this</span>
        <span class="c1"># as a polynomial, followed (perhaps) by a change of variables if the</span>
        <span class="c1"># generator is not a symbol</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">poly</span> <span class="o">=</span> <span class="n">Poly</span><span class="p">(</span><span class="n">f_num</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">poly</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;could not convert </span><span class="si">%s</span><span class="s1"> to Poly&#39;</span> <span class="o">%</span> <span class="n">f_num</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">GeneratorsNeeded</span><span class="p">:</span>
            <span class="n">simplified_f</span> <span class="o">=</span> <span class="n">simplify</span><span class="p">(</span><span class="n">f_num</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">simplified_f</span> <span class="o">!=</span> <span class="n">f_num</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">_solve</span><span class="p">(</span><span class="n">simplified_f</span><span class="p">,</span> <span class="n">symbol</span><span class="p">,</span> <span class="o">**</span><span class="n">flags</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;expression appears to be a constant&#39;</span><span class="p">)</span>

        <span class="n">gens</span> <span class="o">=</span> <span class="p">[</span><span class="n">g</span> <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">poly</span><span class="o">.</span><span class="n">gens</span> <span class="k">if</span> <span class="n">g</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">symbol</span><span class="p">)]</span>

        <span class="k">def</span> <span class="nf">_as_base_q</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Return (b**e, q) for x = b**(p*e/q) where p/q is the leading</span>
<span class="sd">            Rational of the exponent of x, e.g. exp(-2*x/3) -&gt; (exp(x), 3)</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">b</span><span class="p">,</span> <span class="n">e</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">as_base_exp</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">e</span><span class="o">.</span><span class="n">is_Rational</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">b</span><span class="p">,</span> <span class="n">e</span><span class="o">.</span><span class="n">q</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">e</span><span class="o">.</span><span class="n">is_Mul</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">x</span><span class="p">,</span> <span class="mi">1</span>
            <span class="n">c</span><span class="p">,</span> <span class="n">ee</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">as_coeff_Mul</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">is_Rational</span> <span class="ow">and</span> <span class="n">c</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span><span class="p">:</span>  <span class="c1"># c could be a Float</span>
                <span class="k">return</span> <span class="n">b</span><span class="o">**</span><span class="n">ee</span><span class="p">,</span> <span class="n">c</span><span class="o">.</span><span class="n">q</span>
            <span class="k">return</span> <span class="n">x</span><span class="p">,</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">gens</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># If there is more than one generator, it could be that the</span>
            <span class="c1"># generators have the same base but different powers, e.g.</span>
            <span class="c1">#   &gt;&gt;&gt; Poly(exp(x) + 1/exp(x))</span>
            <span class="c1">#   Poly(exp(-x) + exp(x), exp(-x), exp(x), domain=&#39;ZZ&#39;)</span>
            <span class="c1">#</span>
            <span class="c1"># If unrad was not disabled then there should be no rational</span>
            <span class="c1"># exponents appearing as in</span>
            <span class="c1">#   &gt;&gt;&gt; Poly(sqrt(x) + sqrt(sqrt(x)))</span>
            <span class="c1">#   Poly(sqrt(x) + x**(1/4), sqrt(x), x**(1/4), domain=&#39;ZZ&#39;)</span>

            <span class="n">bases</span><span class="p">,</span> <span class="n">qs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">_as_base_q</span><span class="p">(</span><span class="n">g</span><span class="p">)</span> <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">gens</span><span class="p">]))</span>
            <span class="n">bases</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">bases</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">bases</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="n">q</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="n">qs</span><span class="p">):</span>
                <span class="n">funcs</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">b</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">bases</span> <span class="k">if</span> <span class="n">b</span><span class="o">.</span><span class="n">is_Function</span><span class="p">)</span>

                <span class="n">trig</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="n">_</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">funcs</span> <span class="k">if</span>
                    <span class="nb">isinstance</span><span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">TrigonometricFunction</span><span class="p">)])</span>
                <span class="n">other</span> <span class="o">=</span> <span class="n">funcs</span> <span class="o">-</span> <span class="n">trig</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">other</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">funcs</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">trig</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">newf</span> <span class="o">=</span> <span class="n">TR1</span><span class="p">(</span><span class="n">f_num</span><span class="p">)</span><span class="o">.</span><span class="n">rewrite</span><span class="p">(</span><span class="n">tan</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">newf</span> <span class="o">!=</span> <span class="n">f_num</span><span class="p">:</span>
                        <span class="n">result</span> <span class="o">=</span> <span class="n">_solve</span><span class="p">(</span><span class="n">newf</span><span class="p">,</span> <span class="n">symbol</span><span class="p">,</span> <span class="o">**</span><span class="n">flags</span><span class="p">)</span>

                <span class="c1"># just a simple case - see if replacement of single function</span>
                <span class="c1"># clears all symbol-dependent functions, e.g.</span>
                <span class="c1"># log(x) - log(log(x) - 1) - 3 can be solved even though it has</span>
                <span class="c1"># two generators.</span>

                <span class="k">if</span> <span class="n">result</span> <span class="ow">is</span> <span class="bp">False</span> <span class="ow">and</span> <span class="n">funcs</span><span class="p">:</span>
                    <span class="n">funcs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">ordered</span><span class="p">(</span><span class="n">funcs</span><span class="p">))</span>  <span class="c1"># put shallowest function first</span>
                    <span class="n">f1</span> <span class="o">=</span> <span class="n">funcs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">t</span> <span class="o">=</span> <span class="n">Dummy</span><span class="p">(</span><span class="s1">&#39;t&#39;</span><span class="p">)</span>
                    <span class="c1"># perform the substitution</span>
                    <span class="n">ftry</span> <span class="o">=</span> <span class="n">f_num</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">f1</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>

                    <span class="c1"># if no Functions left, we can proceed with usual solve</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">ftry</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">symbol</span><span class="p">):</span>
                        <span class="n">cv_sols</span> <span class="o">=</span> <span class="n">_solve</span><span class="p">(</span><span class="n">ftry</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="o">**</span><span class="n">flags</span><span class="p">)</span>
                        <span class="n">cv_inv</span> <span class="o">=</span> <span class="n">_solve</span><span class="p">(</span><span class="n">t</span> <span class="o">-</span> <span class="n">f1</span><span class="p">,</span> <span class="n">symbol</span><span class="p">,</span> <span class="o">**</span><span class="n">flags</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                        <span class="n">sols</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
                        <span class="k">for</span> <span class="n">sol</span> <span class="ow">in</span> <span class="n">cv_sols</span><span class="p">:</span>
                            <span class="n">sols</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cv_inv</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">sol</span><span class="p">))</span>
                        <span class="n">result</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">ordered</span><span class="p">(</span><span class="n">sols</span><span class="p">))</span>

                <span class="k">if</span> <span class="n">result</span> <span class="ow">is</span> <span class="bp">False</span><span class="p">:</span>
                    <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;multiple generators </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">gens</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># e.g. case where gens are exp(x), exp(-x)</span>
                <span class="n">u</span> <span class="o">=</span> <span class="n">bases</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                <span class="n">t</span> <span class="o">=</span> <span class="n">Dummy</span><span class="p">(</span><span class="s1">&#39;t&#39;</span><span class="p">)</span>
                <span class="n">inv</span> <span class="o">=</span> <span class="n">_solve</span><span class="p">(</span><span class="n">u</span> <span class="o">-</span> <span class="n">t</span><span class="p">,</span> <span class="n">symbol</span><span class="p">,</span> <span class="o">**</span><span class="n">flags</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="p">(</span><span class="n">Pow</span><span class="p">,</span> <span class="n">exp</span><span class="p">)):</span>
                    <span class="c1"># this will be resolved by factor in _tsolve but we might</span>
                    <span class="c1"># as well try a simple expansion here to get things in</span>
                    <span class="c1"># order so something like the following will work now without</span>
                    <span class="c1"># having to factor:</span>
                    <span class="c1">#</span>
                    <span class="c1"># &gt;&gt;&gt; eq = (exp(I*(-x-2))+exp(I*(x+2)))</span>
                    <span class="c1"># &gt;&gt;&gt; eq.subs(exp(x),y)  # fails</span>
                    <span class="c1"># exp(I*(-x - 2)) + exp(I*(x + 2))</span>
                    <span class="c1"># &gt;&gt;&gt; eq.expand().subs(exp(x),y)  # works</span>
                    <span class="c1"># y**I*exp(2*I) + y**(-I)*exp(-2*I)</span>
                    <span class="k">def</span> <span class="nf">_expand</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
                        <span class="n">b</span><span class="p">,</span> <span class="n">e</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">as_base_exp</span><span class="p">()</span>
                        <span class="n">e</span> <span class="o">=</span> <span class="n">expand_mul</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
                        <span class="k">return</span> <span class="n">expand_power_exp</span><span class="p">(</span><span class="n">b</span><span class="o">**</span><span class="n">e</span><span class="p">)</span>
                    <span class="n">ftry</span> <span class="o">=</span> <span class="n">f_num</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span>
                        <span class="k">lambda</span> <span class="n">w</span><span class="p">:</span> <span class="n">w</span><span class="o">.</span><span class="n">is_Pow</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">exp</span><span class="p">),</span>
                        <span class="n">_expand</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">ftry</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">symbol</span><span class="p">):</span>
                        <span class="n">soln</span> <span class="o">=</span> <span class="n">_solve</span><span class="p">(</span><span class="n">ftry</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="o">**</span><span class="n">flags</span><span class="p">)</span>
                        <span class="n">sols</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
                        <span class="k">for</span> <span class="n">sol</span> <span class="ow">in</span> <span class="n">soln</span><span class="p">:</span>
                            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">inv</span><span class="p">:</span>
                                <span class="n">sols</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">sol</span><span class="p">))</span>
                        <span class="n">result</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">ordered</span><span class="p">(</span><span class="n">sols</span><span class="p">))</span>

        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">gens</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>

            <span class="c1"># There is only one generator that we are interested in, but</span>
            <span class="c1"># there may have been more than one generator identified by</span>
            <span class="c1"># polys (e.g. for symbols other than the one we are interested</span>
            <span class="c1"># in) so recast the poly in terms of our generator of interest.</span>
            <span class="c1"># Also use composite=True with f_num since Poly won&#39;t update</span>
            <span class="c1"># poly as documented in issue 8810.</span>

            <span class="n">poly</span> <span class="o">=</span> <span class="n">Poly</span><span class="p">(</span><span class="n">f_num</span><span class="p">,</span> <span class="n">gens</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">composite</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

            <span class="c1"># if we aren&#39;t on the tsolve-pass, use roots</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">flags</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;tsolve&#39;</span><span class="p">,</span> <span class="bp">False</span><span class="p">):</span>
                <span class="n">soln</span> <span class="o">=</span> <span class="bp">None</span>
                <span class="n">deg</span> <span class="o">=</span> <span class="n">poly</span><span class="o">.</span><span class="n">degree</span><span class="p">()</span>
                <span class="n">flags</span><span class="p">[</span><span class="s1">&#39;tsolve&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
                <span class="n">solvers</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">([(</span><span class="n">k</span><span class="p">,</span> <span class="n">flags</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="bp">True</span><span class="p">))</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span>
                    <span class="p">(</span><span class="s1">&#39;cubics&#39;</span><span class="p">,</span> <span class="s1">&#39;quartics&#39;</span><span class="p">,</span> <span class="s1">&#39;quintics&#39;</span><span class="p">)])</span>
                <span class="n">soln</span> <span class="o">=</span> <span class="n">roots</span><span class="p">(</span><span class="n">poly</span><span class="p">,</span> <span class="o">**</span><span class="n">solvers</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">sum</span><span class="p">(</span><span class="n">soln</span><span class="o">.</span><span class="n">values</span><span class="p">())</span> <span class="o">&lt;</span> <span class="n">deg</span><span class="p">:</span>
                    <span class="c1"># e.g. roots(32*x**5 + 400*x**4 + 2032*x**3 +</span>
                    <span class="c1">#            5000*x**2 + 6250*x + 3189) -&gt; {}</span>
                    <span class="c1"># so all_roots is used and RootOf instances are</span>
                    <span class="c1"># returned *unless* the system is multivariate</span>
                    <span class="c1"># or high-order EX domain.</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">soln</span> <span class="o">=</span> <span class="n">poly</span><span class="o">.</span><span class="n">all_roots</span><span class="p">()</span>
                    <span class="k">except</span> <span class="ne">NotImplementedError</span><span class="p">:</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="n">flags</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;incomplete&#39;</span><span class="p">,</span> <span class="bp">True</span><span class="p">):</span>
                                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                                <span class="n">filldedent</span><span class="p">(</span><span class="s1">&#39;&#39;&#39;</span>
<span class="s1">    Neither high-order multivariate polynomials</span>
<span class="s1">    nor sorting of EX-domain polynomials is supported.</span>
<span class="s1">    If you want to see any results, pass keyword incomplete=True to</span>
<span class="s1">    solve; to see numerical values of roots</span>
<span class="s1">    for univariate expressions, use nroots.</span>
<span class="s1">    &#39;&#39;&#39;</span><span class="p">))</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="k">pass</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">soln</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">soln</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

                <span class="k">if</span> <span class="n">soln</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="n">u</span> <span class="o">=</span> <span class="n">poly</span><span class="o">.</span><span class="n">gen</span>
                    <span class="k">if</span> <span class="n">u</span> <span class="o">!=</span> <span class="n">symbol</span><span class="p">:</span>
                        <span class="k">try</span><span class="p">:</span>
                            <span class="n">t</span> <span class="o">=</span> <span class="n">Dummy</span><span class="p">(</span><span class="s1">&#39;t&#39;</span><span class="p">)</span>
                            <span class="n">iv</span> <span class="o">=</span> <span class="n">_solve</span><span class="p">(</span><span class="n">u</span> <span class="o">-</span> <span class="n">t</span><span class="p">,</span> <span class="n">symbol</span><span class="p">,</span> <span class="o">**</span><span class="n">flags</span><span class="p">)</span>
                            <span class="n">soln</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">ordered</span><span class="p">({</span><span class="n">i</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">iv</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">soln</span><span class="p">}))</span>
                        <span class="k">except</span> <span class="ne">NotImplementedError</span><span class="p">:</span>
                            <span class="c1"># perhaps _tsolve can handle f_num</span>
                            <span class="n">soln</span> <span class="o">=</span> <span class="bp">None</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">check</span> <span class="o">=</span> <span class="bp">False</span>  <span class="c1"># only dens need to be checked</span>
                    <span class="k">if</span> <span class="n">soln</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">soln</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
                            <span class="c1"># if the flag wasn&#39;t set then unset it since high-order</span>
                            <span class="c1"># results are quite long. Perhaps one could base this</span>
                            <span class="c1"># decision on a certain critical length of the</span>
                            <span class="c1"># roots. In addition, wester test M2 has an expression</span>
                            <span class="c1"># whose roots can be shown to be real with the</span>
                            <span class="c1"># unsimplified form of the solution whereas only one of</span>
                            <span class="c1"># the simplified forms appears to be real.</span>
                            <span class="n">flags</span><span class="p">[</span><span class="s1">&#39;simplify&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">flags</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;simplify&#39;</span><span class="p">,</span> <span class="bp">False</span><span class="p">)</span>
                        <span class="n">result</span> <span class="o">=</span> <span class="n">soln</span>

    <span class="c1"># fallback if above fails</span>
    <span class="c1"># -----------------------</span>
    <span class="k">if</span> <span class="n">result</span> <span class="ow">is</span> <span class="bp">False</span><span class="p">:</span>
        <span class="c1"># try unrad</span>
        <span class="k">if</span> <span class="n">flags</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;_unrad&#39;</span><span class="p">,</span> <span class="bp">True</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">u</span> <span class="o">=</span> <span class="n">unrad</span><span class="p">(</span><span class="n">f_num</span><span class="p">,</span> <span class="n">symbol</span><span class="p">)</span>
            <span class="k">except</span> <span class="p">(</span><span class="ne">ValueError</span><span class="p">,</span> <span class="ne">NotImplementedError</span><span class="p">):</span>
                <span class="n">u</span> <span class="o">=</span> <span class="bp">False</span>
            <span class="k">if</span> <span class="n">u</span><span class="p">:</span>
                <span class="n">eq</span><span class="p">,</span> <span class="n">cov</span> <span class="o">=</span> <span class="n">u</span>
                <span class="k">if</span> <span class="n">cov</span><span class="p">:</span>
                    <span class="n">isym</span><span class="p">,</span> <span class="n">ieq</span> <span class="o">=</span> <span class="n">cov</span>
                    <span class="n">inv</span> <span class="o">=</span> <span class="n">_solve</span><span class="p">(</span><span class="n">ieq</span><span class="p">,</span> <span class="n">symbol</span><span class="p">,</span> <span class="o">**</span><span class="n">flags</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">rv</span> <span class="o">=</span> <span class="p">{</span><span class="n">inv</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">isym</span><span class="p">,</span> <span class="n">xi</span><span class="p">)</span> <span class="k">for</span> <span class="n">xi</span> <span class="ow">in</span> <span class="n">_solve</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">isym</span><span class="p">,</span> <span class="o">**</span><span class="n">flags</span><span class="p">)}</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">rv</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">_solve</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">symbol</span><span class="p">,</span> <span class="o">**</span><span class="n">flags</span><span class="p">))</span>
                    <span class="k">except</span> <span class="ne">NotImplementedError</span><span class="p">:</span>
                        <span class="n">rv</span> <span class="o">=</span> <span class="bp">None</span>
                <span class="k">if</span> <span class="n">rv</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="n">result</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">ordered</span><span class="p">(</span><span class="n">rv</span><span class="p">))</span>
                    <span class="c1"># if the flag wasn&#39;t set then unset it since unrad results</span>
                    <span class="c1"># can be quite long or of very high order</span>
                    <span class="n">flags</span><span class="p">[</span><span class="s1">&#39;simplify&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">flags</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;simplify&#39;</span><span class="p">,</span> <span class="bp">False</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">pass</span>  <span class="c1"># for coverage</span>

    <span class="c1"># try _tsolve</span>
    <span class="k">if</span> <span class="n">result</span> <span class="ow">is</span> <span class="bp">False</span><span class="p">:</span>
        <span class="n">flags</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;tsolve&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>  <span class="c1"># allow tsolve to be used on next pass</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">soln</span> <span class="o">=</span> <span class="n">_tsolve</span><span class="p">(</span><span class="n">f_num</span><span class="p">,</span> <span class="n">symbol</span><span class="p">,</span> <span class="o">**</span><span class="n">flags</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">soln</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">soln</span>
        <span class="k">except</span> <span class="n">PolynomialError</span><span class="p">:</span>
            <span class="k">pass</span>
    <span class="c1"># ----------- end of fallback ----------------------------</span>

    <span class="k">if</span> <span class="n">result</span> <span class="ow">is</span> <span class="bp">False</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">msg</span><span class="p">,</span> <span class="n">not_impl_msg</span> <span class="o">%</span> <span class="n">f</span><span class="p">]))</span>

    <span class="k">if</span> <span class="n">flags</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;simplify&#39;</span><span class="p">,</span> <span class="bp">True</span><span class="p">):</span>
        <span class="n">result</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">simplify</span><span class="p">,</span> <span class="n">result</span><span class="p">))</span>
        <span class="c1"># we just simplified the solution so we now set the flag to</span>
        <span class="c1"># False so the simplification doesn&#39;t happen again in checksol()</span>
        <span class="n">flags</span><span class="p">[</span><span class="s1">&#39;simplify&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">False</span>

    <span class="k">if</span> <span class="n">checkdens</span><span class="p">:</span>
        <span class="c1"># reject any result that makes any denom. affirmatively 0;</span>
        <span class="c1"># if in doubt, keep it</span>
        <span class="n">dens</span> <span class="o">=</span> <span class="n">_simple_dens</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">symbols</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">result</span> <span class="k">if</span>
                  <span class="nb">all</span><span class="p">(</span><span class="ow">not</span> <span class="n">checksol</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="p">{</span><span class="n">symbol</span><span class="p">:</span> <span class="n">s</span><span class="p">},</span> <span class="o">**</span><span class="n">flags</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">dens</span><span class="p">)]</span>
    <span class="k">if</span> <span class="n">check</span><span class="p">:</span>
        <span class="c1"># keep only results if the check is not False</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">[</span><span class="n">r</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">result</span> <span class="k">if</span>
                  <span class="n">checksol</span><span class="p">(</span><span class="n">f_num</span><span class="p">,</span> <span class="p">{</span><span class="n">symbol</span><span class="p">:</span> <span class="n">r</span><span class="p">},</span> <span class="o">**</span><span class="n">flags</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">False</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">result</span>


<span class="k">def</span> <span class="nf">_solve_system</span><span class="p">(</span><span class="n">exprs</span><span class="p">,</span> <span class="n">symbols</span><span class="p">,</span> <span class="o">**</span><span class="n">flags</span><span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">exprs</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[]</span>

    <span class="n">polys</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">dens</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="n">failed</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">result</span> <span class="o">=</span> <span class="bp">False</span>
    <span class="n">linear</span> <span class="o">=</span> <span class="bp">False</span>
    <span class="n">manual</span> <span class="o">=</span> <span class="n">flags</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;manual&#39;</span><span class="p">,</span> <span class="bp">False</span><span class="p">)</span>
    <span class="n">checkdens</span> <span class="o">=</span> <span class="n">check</span> <span class="o">=</span> <span class="n">flags</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;check&#39;</span><span class="p">,</span> <span class="bp">True</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">g</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">exprs</span><span class="p">):</span>
        <span class="n">dens</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">_simple_dens</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">symbols</span><span class="p">))</span>
        <span class="n">i</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="n">_invert</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="o">*</span><span class="n">symbols</span><span class="p">)</span>
        <span class="n">g</span> <span class="o">=</span> <span class="n">d</span> <span class="o">-</span> <span class="n">i</span>
        <span class="n">g</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">as_numer_denom</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">manual</span><span class="p">:</span>
            <span class="n">failed</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
            <span class="k">continue</span>

        <span class="n">poly</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">as_poly</span><span class="p">(</span><span class="o">*</span><span class="n">symbols</span><span class="p">,</span> <span class="n">extension</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">poly</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">polys</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">poly</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">failed</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">polys</span><span class="p">:</span>
        <span class="n">solved_syms</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">is_linear</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">polys</span><span class="p">):</span>
            <span class="n">n</span><span class="p">,</span> <span class="n">m</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">polys</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">symbols</span><span class="p">)</span>
            <span class="n">matrix</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">poly</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">polys</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">monom</span><span class="p">,</span> <span class="n">coeff</span> <span class="ow">in</span> <span class="n">poly</span><span class="o">.</span><span class="n">terms</span><span class="p">():</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">j</span> <span class="o">=</span> <span class="n">monom</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
                        <span class="n">matrix</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">coeff</span>
                    <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                        <span class="n">matrix</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">m</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">coeff</span>

            <span class="c1"># returns a dictionary ({symbols: values}) or None</span>
            <span class="k">if</span> <span class="n">flags</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;particular&#39;</span><span class="p">,</span> <span class="bp">False</span><span class="p">):</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">minsolve_linear_system</span><span class="p">(</span><span class="n">matrix</span><span class="p">,</span> <span class="o">*</span><span class="n">symbols</span><span class="p">,</span> <span class="o">**</span><span class="n">flags</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">solve_linear_system</span><span class="p">(</span><span class="n">matrix</span><span class="p">,</span> <span class="o">*</span><span class="n">symbols</span><span class="p">,</span> <span class="o">**</span><span class="n">flags</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">failed</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">result</span><span class="p">:</span>
                    <span class="n">solved_syms</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">solved_syms</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">linear</span> <span class="o">=</span> <span class="bp">True</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">symbols</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">polys</span><span class="p">):</span>
                <span class="kn">from</span> <span class="nn">sympy.utilities.iterables</span> <span class="kn">import</span> <span class="n">subsets</span>

                <span class="n">free</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">p</span><span class="o">.</span><span class="n">free_symbols</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">polys</span><span class="p">])</span>
                <span class="n">free</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">ordered</span><span class="p">(</span><span class="n">free</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">symbols</span><span class="p">)))</span>
                <span class="n">got_s</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
                <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">syms</span> <span class="ow">in</span> <span class="n">subsets</span><span class="p">(</span><span class="n">free</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">polys</span><span class="p">)):</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="c1"># returns [] or list of tuples of solutions for syms</span>
                        <span class="n">res</span> <span class="o">=</span> <span class="n">solve_poly_system</span><span class="p">(</span><span class="n">polys</span><span class="p">,</span> <span class="o">*</span><span class="n">syms</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">res</span><span class="p">:</span>
                            <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">res</span><span class="p">:</span>
                                <span class="n">skip</span> <span class="o">=</span> <span class="bp">False</span>
                                <span class="k">for</span> <span class="n">r1</span> <span class="ow">in</span> <span class="n">r</span><span class="p">:</span>
                                    <span class="k">if</span> <span class="n">got_s</span> <span class="ow">and</span> <span class="nb">any</span><span class="p">([</span><span class="n">ss</span> <span class="ow">in</span> <span class="n">r1</span><span class="o">.</span><span class="n">free_symbols</span>
                                           <span class="k">for</span> <span class="n">ss</span> <span class="ow">in</span> <span class="n">got_s</span><span class="p">]):</span>
                                        <span class="c1"># sol depends on previously</span>
                                        <span class="c1"># solved symbols: discard it</span>
                                        <span class="n">skip</span> <span class="o">=</span> <span class="bp">True</span>
                                <span class="k">if</span> <span class="ow">not</span> <span class="n">skip</span><span class="p">:</span>
                                    <span class="n">got_s</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">syms</span><span class="p">)</span>
                                    <span class="n">result</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="nb">dict</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">syms</span><span class="p">,</span> <span class="n">r</span><span class="p">)))])</span>
                    <span class="k">except</span> <span class="ne">NotImplementedError</span><span class="p">:</span>
                        <span class="k">pass</span>
                <span class="k">if</span> <span class="n">got_s</span><span class="p">:</span>
                    <span class="n">solved_syms</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">got_s</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;no valid subset found&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">result</span> <span class="o">=</span> <span class="n">solve_poly_system</span><span class="p">(</span><span class="n">polys</span><span class="p">,</span> <span class="o">*</span><span class="n">symbols</span><span class="p">)</span>
                    <span class="n">solved_syms</span> <span class="o">=</span> <span class="n">symbols</span>
                <span class="k">except</span> <span class="ne">NotImplementedError</span><span class="p">:</span>
                    <span class="n">failed</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">g</span><span class="o">.</span><span class="n">as_expr</span><span class="p">()</span> <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">polys</span><span class="p">])</span>
                    <span class="n">solved_syms</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">if</span> <span class="n">result</span><span class="p">:</span>
                    <span class="c1"># we don&#39;t know here if the symbols provided were given</span>
                    <span class="c1"># or not, so let solve resolve that. A list of dictionaries</span>
                    <span class="c1"># is going to always be returned from here.</span>
                    <span class="c1">#</span>
                    <span class="n">result</span> <span class="o">=</span> <span class="p">[</span><span class="nb">dict</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">solved_syms</span><span class="p">,</span> <span class="n">r</span><span class="p">)))</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">result</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">result</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">dict</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="p">[</span><span class="n">result</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">[{}]</span>

    <span class="k">if</span> <span class="n">failed</span><span class="p">:</span>
        <span class="c1"># For each failed equation, see if we can solve for one of the</span>
        <span class="c1"># remaining symbols from that equation. If so, we update the</span>
        <span class="c1"># solution set and continue with the next failed equation,</span>
        <span class="c1"># repeating until we are done or we get an equation that can&#39;t</span>
        <span class="c1"># be solved.</span>
        <span class="k">def</span> <span class="nf">_ok_syms</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
            <span class="n">rv</span> <span class="o">=</span> <span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">free_symbols</span> <span class="o">-</span> <span class="n">solved_syms</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">legal</span>
            <span class="k">if</span> <span class="n">sort</span><span class="p">:</span>
                <span class="n">rv</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">rv</span><span class="p">)</span>
                <span class="n">rv</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="n">default_sort_key</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">rv</span>

        <span class="n">solved_syms</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">solved_syms</span><span class="p">)</span>  <span class="c1"># set of symbols we have solved for</span>
        <span class="n">legal</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">symbols</span><span class="p">)</span>  <span class="c1"># what we are interested in</span>

        <span class="c1"># sort so equation with the fewest potential symbols is first</span>
        <span class="k">for</span> <span class="n">eq</span> <span class="ow">in</span> <span class="n">ordered</span><span class="p">(</span><span class="n">failed</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">_</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">_ok_syms</span><span class="p">(</span><span class="n">_</span><span class="p">))):</span>
            <span class="n">u</span> <span class="o">=</span> <span class="n">Dummy</span><span class="p">()</span>  <span class="c1"># used in solution checking</span>
            <span class="n">newresult</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">bad_results</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">got_s</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
            <span class="n">hit</span> <span class="o">=</span> <span class="bp">False</span>
            <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">result</span><span class="p">:</span>
                <span class="c1"># update eq with everything that is known so far</span>
                <span class="n">eq2</span> <span class="o">=</span> <span class="n">eq</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
                <span class="c1"># if check is True then we see if it satisfies this</span>
                <span class="c1"># equation, otherwise we just accept it</span>
                <span class="k">if</span> <span class="n">check</span> <span class="ow">and</span> <span class="n">r</span><span class="p">:</span>
                    <span class="n">b</span> <span class="o">=</span> <span class="n">checksol</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">eq2</span><span class="p">,</span> <span class="n">minimal</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">b</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                        <span class="c1"># this solution is sufficient to know whether</span>
                        <span class="c1"># it is valid or not so we either accept or</span>
                        <span class="c1"># reject it, then continue</span>
                        <span class="k">if</span> <span class="n">b</span><span class="p">:</span>
                            <span class="n">newresult</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">bad_results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
                        <span class="k">continue</span>
                <span class="c1"># search for a symbol amongst those available that</span>
                <span class="c1"># can be solved for</span>
                <span class="n">ok_syms</span> <span class="o">=</span> <span class="n">_ok_syms</span><span class="p">(</span><span class="n">eq2</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">ok_syms</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">r</span><span class="p">:</span>
                        <span class="n">newresult</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
                    <span class="k">break</span>  <span class="c1"># skip as it&#39;s independent of desired symbols</span>
                <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">ok_syms</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">soln</span> <span class="o">=</span> <span class="n">_solve</span><span class="p">(</span><span class="n">eq2</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="o">**</span><span class="n">flags</span><span class="p">)</span>
                    <span class="k">except</span> <span class="ne">NotImplementedError</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="c1"># put each solution in r and append the now-expanded</span>
                    <span class="c1"># result in the new result list; use copy since the</span>
                    <span class="c1"># solution for s in being added in-place</span>
                    <span class="k">for</span> <span class="n">sol</span> <span class="ow">in</span> <span class="n">soln</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">got_s</span> <span class="ow">and</span> <span class="nb">any</span><span class="p">([</span><span class="n">ss</span> <span class="ow">in</span> <span class="n">sol</span><span class="o">.</span><span class="n">free_symbols</span> <span class="k">for</span> <span class="n">ss</span> <span class="ow">in</span> <span class="n">got_s</span><span class="p">]):</span>
                            <span class="c1"># sol depends on previously solved symbols: discard it</span>
                            <span class="k">continue</span>
                        <span class="n">rnew</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">r</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                            <span class="n">rnew</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">sol</span><span class="p">)</span>
                        <span class="c1"># and add this new solution</span>
                        <span class="n">rnew</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="n">sol</span>
                        <span class="n">newresult</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rnew</span><span class="p">)</span>
                    <span class="n">hit</span> <span class="o">=</span> <span class="bp">True</span>
                    <span class="n">got_s</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">hit</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;could not solve </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">eq2</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">newresult</span>
                <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">bad_results</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">result</span><span class="p">:</span>
                        <span class="n">result</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>

    <span class="n">default_simplify</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">failed</span><span class="p">)</span>  <span class="c1"># rely on system-solvers to simplify</span>
    <span class="k">if</span>  <span class="n">flags</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;simplify&#39;</span><span class="p">,</span> <span class="n">default_simplify</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">result</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">r</span><span class="p">:</span>
                <span class="n">r</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">simplify</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
        <span class="n">flags</span><span class="p">[</span><span class="s1">&#39;simplify&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">False</span>  <span class="c1"># don&#39;t need to do so in checksol now</span>

    <span class="k">if</span> <span class="n">checkdens</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">[</span><span class="n">r</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">result</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">(</span><span class="n">checksol</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="o">**</span><span class="n">flags</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">dens</span><span class="p">)]</span>

    <span class="k">if</span> <span class="n">check</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">linear</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">[</span><span class="n">r</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">result</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">(</span><span class="n">checksol</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="o">**</span><span class="n">flags</span><span class="p">)</span> <span class="ow">is</span> <span class="bp">False</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">exprs</span><span class="p">)]</span>

    <span class="n">result</span> <span class="o">=</span> <span class="p">[</span><span class="n">r</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">result</span> <span class="k">if</span> <span class="n">r</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">linear</span> <span class="ow">and</span> <span class="n">result</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">result</span>


<div class="viewcode-block" id="solve_linear"><a class="viewcode-back" href="../../../modules/solvers/solvers.html#sympy.solvers.solvers.solve_linear">[docs]</a><span class="k">def</span> <span class="nf">solve_linear</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">symbols</span><span class="o">=</span><span class="p">[],</span> <span class="n">exclude</span><span class="o">=</span><span class="p">[]):</span>
    <span class="sd">r&quot;&quot;&quot; Return a tuple derived from f = lhs - rhs that is one of</span>
<span class="sd">    the following:</span>

<span class="sd">        (0, 1) meaning that ``f`` is independent of the symbols in</span>
<span class="sd">        ``symbols`` that aren&#39;t in ``exclude``, e.g::</span>

<span class="sd">            &gt;&gt;&gt; from sympy.solvers.solvers import solve_linear</span>
<span class="sd">            &gt;&gt;&gt; from sympy.abc import x, y, z</span>
<span class="sd">            &gt;&gt;&gt; from sympy import cos, sin</span>
<span class="sd">            &gt;&gt;&gt; eq = y*cos(x)**2 + y*sin(x)**2 - y  # = y*(1 - 1) = 0</span>
<span class="sd">            &gt;&gt;&gt; solve_linear(eq)</span>
<span class="sd">            (0, 1)</span>
<span class="sd">            &gt;&gt;&gt; eq = cos(x)**2 + sin(x)**2  # = 1</span>
<span class="sd">            &gt;&gt;&gt; solve_linear(eq)</span>
<span class="sd">            (0, 1)</span>
<span class="sd">            &gt;&gt;&gt; solve_linear(x, exclude=[x])</span>
<span class="sd">            (0, 1)</span>

<span class="sd">        (0, 0) meaning that there is no solution to the equation</span>
<span class="sd">        amongst the symbols given.</span>

<span class="sd">            (If the first element of the tuple is not zero then</span>
<span class="sd">            the function is guaranteed to be dependent on a symbol</span>
<span class="sd">            in ``symbols``.)</span>

<span class="sd">        (symbol, solution) where symbol appears linearly in the</span>
<span class="sd">        numerator of ``f``, is in ``symbols`` (if given) and is</span>
<span class="sd">        not in ``exclude`` (if given). No simplification is done</span>
<span class="sd">        to ``f`` other than a ``mul=True`` expansion, so the</span>
<span class="sd">        solution will correspond strictly to a unique solution.</span>

<span class="sd">        ``(n, d)`` where ``n`` and ``d`` are the numerator and</span>
<span class="sd">        denominator of ``f`` when the numerator was not linear</span>
<span class="sd">        in any symbol of interest; ``n`` will never be a symbol</span>
<span class="sd">        unless a solution for that symbol was found (in which case</span>
<span class="sd">        the second element is the solution, not the denominator).</span>


<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy.core.power import Pow</span>
<span class="sd">    &gt;&gt;&gt; from sympy.polys.polytools import cancel</span>

<span class="sd">    The variable ``x`` appears as a linear variable in each of the</span>
<span class="sd">    following:</span>

<span class="sd">    &gt;&gt;&gt; solve_linear(x + y**2)</span>
<span class="sd">    (x, -y**2)</span>
<span class="sd">    &gt;&gt;&gt; solve_linear(1/x - y**2)</span>
<span class="sd">    (x, y**(-2))</span>

<span class="sd">    When not linear in x or y then the numerator and denominator are returned.</span>

<span class="sd">    &gt;&gt;&gt; solve_linear(x**2/y**2 - 3)</span>
<span class="sd">    (x**2 - 3*y**2, y**2)</span>

<span class="sd">    If the numerator of the expression is a symbol then (0, 0) is</span>
<span class="sd">    returned if the solution for that symbol would have set any</span>
<span class="sd">    denominator to 0:</span>

<span class="sd">    &gt;&gt;&gt; eq = 1/(1/x - 2)</span>
<span class="sd">    &gt;&gt;&gt; eq.as_numer_denom()</span>
<span class="sd">    (x, -2*x + 1)</span>
<span class="sd">    &gt;&gt;&gt; solve_linear(eq)</span>
<span class="sd">    (0, 0)</span>

<span class="sd">    But automatic rewriting may cause a symbol in the denominator to</span>
<span class="sd">    appear in the numerator so a solution will be returned:</span>

<span class="sd">    &gt;&gt;&gt; (1/x)**-1</span>
<span class="sd">    x</span>
<span class="sd">    &gt;&gt;&gt; solve_linear((1/x)**-1)</span>
<span class="sd">    (x, 0)</span>

<span class="sd">    Use an unevaluated expression to avoid this:</span>

<span class="sd">    &gt;&gt;&gt; solve_linear(Pow(1/x, -1, evaluate=False))</span>
<span class="sd">    (0, 0)</span>

<span class="sd">    If ``x`` is allowed to cancel in the following expression, then it</span>
<span class="sd">    appears to be linear in ``x``, but this sort of cancellation is not</span>
<span class="sd">    done by ``solve_linear`` so the solution will always satisfy the</span>
<span class="sd">    original expression without causing a division by zero error.</span>

<span class="sd">    &gt;&gt;&gt; eq = x**2*(1/x - z**2/x)</span>
<span class="sd">    &gt;&gt;&gt; solve_linear(cancel(eq))</span>
<span class="sd">    (x, 0)</span>
<span class="sd">    &gt;&gt;&gt; solve_linear(eq)</span>
<span class="sd">    (x**2*(-z**2 + 1), x)</span>

<span class="sd">    A list of symbols for which a solution is desired may be given:</span>

<span class="sd">    &gt;&gt;&gt; solve_linear(x + y + z, symbols=[y])</span>
<span class="sd">    (y, -x - z)</span>

<span class="sd">    A list of symbols to ignore may also be given:</span>

<span class="sd">    &gt;&gt;&gt; solve_linear(x + y + z, exclude=[x])</span>
<span class="sd">    (y, -x - z)</span>

<span class="sd">    (A solution for ``y`` is obtained because it is the first variable</span>
<span class="sd">    from the canonically sorted list of symbols that had a linear</span>
<span class="sd">    solution.)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">Equality</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">rhs</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">filldedent</span><span class="p">(</span><span class="s1">&#39;&#39;&#39;</span>
<span class="s1">            If lhs is an Equality, rhs must be 0 but was </span><span class="si">%s</span><span class="s1">&#39;&#39;&#39;</span> <span class="o">%</span> <span class="n">rhs</span><span class="p">))</span>
        <span class="n">rhs</span> <span class="o">=</span> <span class="n">lhs</span><span class="o">.</span><span class="n">rhs</span>
        <span class="n">lhs</span> <span class="o">=</span> <span class="n">lhs</span><span class="o">.</span><span class="n">lhs</span>
    <span class="n">dens</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="n">eq</span> <span class="o">=</span> <span class="n">lhs</span> <span class="o">-</span> <span class="n">rhs</span>
    <span class="n">n</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="n">eq</span><span class="o">.</span><span class="n">as_numer_denom</span><span class="p">()</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">n</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">S</span><span class="o">.</span><span class="n">Zero</span><span class="p">,</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span>

    <span class="n">free</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">free_symbols</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">symbols</span><span class="p">:</span>
        <span class="n">symbols</span> <span class="o">=</span> <span class="n">free</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">bad</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">symbols</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">s</span><span class="o">.</span><span class="n">is_Symbol</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">bad</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">bad</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">bad</span> <span class="o">=</span> <span class="n">bad</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">symbols</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">eg</span> <span class="o">=</span> <span class="s1">&#39;solve(</span><span class="si">%s</span><span class="s1">, </span><span class="si">%s</span><span class="s1">)&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">symbols</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">eg</span> <span class="o">=</span> <span class="s1">&#39;solve(</span><span class="si">%s</span><span class="s1">, *</span><span class="si">%s</span><span class="s1">)&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="n">symbols</span><span class="p">))</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">filldedent</span><span class="p">(</span><span class="s1">&#39;&#39;&#39;</span>
<span class="s1">                solve_linear only handles symbols, not </span><span class="si">%s</span><span class="s1">. To isolate</span>
<span class="s1">                non-symbols use solve, e.g. &gt;&gt;&gt; </span><span class="si">%s</span><span class="s1"> &lt;&lt;&lt;.</span>
<span class="s1">                             &#39;&#39;&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">bad</span><span class="p">,</span> <span class="n">eg</span><span class="p">)))</span>
        <span class="n">symbols</span> <span class="o">=</span> <span class="n">free</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">symbols</span><span class="p">)</span>
    <span class="n">symbols</span> <span class="o">=</span> <span class="n">symbols</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">exclude</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">symbols</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">S</span><span class="o">.</span><span class="n">Zero</span><span class="p">,</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span>
    <span class="n">dfree</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">free_symbols</span>

    <span class="c1"># derivatives are easy to do but tricky to analyze to see if they</span>
    <span class="c1"># are going to disallow a linear solution, so for simplicity we</span>
    <span class="c1"># just evaluate the ones that have the symbols of interest</span>
    <span class="n">derivs</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">der</span> <span class="ow">in</span> <span class="n">n</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">Derivative</span><span class="p">):</span>
        <span class="n">csym</span> <span class="o">=</span> <span class="n">der</span><span class="o">.</span><span class="n">free_symbols</span> <span class="o">&amp;</span> <span class="n">symbols</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">csym</span><span class="p">:</span>
            <span class="n">derivs</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">der</span><span class="p">)</span>

    <span class="n">all_zero</span> <span class="o">=</span> <span class="bp">True</span>
    <span class="k">for</span> <span class="n">xi</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">symbols</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">default_sort_key</span><span class="p">):</span>  <span class="c1"># canonical order</span>
        <span class="c1"># if there are derivatives in this var, calculate them now</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">derivs</span><span class="p">[</span><span class="n">xi</span><span class="p">])</span> <span class="ow">is</span> <span class="nb">list</span><span class="p">:</span>
            <span class="n">derivs</span><span class="p">[</span><span class="n">xi</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="n">der</span><span class="p">:</span> <span class="n">der</span><span class="o">.</span><span class="n">doit</span><span class="p">()</span> <span class="k">for</span> <span class="n">der</span> <span class="ow">in</span> <span class="n">derivs</span><span class="p">[</span><span class="n">xi</span><span class="p">]}</span>
        <span class="n">newn</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">derivs</span><span class="p">[</span><span class="n">xi</span><span class="p">])</span>
        <span class="n">dnewn_dxi</span> <span class="o">=</span> <span class="n">newn</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">xi</span><span class="p">)</span>
        <span class="c1"># dnewn_dxi can be nonzero if it survives differentation by any</span>
        <span class="c1"># of its free symbols</span>
        <span class="n">free</span> <span class="o">=</span> <span class="n">dnewn_dxi</span><span class="o">.</span><span class="n">free_symbols</span>
        <span class="k">if</span> <span class="n">dnewn_dxi</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="n">free</span> <span class="ow">or</span> <span class="nb">any</span><span class="p">(</span><span class="n">dnewn_dxi</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">free</span><span class="p">)):</span>
            <span class="n">all_zero</span> <span class="o">=</span> <span class="bp">False</span>
            <span class="k">if</span> <span class="n">dnewn_dxi</span> <span class="ow">is</span> <span class="n">S</span><span class="o">.</span><span class="n">NaN</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="k">if</span> <span class="n">xi</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">dnewn_dxi</span><span class="o">.</span><span class="n">free_symbols</span><span class="p">:</span>
                <span class="n">vi</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="n">newn</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span><span class="o">/</span><span class="n">dnewn_dxi</span>
                <span class="k">if</span> <span class="n">dens</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="n">dens</span> <span class="o">=</span> <span class="n">_simple_dens</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">symbols</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">(</span><span class="n">checksol</span><span class="p">(</span><span class="n">di</span><span class="p">,</span> <span class="p">{</span><span class="n">xi</span><span class="p">:</span> <span class="n">vi</span><span class="p">},</span> <span class="n">minimal</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span> <span class="ow">is</span> <span class="bp">True</span>
                          <span class="k">for</span> <span class="n">di</span> <span class="ow">in</span> <span class="n">dens</span><span class="p">):</span>
                    <span class="c1"># simplify any trivial integral</span>
                    <span class="n">irep</span> <span class="o">=</span> <span class="p">[(</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="o">.</span><span class="n">doit</span><span class="p">())</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">vi</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">Integral</span><span class="p">)</span> <span class="k">if</span>
                            <span class="n">i</span><span class="o">.</span><span class="n">function</span><span class="o">.</span><span class="n">is_number</span><span class="p">]</span>
                    <span class="c1"># do a slight bit of simplification</span>
                    <span class="n">vi</span> <span class="o">=</span> <span class="n">expand_mul</span><span class="p">(</span><span class="n">vi</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">irep</span><span class="p">))</span>
                    <span class="k">return</span> <span class="n">xi</span><span class="p">,</span> <span class="n">vi</span>
    <span class="k">if</span> <span class="n">all_zero</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">S</span><span class="o">.</span><span class="n">Zero</span><span class="p">,</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span>
    <span class="k">if</span> <span class="n">n</span><span class="o">.</span><span class="n">is_Symbol</span><span class="p">:</span> <span class="c1"># no solution for this symbol was found</span>
        <span class="k">return</span> <span class="n">S</span><span class="o">.</span><span class="n">Zero</span><span class="p">,</span> <span class="n">S</span><span class="o">.</span><span class="n">Zero</span>
    <span class="k">return</span> <span class="n">n</span><span class="p">,</span> <span class="n">d</span></div>


<span class="k">def</span> <span class="nf">minsolve_linear_system</span><span class="p">(</span><span class="n">system</span><span class="p">,</span> <span class="o">*</span><span class="n">symbols</span><span class="p">,</span> <span class="o">**</span><span class="n">flags</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    Find a particular solution to a linear system.</span>

<span class="sd">    In particular, try to find a solution with the minimal possible number</span>
<span class="sd">    of non-zero variables using a naive algorithm with exponential complexity.</span>
<span class="sd">    If ``quick=True``, a heuristic is used.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">quick</span> <span class="o">=</span> <span class="n">flags</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;quick&#39;</span><span class="p">,</span> <span class="bp">False</span><span class="p">)</span>
    <span class="c1"># Check if there are any non-zero solutions at all</span>
    <span class="n">s0</span> <span class="o">=</span> <span class="n">solve_linear_system</span><span class="p">(</span><span class="n">system</span><span class="p">,</span> <span class="o">*</span><span class="n">symbols</span><span class="p">,</span> <span class="o">**</span><span class="n">flags</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">s0</span> <span class="ow">or</span> <span class="nb">all</span><span class="p">(</span><span class="n">v</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">s0</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span>
        <span class="k">return</span> <span class="n">s0</span>
    <span class="k">if</span> <span class="n">quick</span><span class="p">:</span>
        <span class="c1"># We just solve the system and try to heuristically find a nice</span>
        <span class="c1"># solution.</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">solve_linear_system</span><span class="p">(</span><span class="n">system</span><span class="p">,</span> <span class="o">*</span><span class="n">symbols</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="n">determined</span><span class="p">,</span> <span class="n">solution</span><span class="p">):</span>
            <span class="n">delete</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">solution</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">solution</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">determined</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">solution</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">free_symbols</span><span class="p">:</span>
                    <span class="n">delete</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
                    <span class="n">determined</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">solution</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">delete</span><span class="p">:</span>
                <span class="k">del</span> <span class="n">solution</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
        <span class="n">determined</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">update</span><span class="p">(</span><span class="n">determined</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
        <span class="k">while</span> <span class="n">s</span><span class="p">:</span>
            <span class="c1"># NOTE sort by default_sort_key to get deterministic result</span>
            <span class="n">k</span> <span class="o">=</span> <span class="nb">max</span><span class="p">((</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">s</span><span class="o">.</span><span class="n">values</span><span class="p">()),</span>
                    <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">free_symbols</span><span class="p">),</span> <span class="n">default_sort_key</span><span class="p">(</span><span class="n">x</span><span class="p">)))</span>
            <span class="n">x</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">k</span><span class="o">.</span><span class="n">free_symbols</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">default_sort_key</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">k</span><span class="o">.</span><span class="n">free_symbols</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">determined</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">S</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">val</span> <span class="o">=</span> <span class="n">solve</span><span class="p">(</span><span class="n">k</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">val</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">s</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span>
                    <span class="n">determined</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">S</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">determined</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>
            <span class="n">update</span><span class="p">(</span><span class="n">determined</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">determined</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># We try to select n variables which we want to be non-zero.</span>
        <span class="c1"># All others will be assumed zero. We try to solve the modified system.</span>
        <span class="c1"># If there is a non-trivial solution, just set the free variables to</span>
        <span class="c1"># one. If we do this for increasing n, trying all combinations of</span>
        <span class="c1"># variables, we will find an optimal solution.</span>
        <span class="c1"># We speed up slightly by starting at one less than the number of</span>
        <span class="c1"># variables the quick method manages.</span>
        <span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">combinations</span>
        <span class="kn">from</span> <span class="nn">sympy.utilities.misc</span> <span class="kn">import</span> <span class="n">debug</span>
        <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">symbols</span><span class="p">)</span>
        <span class="n">bestsol</span> <span class="o">=</span> <span class="n">minsolve_linear_system</span><span class="p">(</span><span class="n">system</span><span class="p">,</span> <span class="o">*</span><span class="n">symbols</span><span class="p">,</span> <span class="n">quick</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="n">n0</span> <span class="o">=</span> <span class="nb">len</span><span class="p">([</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">bestsol</span><span class="o">.</span><span class="n">values</span><span class="p">()</span> <span class="k">if</span> <span class="n">x</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n0</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">debug</span><span class="p">(</span><span class="s1">&#39;minsolve: </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">n</span><span class="p">)</span>
            <span class="n">thissol</span> <span class="o">=</span> <span class="bp">None</span>
            <span class="k">for</span> <span class="n">nonzeros</span> <span class="ow">in</span> <span class="n">combinations</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">)),</span> <span class="n">n</span><span class="p">):</span>
                <span class="n">subm</span> <span class="o">=</span> <span class="n">Matrix</span><span class="p">([</span><span class="n">system</span><span class="o">.</span><span class="n">col</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">.</span><span class="n">T</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">nonzeros</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">system</span><span class="o">.</span><span class="n">col</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>
                <span class="n">s</span> <span class="o">=</span> <span class="n">solve_linear_system</span><span class="p">(</span><span class="n">subm</span><span class="p">,</span> <span class="o">*</span><span class="p">[</span><span class="n">symbols</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">nonzeros</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">s</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="n">v</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">s</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span>
                    <span class="n">subs</span> <span class="o">=</span> <span class="p">[(</span><span class="n">symbols</span><span class="p">[</span><span class="n">v</span><span class="p">],</span> <span class="n">S</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">nonzeros</span><span class="p">]</span>
                    <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">s</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                        <span class="n">s</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">subs</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">sym</span> <span class="ow">in</span> <span class="n">symbols</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">sym</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">s</span><span class="p">:</span>
                            <span class="k">if</span> <span class="n">symbols</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">sym</span><span class="p">)</span> <span class="ow">in</span> <span class="n">nonzeros</span><span class="p">:</span>
                                <span class="n">s</span><span class="p">[</span><span class="n">sym</span><span class="p">]</span> <span class="o">=</span> <span class="n">S</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="n">s</span><span class="p">[</span><span class="n">sym</span><span class="p">]</span> <span class="o">=</span> <span class="n">S</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                    <span class="n">thissol</span> <span class="o">=</span> <span class="n">s</span>
                    <span class="k">break</span>
            <span class="k">if</span> <span class="n">thissol</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="n">bestsol</span> <span class="o">=</span> <span class="n">thissol</span>
        <span class="k">return</span> <span class="n">bestsol</span>


<div class="viewcode-block" id="solve_linear_system"><a class="viewcode-back" href="../../../modules/solvers/solvers.html#sympy.solvers.solvers.solve_linear_system">[docs]</a><span class="k">def</span> <span class="nf">solve_linear_system</span><span class="p">(</span><span class="n">system</span><span class="p">,</span> <span class="o">*</span><span class="n">symbols</span><span class="p">,</span> <span class="o">**</span><span class="n">flags</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    Solve system of N linear equations with M variables, which means</span>
<span class="sd">    both under- and overdetermined systems are supported. The possible</span>
<span class="sd">    number of solutions is zero, one or infinite. Respectively, this</span>
<span class="sd">    procedure will return None or a dictionary with solutions. In the</span>
<span class="sd">    case of underdetermined systems, all arbitrary parameters are skipped.</span>
<span class="sd">    This may cause a situation in which an empty dictionary is returned.</span>
<span class="sd">    In that case, all symbols can be assigned arbitrary values.</span>

<span class="sd">    Input to this functions is a Nx(M+1) matrix, which means it has</span>
<span class="sd">    to be in augmented form. If you prefer to enter N equations and M</span>
<span class="sd">    unknowns then use `solve(Neqs, *Msymbols)` instead. Note: a local</span>
<span class="sd">    copy of the matrix is made by this routine so the matrix that is</span>
<span class="sd">    passed will not be modified.</span>

<span class="sd">    The algorithm used here is fraction-free Gaussian elimination,</span>
<span class="sd">    which results, after elimination, in an upper-triangular matrix.</span>
<span class="sd">    Then solutions are found using back-substitution. This approach</span>
<span class="sd">    is more efficient and compact than the Gauss-Jordan method.</span>

<span class="sd">    &gt;&gt;&gt; from sympy import Matrix, solve_linear_system</span>
<span class="sd">    &gt;&gt;&gt; from sympy.abc import x, y</span>

<span class="sd">    Solve the following system::</span>

<span class="sd">           x + 4 y ==  2</span>
<span class="sd">        -2 x +   y == 14</span>

<span class="sd">    &gt;&gt;&gt; system = Matrix(( (1, 4, 2), (-2, 1, 14)))</span>
<span class="sd">    &gt;&gt;&gt; solve_linear_system(system, x, y)</span>
<span class="sd">    {x: -6, y: 2}</span>

<span class="sd">    A degenerate system returns an empty dictionary.</span>

<span class="sd">    &gt;&gt;&gt; system = Matrix(( (0,0,0), (0,0,0) ))</span>
<span class="sd">    &gt;&gt;&gt; solve_linear_system(system, x, y)</span>
<span class="sd">    {}</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">do_simplify</span> <span class="o">=</span> <span class="n">flags</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;simplify&#39;</span><span class="p">,</span> <span class="bp">True</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">system</span><span class="o">.</span><span class="n">rows</span> <span class="o">==</span> <span class="n">system</span><span class="o">.</span><span class="n">cols</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">symbols</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># well behaved n-equations and n-unknowns</span>
            <span class="n">inv</span> <span class="o">=</span> <span class="n">inv_quick</span><span class="p">(</span><span class="n">system</span><span class="p">[:,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">rv</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">symbols</span><span class="p">,</span> <span class="n">inv</span><span class="o">*</span><span class="n">system</span><span class="p">[:,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
            <span class="k">if</span> <span class="n">do_simplify</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">rv</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="n">rv</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">simplify</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">is_zero</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">rv</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span>
                <span class="c1"># non-trivial solution</span>
                <span class="k">return</span> <span class="n">rv</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">pass</span>

    <span class="n">matrix</span> <span class="o">=</span> <span class="n">system</span><span class="p">[:,</span> <span class="p">:]</span>
    <span class="n">syms</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">symbols</span><span class="p">)</span>

    <span class="n">i</span><span class="p">,</span> <span class="n">m</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">matrix</span><span class="o">.</span><span class="n">cols</span> <span class="o">-</span> <span class="mi">1</span>  <span class="c1"># don&#39;t count augmentation</span>

    <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">matrix</span><span class="o">.</span><span class="n">rows</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">m</span><span class="p">:</span>
            <span class="c1"># an overdetermined system</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">matrix</span><span class="p">[</span><span class="n">i</span><span class="p">:,</span> <span class="n">m</span><span class="p">]):</span>
                <span class="k">return</span> <span class="bp">None</span>   <span class="c1"># no solutions</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># remove trailing rows</span>
                <span class="n">matrix</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">[:</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span>
                <span class="k">break</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">matrix</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">]:</span>
            <span class="c1"># there is no pivot in current column</span>
            <span class="c1"># so try to find one in other columns</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">m</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">matrix</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">k</span><span class="p">]:</span>
                    <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">matrix</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">m</span><span class="p">]:</span>
                    <span class="c1"># We need to know if this is always zero or not. We</span>
                    <span class="c1"># assume that if there are free symbols that it is not</span>
                    <span class="c1"># identically zero (or that there is more than one way</span>
                    <span class="c1"># to make this zero). Otherwise, if there are none, this</span>
                    <span class="c1"># is a constant and we assume that it does not simplify</span>
                    <span class="c1"># to zero XXX are there better (fast) ways to test this?</span>
                    <span class="c1"># The .equals(0) method could be used but that can be</span>
                    <span class="c1"># slow; numerical testing is prone to errors of scaling.</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">matrix</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">m</span><span class="p">]</span><span class="o">.</span><span class="n">free_symbols</span><span class="p">:</span>
                        <span class="k">return</span> <span class="bp">None</span>  <span class="c1"># no solution</span>

                    <span class="c1"># A row of zeros with a non-zero rhs can only be accepted</span>
                    <span class="c1"># if there is another equivalent row. Any such rows will</span>
                    <span class="c1"># be deleted.</span>
                    <span class="n">nrows</span> <span class="o">=</span> <span class="n">matrix</span><span class="o">.</span><span class="n">rows</span>
                    <span class="n">rowi</span> <span class="o">=</span> <span class="n">matrix</span><span class="o">.</span><span class="n">row</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                    <span class="n">ip</span> <span class="o">=</span> <span class="bp">None</span>
                    <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
                    <span class="k">while</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">matrix</span><span class="o">.</span><span class="n">rows</span><span class="p">:</span>
                        <span class="c1"># do we need to see if the rhs of j</span>
                        <span class="c1"># is a constant multiple of i&#39;s rhs?</span>
                        <span class="n">rowj</span> <span class="o">=</span> <span class="n">matrix</span><span class="o">.</span><span class="n">row</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">rowj</span> <span class="o">==</span> <span class="n">rowi</span><span class="p">:</span>
                            <span class="n">matrix</span><span class="o">.</span><span class="n">row_del</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
                        <span class="k">elif</span> <span class="n">rowj</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">rowi</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                            <span class="k">if</span> <span class="n">ip</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                                <span class="n">_</span><span class="p">,</span> <span class="n">ip</span> <span class="o">=</span> <span class="n">rowi</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">as_content_primitive</span><span class="p">()</span>
                            <span class="n">_</span><span class="p">,</span> <span class="n">jp</span> <span class="o">=</span> <span class="n">rowj</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">as_content_primitive</span><span class="p">()</span>
                            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">simplify</span><span class="p">(</span><span class="n">jp</span> <span class="o">-</span> <span class="n">ip</span><span class="p">)</span> <span class="ow">or</span> <span class="n">simplify</span><span class="p">(</span><span class="n">jp</span> <span class="o">+</span> <span class="n">ip</span><span class="p">)):</span>
                                <span class="n">matrix</span><span class="o">.</span><span class="n">row_del</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>

                        <span class="n">j</span> <span class="o">+=</span> <span class="mi">1</span>

                    <span class="k">if</span> <span class="n">nrows</span> <span class="o">==</span> <span class="n">matrix</span><span class="o">.</span><span class="n">rows</span><span class="p">:</span>
                        <span class="c1"># no solution</span>
                        <span class="k">return</span> <span class="bp">None</span>
                <span class="c1"># zero row or was a linear combination of</span>
                <span class="c1"># other rows or was a row with a symbolic</span>
                <span class="c1"># expression that matched other rows, e.g. [0, 0, x - y]</span>
                <span class="c1"># so now we can safely skip it</span>
                <span class="n">matrix</span><span class="o">.</span><span class="n">row_del</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">matrix</span><span class="p">:</span>
                    <span class="c1"># every choice of variable values is a solution</span>
                    <span class="c1"># so we return an empty dict instead of None</span>
                    <span class="k">return</span> <span class="nb">dict</span><span class="p">()</span>
                <span class="k">continue</span>

            <span class="c1"># we want to change the order of colums so</span>
            <span class="c1"># the order of variables must also change</span>
            <span class="n">syms</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">syms</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">syms</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">syms</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">matrix</span><span class="o">.</span><span class="n">col_swap</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>

        <span class="n">pivot_inv</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span><span class="o">/</span><span class="n">matrix</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span>

        <span class="c1"># divide all elements in the current row by the pivot</span>
        <span class="n">matrix</span><span class="o">.</span><span class="n">row_op</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">_</span><span class="p">:</span> <span class="n">x</span> <span class="o">*</span> <span class="n">pivot_inv</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">matrix</span><span class="o">.</span><span class="n">rows</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">matrix</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">i</span><span class="p">]:</span>
                <span class="n">coeff</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span>

                <span class="c1"># subtract from the current row the row containing</span>
                <span class="c1"># pivot and multiplied by extracted coefficient</span>
                <span class="n">matrix</span><span class="o">.</span><span class="n">row_op</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">j</span><span class="p">:</span> <span class="n">simplify</span><span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">matrix</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span><span class="o">*</span><span class="n">coeff</span><span class="p">))</span>

        <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="c1"># if there weren&#39;t any problems, augmented matrix is now</span>
    <span class="c1"># in row-echelon form so we can check how many solutions</span>
    <span class="c1"># there are and extract them using back substitution</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">syms</span><span class="p">)</span> <span class="o">==</span> <span class="n">matrix</span><span class="o">.</span><span class="n">rows</span><span class="p">:</span>
        <span class="c1"># this system is Cramer equivalent so there is</span>
        <span class="c1"># exactly one solution to this system of equations</span>
        <span class="n">k</span><span class="p">,</span> <span class="n">solutions</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="p">{}</span>

        <span class="k">while</span> <span class="n">k</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">content</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">m</span><span class="p">]</span>

            <span class="c1"># run back-substitution for variables</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">m</span><span class="p">):</span>
                <span class="n">content</span> <span class="o">-=</span> <span class="n">matrix</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span><span class="o">*</span><span class="n">solutions</span><span class="p">[</span><span class="n">syms</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span>

            <span class="k">if</span> <span class="n">do_simplify</span><span class="p">:</span>
                <span class="n">solutions</span><span class="p">[</span><span class="n">syms</span><span class="p">[</span><span class="n">k</span><span class="p">]]</span> <span class="o">=</span> <span class="n">simplify</span><span class="p">(</span><span class="n">content</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">solutions</span><span class="p">[</span><span class="n">syms</span><span class="p">[</span><span class="n">k</span><span class="p">]]</span> <span class="o">=</span> <span class="n">content</span>

            <span class="n">k</span> <span class="o">-=</span> <span class="mi">1</span>

        <span class="k">return</span> <span class="n">solutions</span>
    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">syms</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">matrix</span><span class="o">.</span><span class="n">rows</span><span class="p">:</span>
        <span class="c1"># this system will have infinite number of solutions</span>
        <span class="c1"># dependent on exactly len(syms) - i parameters</span>
        <span class="n">k</span><span class="p">,</span> <span class="n">solutions</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="p">{}</span>

        <span class="k">while</span> <span class="n">k</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">content</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">m</span><span class="p">]</span>

            <span class="c1"># run back-substitution for variables</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
                <span class="n">content</span> <span class="o">-=</span> <span class="n">matrix</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span><span class="o">*</span><span class="n">solutions</span><span class="p">[</span><span class="n">syms</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span>

            <span class="c1"># run back-substitution for parameters</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">m</span><span class="p">):</span>
                <span class="n">content</span> <span class="o">-=</span> <span class="n">matrix</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span><span class="o">*</span><span class="n">syms</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">do_simplify</span><span class="p">:</span>
                <span class="n">solutions</span><span class="p">[</span><span class="n">syms</span><span class="p">[</span><span class="n">k</span><span class="p">]]</span> <span class="o">=</span> <span class="n">simplify</span><span class="p">(</span><span class="n">content</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">solutions</span><span class="p">[</span><span class="n">syms</span><span class="p">[</span><span class="n">k</span><span class="p">]]</span> <span class="o">=</span> <span class="n">content</span>

            <span class="n">k</span> <span class="o">-=</span> <span class="mi">1</span>

        <span class="k">return</span> <span class="n">solutions</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[]</span>   <span class="c1"># no solutions</span></div>


<div class="viewcode-block" id="solve_undetermined_coeffs"><a class="viewcode-back" href="../../../modules/solvers/solvers.html#sympy.solvers.solvers.solve_undetermined_coeffs">[docs]</a><span class="k">def</span> <span class="nf">solve_undetermined_coeffs</span><span class="p">(</span><span class="n">equ</span><span class="p">,</span> <span class="n">coeffs</span><span class="p">,</span> <span class="n">sym</span><span class="p">,</span> <span class="o">**</span><span class="n">flags</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Solve equation of a type p(x; a_1, ..., a_k) == q(x) where both</span>
<span class="sd">       p, q are univariate polynomials and f depends on k parameters.</span>
<span class="sd">       The result of this functions is a dictionary with symbolic</span>
<span class="sd">       values of those parameters with respect to coefficients in q.</span>

<span class="sd">       This functions accepts both Equations class instances and ordinary</span>
<span class="sd">       SymPy expressions. Specification of parameters and variable is</span>
<span class="sd">       obligatory for efficiency and simplicity reason.</span>

<span class="sd">       &gt;&gt;&gt; from sympy import Eq</span>
<span class="sd">       &gt;&gt;&gt; from sympy.abc import a, b, c, x</span>
<span class="sd">       &gt;&gt;&gt; from sympy.solvers import solve_undetermined_coeffs</span>

<span class="sd">       &gt;&gt;&gt; solve_undetermined_coeffs(Eq(2*a*x + a+b, x), [a, b], x)</span>
<span class="sd">       {a: 1/2, b: -1/2}</span>

<span class="sd">       &gt;&gt;&gt; solve_undetermined_coeffs(Eq(a*c*x + a+b, x), [a, b], x)</span>
<span class="sd">       {a: 1/c, b: -1/c}</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">equ</span><span class="p">,</span> <span class="n">Equality</span><span class="p">):</span>
        <span class="c1"># got equation, so move all the</span>
        <span class="c1"># terms to the left hand side</span>
        <span class="n">equ</span> <span class="o">=</span> <span class="n">equ</span><span class="o">.</span><span class="n">lhs</span> <span class="o">-</span> <span class="n">equ</span><span class="o">.</span><span class="n">rhs</span>

    <span class="n">equ</span> <span class="o">=</span> <span class="n">cancel</span><span class="p">(</span><span class="n">equ</span><span class="p">)</span><span class="o">.</span><span class="n">as_numer_denom</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>

    <span class="n">system</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">collect</span><span class="p">(</span><span class="n">equ</span><span class="o">.</span><span class="n">expand</span><span class="p">(),</span> <span class="n">sym</span><span class="p">,</span> <span class="n">evaluate</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">(</span><span class="n">equ</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">sym</span><span class="p">)</span> <span class="k">for</span> <span class="n">equ</span> <span class="ow">in</span> <span class="n">system</span><span class="p">):</span>
        <span class="c1"># consecutive powers in the input expressions have</span>
        <span class="c1"># been successfully collected, so solve remaining</span>
        <span class="c1"># system using Gaussian elimination algorithm</span>
        <span class="k">return</span> <span class="n">solve</span><span class="p">(</span><span class="n">system</span><span class="p">,</span> <span class="o">*</span><span class="n">coeffs</span><span class="p">,</span> <span class="o">**</span><span class="n">flags</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">None</span>  <span class="c1"># no solutions</span></div>


<div class="viewcode-block" id="solve_linear_system_LU"><a class="viewcode-back" href="../../../modules/solvers/solvers.html#sympy.solvers.solvers.solve_linear_system_LU">[docs]</a><span class="k">def</span> <span class="nf">solve_linear_system_LU</span><span class="p">(</span><span class="n">matrix</span><span class="p">,</span> <span class="n">syms</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Solves the augmented matrix system using LUsolve and returns a dictionary</span>
<span class="sd">    in which solutions are keyed to the symbols of syms *as ordered*.</span>

<span class="sd">    The matrix must be invertible.</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy import Matrix</span>
<span class="sd">    &gt;&gt;&gt; from sympy.abc import x, y, z</span>
<span class="sd">    &gt;&gt;&gt; from sympy.solvers.solvers import solve_linear_system_LU</span>

<span class="sd">    &gt;&gt;&gt; solve_linear_system_LU(Matrix([</span>
<span class="sd">    ... [1, 2, 0, 1],</span>
<span class="sd">    ... [3, 2, 2, 1],</span>
<span class="sd">    ... [2, 0, 0, 1]]), [x, y, z])</span>
<span class="sd">    {x: 1/2, y: 1/4, z: -1/2}</span>

<span class="sd">    See Also</span>
<span class="sd">    ========</span>

<span class="sd">    sympy.matrices.LUsolve</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">matrix</span><span class="o">.</span><span class="n">rows</span> <span class="o">!=</span> <span class="n">matrix</span><span class="o">.</span><span class="n">cols</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Rows should be equal to columns - 1&quot;</span><span class="p">)</span>
    <span class="n">A</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">[:</span><span class="n">matrix</span><span class="o">.</span><span class="n">rows</span><span class="p">,</span> <span class="p">:</span><span class="n">matrix</span><span class="o">.</span><span class="n">rows</span><span class="p">]</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">[:,</span> <span class="n">matrix</span><span class="o">.</span><span class="n">cols</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:]</span>
    <span class="n">soln</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">LUsolve</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
    <span class="n">solutions</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">soln</span><span class="o">.</span><span class="n">rows</span><span class="p">):</span>
        <span class="n">solutions</span><span class="p">[</span><span class="n">syms</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="n">soln</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">solutions</span></div>


<span class="k">def</span> <span class="nf">det_perm</span><span class="p">(</span><span class="n">M</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return the det(``M``) by using permutations to select factors.</span>
<span class="sd">    For size larger than 8 the number of permutations becomes prohibitively</span>
<span class="sd">    large, or if there are no symbols in the matrix, it is better to use the</span>
<span class="sd">    standard determinant routines, e.g. `M.det()`.</span>

<span class="sd">    See Also</span>
<span class="sd">    ========</span>
<span class="sd">    det_minor</span>
<span class="sd">    det_quick</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">args</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">s</span> <span class="o">=</span> <span class="bp">True</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">rows</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="nb">list</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">_mat</span>
    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
        <span class="nb">list</span> <span class="o">=</span> <span class="n">flatten</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>
    <span class="k">for</span> <span class="n">perm</span> <span class="ow">in</span> <span class="n">generate_bell</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="n">fac</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">perm</span><span class="p">:</span>
            <span class="n">fac</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">list</span><span class="p">[</span><span class="n">idx</span> <span class="o">+</span> <span class="n">j</span><span class="p">])</span>
            <span class="n">idx</span> <span class="o">+=</span> <span class="n">n</span>
        <span class="n">term</span> <span class="o">=</span> <span class="n">Mul</span><span class="p">(</span><span class="o">*</span><span class="n">fac</span><span class="p">)</span> <span class="c1"># disaster with unevaluated Mul -- takes forever for n=7</span>
        <span class="n">args</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">term</span> <span class="k">if</span> <span class="n">s</span> <span class="k">else</span> <span class="o">-</span><span class="n">term</span><span class="p">)</span>
        <span class="n">s</span> <span class="o">=</span> <span class="ow">not</span> <span class="n">s</span>
    <span class="k">return</span> <span class="n">Add</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">det_minor</span><span class="p">(</span><span class="n">M</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return the ``det(M)`` computed from minors without</span>
<span class="sd">    introducing new nesting in products.</span>

<span class="sd">    See Also</span>
<span class="sd">    ========</span>
<span class="sd">    det_perm</span>
<span class="sd">    det_quick</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">rows</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">M</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">M</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">M</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">M</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)[</span><span class="n">i</span> <span class="o">%</span> <span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">Add</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">M</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">d</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span>
            <span class="n">Add</span><span class="o">.</span><span class="n">make_args</span><span class="p">(</span><span class="n">det_minor</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">minorMatrix</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">)))])</span>
            <span class="k">if</span> <span class="n">M</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="k">else</span> <span class="n">S</span><span class="o">.</span><span class="n">Zero</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)])</span>


<span class="k">def</span> <span class="nf">det_quick</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return ``det(M)`` assuming that either</span>
<span class="sd">    there are lots of zeros or the size of the matrix</span>
<span class="sd">    is small. If this assumption is not met, then the normal</span>
<span class="sd">    Matrix.det function will be used with method = ``method``.</span>

<span class="sd">    See Also</span>
<span class="sd">    ========</span>
<span class="sd">    det_minor</span>
<span class="sd">    det_perm</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">Symbol</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">M</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">M</span><span class="o">.</span><span class="n">rows</span> <span class="o">&lt;</span> <span class="mi">8</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">Symbol</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">M</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">det_perm</span><span class="p">(</span><span class="n">M</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">det_minor</span><span class="p">(</span><span class="n">M</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">M</span><span class="o">.</span><span class="n">det</span><span class="p">(</span><span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">)</span> <span class="k">if</span> <span class="n">method</span> <span class="k">else</span> <span class="n">M</span><span class="o">.</span><span class="n">det</span><span class="p">()</span>


<span class="k">def</span> <span class="nf">inv_quick</span><span class="p">(</span><span class="n">M</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return the inverse of ``M``, assuming that either</span>
<span class="sd">    there are lots of zeros or the size of the matrix</span>
<span class="sd">    is small.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">sympy.matrices</span> <span class="kn">import</span> <span class="n">zeros</span>
    <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">Symbol</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">M</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">Symbol</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">M</span><span class="p">):</span>
            <span class="n">det</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">_</span><span class="p">:</span> <span class="n">det_perm</span><span class="p">(</span><span class="n">_</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">det</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">_</span><span class="p">:</span> <span class="n">det_minor</span><span class="p">(</span><span class="n">_</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">M</span><span class="o">.</span><span class="n">inv</span><span class="p">()</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">rows</span>
    <span class="n">d</span> <span class="o">=</span> <span class="n">det</span><span class="p">(</span><span class="n">M</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">d</span> <span class="ow">is</span> <span class="n">S</span><span class="o">.</span><span class="n">Zero</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Matrix det == 0; not invertible.&quot;</span><span class="p">)</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
    <span class="n">s1</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">s1</span> <span class="o">=</span> <span class="o">-</span><span class="n">s1</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="n">di</span> <span class="o">=</span> <span class="n">det</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">minorMatrix</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">))</span>
            <span class="n">ret</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">s</span><span class="o">*</span><span class="n">di</span><span class="o">/</span><span class="n">d</span>
            <span class="n">s</span> <span class="o">=</span> <span class="o">-</span><span class="n">s</span>
    <span class="k">return</span> <span class="n">ret</span>


<span class="c1"># these are functions that have multiple inverse values per period</span>
<span class="n">multi_inverses</span> <span class="o">=</span> <span class="p">{</span>
    <span class="n">sin</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">(</span><span class="n">asin</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">S</span><span class="o">.</span><span class="n">Pi</span> <span class="o">-</span> <span class="n">asin</span><span class="p">(</span><span class="n">x</span><span class="p">)),</span>
    <span class="n">cos</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">(</span><span class="n">acos</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="mi">2</span><span class="o">*</span><span class="n">S</span><span class="o">.</span><span class="n">Pi</span> <span class="o">-</span> <span class="n">acos</span><span class="p">(</span><span class="n">x</span><span class="p">)),</span>
<span class="p">}</span>


<span class="k">def</span> <span class="nf">_tsolve</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">sym</span><span class="p">,</span> <span class="o">**</span><span class="n">flags</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Helper for _solve that solves a transcendental equation with respect</span>
<span class="sd">    to the given symbol. Various equations containing powers and logarithms,</span>
<span class="sd">    can be solved.</span>

<span class="sd">    There is currently no guarantee that all solutions will be returned or</span>
<span class="sd">    that a real solution will be favored over a complex one.</span>

<span class="sd">    Either a list of potential solutions will be returned or None will be</span>
<span class="sd">    returned (in the case that no method was known to get a solution</span>
<span class="sd">    for the equation). All other errors (like the inability to cast an</span>
<span class="sd">    expression as a Poly) are unhandled.</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy import log</span>
<span class="sd">    &gt;&gt;&gt; from sympy.solvers.solvers import _tsolve as tsolve</span>
<span class="sd">    &gt;&gt;&gt; from sympy.abc import x</span>

<span class="sd">    &gt;&gt;&gt; tsolve(3**(2*x + 5) - 4, x)</span>
<span class="sd">    [-5/2 + log(2)/log(3), (-5*log(3)/2 + log(2) + I*pi)/log(3)]</span>

<span class="sd">    &gt;&gt;&gt; tsolve(log(x) + 2*x, x)</span>
<span class="sd">    [LambertW(2)/2]</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="s1">&#39;tsolve_saw&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">flags</span><span class="p">:</span>
        <span class="n">flags</span><span class="p">[</span><span class="s1">&#39;tsolve_saw&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="n">eq</span> <span class="ow">in</span> <span class="n">flags</span><span class="p">[</span><span class="s1">&#39;tsolve_saw&#39;</span><span class="p">]:</span>
        <span class="k">return</span> <span class="bp">None</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">flags</span><span class="p">[</span><span class="s1">&#39;tsolve_saw&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">eq</span><span class="p">)</span>

    <span class="n">rhs</span><span class="p">,</span> <span class="n">lhs</span> <span class="o">=</span> <span class="n">_invert</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">sym</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">lhs</span> <span class="o">==</span> <span class="n">sym</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">rhs</span><span class="p">]</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">lhs</span><span class="o">.</span><span class="n">is_Add</span><span class="p">:</span>
            <span class="c1"># it&#39;s time to try factoring; powdenest is used</span>
            <span class="c1"># to try get powers in standard form for better factoring</span>
            <span class="n">f</span> <span class="o">=</span> <span class="n">factor</span><span class="p">(</span><span class="n">powdenest</span><span class="p">(</span><span class="n">lhs</span> <span class="o">-</span> <span class="n">rhs</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">f</span><span class="o">.</span><span class="n">is_Mul</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">_solve</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">sym</span><span class="p">,</span> <span class="o">**</span><span class="n">flags</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">rhs</span><span class="p">:</span>
                <span class="n">f</span> <span class="o">=</span> <span class="n">logcombine</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">force</span><span class="o">=</span><span class="n">flags</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;force&#39;</span><span class="p">,</span> <span class="bp">True</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">f</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">log</span><span class="p">)</span> <span class="o">!=</span> <span class="n">lhs</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">log</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">f</span><span class="o">.</span><span class="n">func</span> <span class="ow">is</span> <span class="n">log</span><span class="p">:</span>
                        <span class="k">return</span> <span class="n">_solve</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">exp</span><span class="p">(</span><span class="n">rhs</span><span class="p">),</span> <span class="n">sym</span><span class="p">,</span> <span class="o">**</span><span class="n">flags</span><span class="p">)</span>
                    <span class="k">return</span> <span class="n">_tsolve</span><span class="p">(</span><span class="n">f</span> <span class="o">-</span> <span class="n">rhs</span><span class="p">,</span> <span class="n">sym</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">lhs</span><span class="o">.</span><span class="n">is_Pow</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">lhs</span><span class="o">.</span><span class="n">exp</span><span class="o">.</span><span class="n">is_Integer</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">lhs</span> <span class="o">-</span> <span class="n">rhs</span> <span class="o">!=</span> <span class="n">eq</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">_solve</span><span class="p">(</span><span class="n">lhs</span> <span class="o">-</span> <span class="n">rhs</span><span class="p">,</span> <span class="n">sym</span><span class="p">,</span> <span class="o">**</span><span class="n">flags</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">sym</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">lhs</span><span class="o">.</span><span class="n">exp</span><span class="o">.</span><span class="n">free_symbols</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">_solve</span><span class="p">(</span><span class="n">lhs</span><span class="o">.</span><span class="n">base</span> <span class="o">-</span> <span class="n">rhs</span><span class="o">**</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">lhs</span><span class="o">.</span><span class="n">exp</span><span class="p">),</span> <span class="n">sym</span><span class="p">,</span> <span class="o">**</span><span class="n">flags</span><span class="p">)</span>
            <span class="k">elif</span> <span class="ow">not</span> <span class="n">rhs</span> <span class="ow">and</span> <span class="n">sym</span> <span class="ow">in</span> <span class="n">lhs</span><span class="o">.</span><span class="n">exp</span><span class="o">.</span><span class="n">free_symbols</span><span class="p">:</span>
                <span class="c1"># f(x)**g(x) only has solutions where f(x) == 0 and g(x) != 0 at</span>
                <span class="c1"># the same place</span>
                <span class="n">sol_base</span> <span class="o">=</span> <span class="n">_solve</span><span class="p">(</span><span class="n">lhs</span><span class="o">.</span><span class="n">base</span><span class="p">,</span> <span class="n">sym</span><span class="p">,</span> <span class="o">**</span><span class="n">flags</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">sol_base</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">sol_base</span>  <span class="c1"># no solutions to remove so return now</span>
                <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">ordered</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">sol_base</span><span class="p">)</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span>
                    <span class="n">_solve</span><span class="p">(</span><span class="n">lhs</span><span class="o">.</span><span class="n">exp</span><span class="p">,</span> <span class="n">sym</span><span class="p">,</span> <span class="o">**</span><span class="n">flags</span><span class="p">))))</span>
            <span class="k">elif</span> <span class="p">(</span><span class="n">rhs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">S</span><span class="o">.</span><span class="n">Zero</span> <span class="ow">and</span>
                        <span class="n">lhs</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">is_positive</span> <span class="ow">and</span>
                        <span class="n">lhs</span><span class="o">.</span><span class="n">exp</span><span class="o">.</span><span class="n">is_real</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">_solve</span><span class="p">(</span><span class="n">lhs</span><span class="o">.</span><span class="n">exp</span><span class="o">*</span><span class="n">log</span><span class="p">(</span><span class="n">lhs</span><span class="o">.</span><span class="n">base</span><span class="p">)</span> <span class="o">-</span> <span class="n">log</span><span class="p">(</span><span class="n">rhs</span><span class="p">),</span> <span class="n">sym</span><span class="p">,</span> <span class="o">**</span><span class="n">flags</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">lhs</span><span class="o">.</span><span class="n">base</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">rhs</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">_solve</span><span class="p">(</span><span class="n">lhs</span><span class="o">.</span><span class="n">exp</span><span class="p">,</span> <span class="n">sym</span><span class="p">,</span> <span class="o">**</span><span class="n">flags</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">lhs</span><span class="o">.</span><span class="n">is_Mul</span> <span class="ow">and</span> <span class="n">rhs</span><span class="o">.</span><span class="n">is_positive</span><span class="p">:</span>
            <span class="n">llhs</span> <span class="o">=</span> <span class="n">expand_log</span><span class="p">(</span><span class="n">log</span><span class="p">(</span><span class="n">lhs</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">llhs</span><span class="o">.</span><span class="n">is_Add</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">_solve</span><span class="p">(</span><span class="n">llhs</span> <span class="o">-</span> <span class="n">log</span><span class="p">(</span><span class="n">rhs</span><span class="p">),</span> <span class="n">sym</span><span class="p">,</span> <span class="o">**</span><span class="n">flags</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">lhs</span><span class="o">.</span><span class="n">is_Function</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">lhs</span><span class="o">.</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">lhs</span><span class="o">.</span><span class="n">func</span> <span class="ow">in</span> <span class="n">multi_inverses</span><span class="p">:</span>
            <span class="c1"># sin(x) = 1/3 -&gt; x - asin(1/3) &amp; x - (pi - asin(1/3))</span>
            <span class="n">soln</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">multi_inverses</span><span class="p">[</span><span class="n">lhs</span><span class="o">.</span><span class="n">func</span><span class="p">](</span><span class="n">rhs</span><span class="p">):</span>
                <span class="n">soln</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">_solve</span><span class="p">(</span><span class="n">lhs</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">i</span><span class="p">,</span> <span class="n">sym</span><span class="p">,</span> <span class="o">**</span><span class="n">flags</span><span class="p">))</span>
            <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">ordered</span><span class="p">(</span><span class="n">soln</span><span class="p">))</span>

        <span class="n">rewrite</span> <span class="o">=</span> <span class="n">lhs</span><span class="o">.</span><span class="n">rewrite</span><span class="p">(</span><span class="n">exp</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">rewrite</span> <span class="o">!=</span> <span class="n">lhs</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">_solve</span><span class="p">(</span><span class="n">rewrite</span> <span class="o">-</span> <span class="n">rhs</span><span class="p">,</span> <span class="n">sym</span><span class="p">,</span> <span class="o">**</span><span class="n">flags</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">NotImplementedError</span><span class="p">:</span>
        <span class="k">pass</span>

    <span class="c1"># maybe it is a lambert pattern</span>
    <span class="k">if</span> <span class="n">flags</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;bivariate&#39;</span><span class="p">,</span> <span class="bp">True</span><span class="p">):</span>
        <span class="c1"># lambert forms may need some help being recognized, e.g. changing</span>
        <span class="c1"># 2**(3*x) + x**3*log(2)**3 + 3*x**2*log(2)**2 + 3*x*log(2) + 1</span>
        <span class="c1"># to 2**(3*x) + (x*log(2) + 1)**3</span>
        <span class="n">g</span> <span class="o">=</span> <span class="n">_filtered_gens</span><span class="p">(</span><span class="n">eq</span><span class="o">.</span><span class="n">as_poly</span><span class="p">(),</span> <span class="n">sym</span><span class="p">)</span>
        <span class="n">up_or_log</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">gi</span> <span class="ow">in</span> <span class="n">g</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">gi</span><span class="o">.</span><span class="n">func</span> <span class="ow">is</span> <span class="n">exp</span> <span class="ow">or</span> <span class="n">gi</span><span class="o">.</span><span class="n">func</span> <span class="ow">is</span> <span class="n">log</span><span class="p">:</span>
                <span class="n">up_or_log</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">gi</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">gi</span><span class="o">.</span><span class="n">is_Pow</span><span class="p">:</span>
                <span class="n">gisimp</span> <span class="o">=</span> <span class="n">powdenest</span><span class="p">(</span><span class="n">expand_power_exp</span><span class="p">(</span><span class="n">gi</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">gisimp</span><span class="o">.</span><span class="n">is_Pow</span> <span class="ow">and</span> <span class="n">sym</span> <span class="ow">in</span> <span class="n">gisimp</span><span class="o">.</span><span class="n">exp</span><span class="o">.</span><span class="n">free_symbols</span><span class="p">:</span>
                    <span class="n">up_or_log</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">gi</span><span class="p">)</span>
        <span class="n">down</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">up_or_log</span><span class="p">)</span>
        <span class="n">eq_down</span> <span class="o">=</span> <span class="n">expand_log</span><span class="p">(</span><span class="n">expand_power_exp</span><span class="p">(</span><span class="n">eq</span><span class="p">))</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span>
            <span class="nb">dict</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">up_or_log</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">up_or_log</span><span class="p">)))))</span>
        <span class="n">eq</span> <span class="o">=</span> <span class="n">expand_power_exp</span><span class="p">(</span><span class="n">factor</span><span class="p">(</span><span class="n">eq_down</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">eq</span> <span class="o">-</span> <span class="n">eq_down</span><span class="p">))</span>
        <span class="n">rhs</span><span class="p">,</span> <span class="n">lhs</span> <span class="o">=</span> <span class="n">_invert</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">sym</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">lhs</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">sym</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">poly</span> <span class="o">=</span> <span class="n">lhs</span><span class="o">.</span><span class="n">as_poly</span><span class="p">()</span>
                <span class="n">g</span> <span class="o">=</span> <span class="n">_filtered_gens</span><span class="p">(</span><span class="n">poly</span><span class="p">,</span> <span class="n">sym</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">_solve_lambert</span><span class="p">(</span><span class="n">lhs</span> <span class="o">-</span> <span class="n">rhs</span><span class="p">,</span> <span class="n">sym</span><span class="p">,</span> <span class="n">g</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">NotImplementedError</span><span class="p">:</span>
                <span class="c1"># maybe it&#39;s a convoluted function</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">g</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">gpu</span> <span class="o">=</span> <span class="n">bivariate_type</span><span class="p">(</span><span class="n">lhs</span> <span class="o">-</span> <span class="n">rhs</span><span class="p">,</span> <span class="o">*</span><span class="n">g</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">gpu</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                            <span class="k">raise</span> <span class="ne">NotImplementedError</span>
                        <span class="n">g</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">u</span> <span class="o">=</span> <span class="n">gpu</span>
                        <span class="n">flags</span><span class="p">[</span><span class="s1">&#39;bivariate&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">False</span>
                        <span class="n">inversion</span> <span class="o">=</span> <span class="n">_tsolve</span><span class="p">(</span><span class="n">g</span> <span class="o">-</span> <span class="n">u</span><span class="p">,</span> <span class="n">sym</span><span class="p">,</span> <span class="o">**</span><span class="n">flags</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">inversion</span><span class="p">:</span>
                            <span class="n">sol</span> <span class="o">=</span> <span class="n">_solve</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="o">**</span><span class="n">flags</span><span class="p">)</span>
                            <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">ordered</span><span class="p">(</span><span class="nb">set</span><span class="p">([</span><span class="n">i</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
                                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">inversion</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">sol</span><span class="p">])))</span>
                    <span class="k">except</span> <span class="ne">NotImplementedError</span><span class="p">:</span>
                        <span class="k">pass</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">pass</span>

    <span class="k">if</span> <span class="n">flags</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;force&#39;</span><span class="p">,</span> <span class="bp">True</span><span class="p">):</span>
        <span class="n">flags</span><span class="p">[</span><span class="s1">&#39;force&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="n">pos</span><span class="p">,</span> <span class="n">reps</span> <span class="o">=</span> <span class="n">posify</span><span class="p">(</span><span class="n">lhs</span> <span class="o">-</span> <span class="n">rhs</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">u</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">reps</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">s</span> <span class="o">==</span> <span class="n">sym</span><span class="p">:</span>
                <span class="k">break</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">u</span> <span class="o">=</span> <span class="n">sym</span>
        <span class="k">if</span> <span class="n">pos</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">u</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">soln</span> <span class="o">=</span> <span class="n">_solve</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="o">**</span><span class="n">flags</span><span class="p">)</span>
                <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">ordered</span><span class="p">([</span><span class="n">s</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">reps</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">soln</span><span class="p">]))</span>
            <span class="k">except</span> <span class="ne">NotImplementedError</span><span class="p">:</span>
                <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">pass</span>  <span class="c1"># here for coverage</span>

    <span class="k">return</span>  <span class="c1"># here for coverage</span>


<span class="c1"># TODO: option for calculating J numerically</span>


<div class="viewcode-block" id="nsolve"><a class="viewcode-back" href="../../../modules/solvers/solvers.html#sympy.solvers.solvers.nsolve">[docs]</a><span class="k">def</span> <span class="nf">nsolve</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    Solve a nonlinear equation system numerically::</span>

<span class="sd">        nsolve(f, [args,] x0, modules=[&#39;mpmath&#39;], **kwargs)</span>

<span class="sd">    f is a vector function of symbolic expressions representing the system.</span>
<span class="sd">    args are the variables. If there is only one variable, this argument can</span>
<span class="sd">    be omitted.</span>
<span class="sd">    x0 is a starting vector close to a solution.</span>

<span class="sd">    Use the modules keyword to specify which modules should be used to</span>
<span class="sd">    evaluate the function and the Jacobian matrix. Make sure to use a module</span>
<span class="sd">    that supports matrices. For more information on the syntax, please see the</span>
<span class="sd">    docstring of lambdify.</span>

<span class="sd">    Overdetermined systems are supported.</span>

<span class="sd">    &gt;&gt;&gt; from sympy import Symbol, nsolve</span>
<span class="sd">    &gt;&gt;&gt; import sympy</span>
<span class="sd">    &gt;&gt;&gt; import mpmath</span>
<span class="sd">    &gt;&gt;&gt; mpmath.mp.dps = 15</span>
<span class="sd">    &gt;&gt;&gt; x1 = Symbol(&#39;x1&#39;)</span>
<span class="sd">    &gt;&gt;&gt; x2 = Symbol(&#39;x2&#39;)</span>
<span class="sd">    &gt;&gt;&gt; f1 = 3 * x1**2 - 2 * x2**2 - 1</span>
<span class="sd">    &gt;&gt;&gt; f2 = x1**2 - 2 * x1 + x2**2 + 2 * x2 - 8</span>
<span class="sd">    &gt;&gt;&gt; print(nsolve((f1, f2), (x1, x2), (-1, 1)))</span>
<span class="sd">    [-1.19287309935246]</span>
<span class="sd">    [ 1.27844411169911]</span>

<span class="sd">    For one-dimensional functions the syntax is simplified:</span>

<span class="sd">    &gt;&gt;&gt; from sympy import sin, nsolve</span>
<span class="sd">    &gt;&gt;&gt; from sympy.abc import x</span>
<span class="sd">    &gt;&gt;&gt; nsolve(sin(x), x, 2)</span>
<span class="sd">    3.14159265358979</span>
<span class="sd">    &gt;&gt;&gt; nsolve(sin(x), 2)</span>
<span class="sd">    3.14159265358979</span>

<span class="sd">    mpmath.findroot is used, you can find there more extensive documentation,</span>
<span class="sd">    especially concerning keyword parameters and available solvers. Note,</span>
<span class="sd">    however, that this routine works only with the numerator of the function</span>
<span class="sd">    in the one-dimensional case, and for very steep functions near the root</span>
<span class="sd">    this may lead to a failure in the verification of the root. In this case</span>
<span class="sd">    you should use the flag `verify=False` and independently verify the</span>
<span class="sd">    solution.</span>

<span class="sd">    &gt;&gt;&gt; from sympy import cos, cosh</span>
<span class="sd">    &gt;&gt;&gt; from sympy.abc import i</span>
<span class="sd">    &gt;&gt;&gt; f = cos(x)*cosh(x) - 1</span>
<span class="sd">    &gt;&gt;&gt; nsolve(f, 3.14*100)</span>
<span class="sd">    Traceback (most recent call last):</span>
<span class="sd">    ...</span>
<span class="sd">    ValueError: Could not find root within given tolerance. (1.39267e+230 &gt; 2.1684e-19)</span>
<span class="sd">    &gt;&gt;&gt; ans = nsolve(f, 3.14*100, verify=False); ans</span>
<span class="sd">    312.588469032184</span>
<span class="sd">    &gt;&gt;&gt; f.subs(x, ans).n(2)</span>
<span class="sd">    2.1e+121</span>
<span class="sd">    &gt;&gt;&gt; (f/f.diff(x)).subs(x, ans).n(2)</span>
<span class="sd">    7.4e-15</span>

<span class="sd">    One might safely skip the verification if bounds of the root are known</span>
<span class="sd">    and a bisection method is used:</span>

<span class="sd">    &gt;&gt;&gt; bounds = lambda i: (3.14*i, 3.14*(i + 1))</span>
<span class="sd">    &gt;&gt;&gt; nsolve(f, bounds(100), solver=&#39;bisect&#39;, verify=False)</span>
<span class="sd">    315.730061685774</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># there are several other SymPy functions that use method= so</span>
    <span class="c1"># guard against that here</span>
    <span class="k">if</span> <span class="s1">&#39;method&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">filldedent</span><span class="p">(</span><span class="s1">&#39;&#39;&#39;</span>
<span class="s1">            Keyword &quot;method&quot; should not be used in this context.  When using</span>
<span class="s1">            some mpmath solvers directly, the keyword &quot;method&quot; is</span>
<span class="s1">            used, but when using nsolve (and findroot) the keyword to use is</span>
<span class="s1">            &quot;solver&quot;.&#39;&#39;&#39;</span><span class="p">))</span>

    <span class="c1"># interpret arguments</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
        <span class="n">f</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">fargs</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">x0</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">f</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">fargs</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="n">x0</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;nsolve expected at least 2 arguments, got </span><span class="si">%i</span><span class="s1">&#39;</span>
                        <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;nsolve expected at most 3 arguments, got </span><span class="si">%i</span><span class="s1">&#39;</span>
                        <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">))</span>
    <span class="n">modules</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;modules&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;mpmath&#39;</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">iterable</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
        <span class="n">f</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">fi</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fi</span><span class="p">,</span> <span class="n">Equality</span><span class="p">):</span>
                <span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">fi</span><span class="o">.</span><span class="n">lhs</span> <span class="o">-</span> <span class="n">fi</span><span class="o">.</span><span class="n">rhs</span>
        <span class="n">f</span> <span class="o">=</span> <span class="n">Matrix</span><span class="p">(</span><span class="n">f</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">Matrix</span><span class="p">):</span>
        <span class="c1"># assume it&#39;s a sympy expression</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">Equality</span><span class="p">):</span>
            <span class="n">f</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">lhs</span> <span class="o">-</span> <span class="n">f</span><span class="o">.</span><span class="n">rhs</span>
        <span class="n">f</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">evalf</span><span class="p">()</span>
        <span class="n">syms</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">free_symbols</span>
        <span class="k">if</span> <span class="n">fargs</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">fargs</span> <span class="o">=</span> <span class="n">syms</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">syms</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="p">(</span><span class="n">fargs</span> <span class="ow">in</span> <span class="n">syms</span> <span class="ow">or</span> <span class="n">fargs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="n">syms</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">filldedent</span><span class="p">(</span><span class="s1">&#39;&#39;&#39;</span>
<span class="s1">                expected a one-dimensional and numerical function&#39;&#39;&#39;</span><span class="p">))</span>

        <span class="c1"># the function is much better behaved if there is no denominator</span>
        <span class="n">f</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">as_numer_denom</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">f</span> <span class="o">=</span> <span class="n">lambdify</span><span class="p">(</span><span class="n">fargs</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">modules</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">findroot</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">fargs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">f</span><span class="o">.</span><span class="n">cols</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="n">filldedent</span><span class="p">(</span><span class="s1">&#39;&#39;&#39;</span>
<span class="s1">            need at least as many equations as variables&#39;&#39;&#39;</span><span class="p">))</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;verbose&#39;</span><span class="p">,</span> <span class="bp">False</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;f(x):&#39;</span><span class="p">)</span>
        <span class="k">print</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
    <span class="c1"># derive Jacobian</span>
    <span class="n">J</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">jacobian</span><span class="p">(</span><span class="n">fargs</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;J(x):&#39;</span><span class="p">)</span>
        <span class="k">print</span><span class="p">(</span><span class="n">J</span><span class="p">)</span>
    <span class="c1"># create functions</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">lambdify</span><span class="p">(</span><span class="n">fargs</span><span class="p">,</span> <span class="n">f</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">modules</span><span class="p">)</span>
    <span class="n">J</span> <span class="o">=</span> <span class="n">lambdify</span><span class="p">(</span><span class="n">fargs</span><span class="p">,</span> <span class="n">J</span><span class="p">,</span> <span class="n">modules</span><span class="p">)</span>
    <span class="c1"># solve the system numerically</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">findroot</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">J</span><span class="o">=</span><span class="n">J</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">x</span></div>


<span class="k">def</span> <span class="nf">_invert</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="o">*</span><span class="n">symbols</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return tuple (i, d) where ``i`` is independent of ``symbols`` and ``d``</span>
<span class="sd">    contains symbols. ``i`` and ``d`` are obtained after recursively using</span>
<span class="sd">    algebraic inversion until an uninvertible ``d`` remains. If there are no</span>
<span class="sd">    free symbols then ``d`` will be zero. Some (but not necessarily all)</span>
<span class="sd">    solutions to the expression ``i - d`` will be related to the solutions of</span>
<span class="sd">    the original expression.</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy.solvers.solvers import _invert as invert</span>
<span class="sd">    &gt;&gt;&gt; from sympy import sqrt, cos</span>
<span class="sd">    &gt;&gt;&gt; from sympy.abc import x, y</span>
<span class="sd">    &gt;&gt;&gt; invert(x - 3)</span>
<span class="sd">    (3, x)</span>
<span class="sd">    &gt;&gt;&gt; invert(3)</span>
<span class="sd">    (3, 0)</span>
<span class="sd">    &gt;&gt;&gt; invert(2*cos(x) - 1)</span>
<span class="sd">    (1/2, cos(x))</span>
<span class="sd">    &gt;&gt;&gt; invert(sqrt(x) - 3)</span>
<span class="sd">    (3, sqrt(x))</span>
<span class="sd">    &gt;&gt;&gt; invert(sqrt(x) + y, x)</span>
<span class="sd">    (-y, sqrt(x))</span>
<span class="sd">    &gt;&gt;&gt; invert(sqrt(x) + y, y)</span>
<span class="sd">    (-sqrt(x), y)</span>
<span class="sd">    &gt;&gt;&gt; invert(sqrt(x) + y, x, y)</span>
<span class="sd">    (0, sqrt(x) + y)</span>

<span class="sd">    If there is more than one symbol in a power&#39;s base and the exponent</span>
<span class="sd">    is not an Integer, then the principal root will be used for the</span>
<span class="sd">    inversion:</span>

<span class="sd">    &gt;&gt;&gt; invert(sqrt(x + y) - 2)</span>
<span class="sd">    (4, x + y)</span>
<span class="sd">    &gt;&gt;&gt; invert(sqrt(x + y) - 2)</span>
<span class="sd">    (4, x + y)</span>

<span class="sd">    If the exponent is an integer, setting ``integer_power`` to True</span>
<span class="sd">    will force the principal root to be selected:</span>

<span class="sd">    &gt;&gt;&gt; invert(x**2 - 4, integer_power=True)</span>
<span class="sd">    (2, x)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">eq</span> <span class="o">=</span> <span class="n">sympify</span><span class="p">(</span><span class="n">eq</span><span class="p">)</span>
    <span class="n">free</span> <span class="o">=</span> <span class="n">eq</span><span class="o">.</span><span class="n">free_symbols</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">symbols</span><span class="p">:</span>
        <span class="n">symbols</span> <span class="o">=</span> <span class="n">free</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">free</span> <span class="o">&amp;</span> <span class="nb">set</span><span class="p">(</span><span class="n">symbols</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">eq</span><span class="p">,</span> <span class="n">S</span><span class="o">.</span><span class="n">Zero</span>

    <span class="n">dointpow</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;integer_power&#39;</span><span class="p">,</span> <span class="bp">False</span><span class="p">))</span>

    <span class="n">lhs</span> <span class="o">=</span> <span class="n">eq</span>
    <span class="n">rhs</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">Zero</span>
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="n">was</span> <span class="o">=</span> <span class="n">lhs</span>
        <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
            <span class="n">indep</span><span class="p">,</span> <span class="n">dep</span> <span class="o">=</span> <span class="n">lhs</span><span class="o">.</span><span class="n">as_independent</span><span class="p">(</span><span class="o">*</span><span class="n">symbols</span><span class="p">)</span>

            <span class="c1"># dep + indep == rhs</span>
            <span class="k">if</span> <span class="n">lhs</span><span class="o">.</span><span class="n">is_Add</span><span class="p">:</span>
                <span class="c1"># this indicates we have done it all</span>
                <span class="k">if</span> <span class="n">indep</span> <span class="ow">is</span> <span class="n">S</span><span class="o">.</span><span class="n">Zero</span><span class="p">:</span>
                    <span class="k">break</span>

                <span class="n">lhs</span> <span class="o">=</span> <span class="n">dep</span>
                <span class="n">rhs</span> <span class="o">-=</span> <span class="n">indep</span>

            <span class="c1"># dep * indep == rhs</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># this indicates we have done it all</span>
                <span class="k">if</span> <span class="n">indep</span> <span class="ow">is</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span><span class="p">:</span>
                    <span class="k">break</span>

                <span class="n">lhs</span> <span class="o">=</span> <span class="n">dep</span>
                <span class="n">rhs</span> <span class="o">/=</span> <span class="n">indep</span>

        <span class="c1"># collect like-terms in symbols</span>
        <span class="k">if</span> <span class="n">lhs</span><span class="o">.</span><span class="n">is_Add</span><span class="p">:</span>
            <span class="n">terms</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">lhs</span><span class="o">.</span><span class="n">args</span><span class="p">:</span>
                <span class="n">i</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">as_independent</span><span class="p">(</span><span class="o">*</span><span class="n">symbols</span><span class="p">)</span>
                <span class="n">terms</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="p">[])</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">terms</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span>
                <span class="n">args</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">d</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">terms</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">args</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Add</span><span class="p">(</span><span class="o">*</span><span class="n">i</span><span class="p">)</span><span class="o">*</span><span class="n">d</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">args</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">d</span><span class="p">)</span>
                <span class="n">lhs</span> <span class="o">=</span> <span class="n">Add</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

        <span class="c1"># if it&#39;s a two-term Add with rhs = 0 and two powers we can get the</span>
        <span class="c1"># dependent terms together, e.g. 3*f(x) + 2*g(x) -&gt; f(x)/g(x) = -2/3</span>
        <span class="k">if</span> <span class="n">lhs</span><span class="o">.</span><span class="n">is_Add</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">rhs</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">lhs</span><span class="o">.</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> \
                <span class="ow">not</span> <span class="n">lhs</span><span class="o">.</span><span class="n">is_polynomial</span><span class="p">(</span><span class="o">*</span><span class="n">symbols</span><span class="p">):</span>
            <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">ordered</span><span class="p">(</span><span class="n">lhs</span><span class="o">.</span><span class="n">args</span><span class="p">)</span>
            <span class="n">ai</span><span class="p">,</span> <span class="n">ad</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">as_independent</span><span class="p">(</span><span class="o">*</span><span class="n">symbols</span><span class="p">)</span>
            <span class="n">bi</span><span class="p">,</span> <span class="n">bd</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">as_independent</span><span class="p">(</span><span class="o">*</span><span class="n">symbols</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">_ispow</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">(</span><span class="n">ad</span><span class="p">,</span> <span class="n">bd</span><span class="p">)):</span>
                <span class="n">a_base</span><span class="p">,</span> <span class="n">a_exp</span> <span class="o">=</span> <span class="n">ad</span><span class="o">.</span><span class="n">as_base_exp</span><span class="p">()</span>
                <span class="n">b_base</span><span class="p">,</span> <span class="n">b_exp</span> <span class="o">=</span> <span class="n">bd</span><span class="o">.</span><span class="n">as_base_exp</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">a_base</span> <span class="o">==</span> <span class="n">b_base</span><span class="p">:</span>
                    <span class="c1"># a = -b</span>
                    <span class="n">lhs</span> <span class="o">=</span> <span class="n">powsimp</span><span class="p">(</span><span class="n">powdenest</span><span class="p">(</span><span class="n">ad</span><span class="o">/</span><span class="n">bd</span><span class="p">))</span>
                    <span class="n">rhs</span> <span class="o">=</span> <span class="o">-</span><span class="n">bi</span><span class="o">/</span><span class="n">ai</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">rat</span> <span class="o">=</span> <span class="n">ad</span><span class="o">/</span><span class="n">bd</span>
                    <span class="n">_lhs</span> <span class="o">=</span> <span class="n">powsimp</span><span class="p">(</span><span class="n">ad</span><span class="o">/</span><span class="n">bd</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">_lhs</span> <span class="o">!=</span> <span class="n">rat</span><span class="p">:</span>
                        <span class="n">lhs</span> <span class="o">=</span> <span class="n">_lhs</span>
                        <span class="n">rhs</span> <span class="o">=</span> <span class="o">-</span><span class="n">bi</span><span class="o">/</span><span class="n">ai</span>
            <span class="k">if</span> <span class="n">ai</span><span class="o">*</span><span class="n">bi</span> <span class="ow">is</span> <span class="n">S</span><span class="o">.</span><span class="n">NegativeOne</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">all</span><span class="p">(</span>
                        <span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">Function</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">(</span><span class="n">ad</span><span class="p">,</span> <span class="n">bd</span><span class="p">))</span> <span class="ow">and</span> \
                        <span class="n">ad</span><span class="o">.</span><span class="n">func</span> <span class="o">==</span> <span class="n">bd</span><span class="o">.</span><span class="n">func</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">ad</span><span class="o">.</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">bd</span><span class="o">.</span><span class="n">args</span><span class="p">):</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ad</span><span class="o">.</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">lhs</span> <span class="o">=</span> <span class="n">ad</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">bd</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># should be able to solve</span>
                        <span class="c1"># f(x, y) == f(2, 3) -&gt; x == 2</span>
                        <span class="c1"># f(x, x + y) == f(2, 3) -&gt; x == 2 or x == 3 - y</span>
                        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;equal function with more than 1 argument&#39;</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">lhs</span><span class="o">.</span><span class="n">is_Mul</span> <span class="ow">and</span> <span class="nb">any</span><span class="p">(</span><span class="n">_ispow</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">lhs</span><span class="o">.</span><span class="n">args</span><span class="p">):</span>
            <span class="n">lhs</span> <span class="o">=</span> <span class="n">powsimp</span><span class="p">(</span><span class="n">powdenest</span><span class="p">(</span><span class="n">lhs</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">lhs</span><span class="o">.</span><span class="n">is_Function</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="s1">&#39;inverse&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">lhs</span><span class="o">.</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1">#                    -1</span>
                <span class="c1"># f(x) = g  -&gt;  x = f  (g)</span>
                <span class="c1">#</span>
                <span class="c1"># /!\ inverse should not be defined if there are multiple values</span>
                <span class="c1"># for the function -- these are handled in _tsolve</span>
                <span class="c1">#</span>
                <span class="n">rhs</span> <span class="o">=</span> <span class="n">lhs</span><span class="o">.</span><span class="n">inverse</span><span class="p">()(</span><span class="n">rhs</span><span class="p">)</span>
                <span class="n">lhs</span> <span class="o">=</span> <span class="n">lhs</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">lhs</span><span class="o">.</span><span class="n">func</span> <span class="ow">is</span> <span class="n">atan2</span><span class="p">:</span>
                <span class="n">y</span><span class="p">,</span> <span class="n">x</span> <span class="o">=</span> <span class="n">lhs</span><span class="o">.</span><span class="n">args</span>
                <span class="n">lhs</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">atan</span><span class="p">(</span><span class="n">y</span><span class="o">/</span><span class="p">(</span><span class="n">sqrt</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">y</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">x</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">rhs</span> <span class="ow">and</span> <span class="n">lhs</span><span class="o">.</span><span class="n">is_Pow</span> <span class="ow">and</span> <span class="n">lhs</span><span class="o">.</span><span class="n">exp</span><span class="o">.</span><span class="n">is_Integer</span> <span class="ow">and</span> <span class="n">lhs</span><span class="o">.</span><span class="n">exp</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">lhs</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="n">lhs</span>
            <span class="n">rhs</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="n">rhs</span>

        <span class="c1"># base**a = b -&gt; base = b**(1/a) if</span>
        <span class="c1">#    a is an Integer and dointpow=True (this gives real branch of root)</span>
        <span class="c1">#    a is not an Integer and the equation is multivariate and the</span>
        <span class="c1">#      base has more than 1 symbol in it</span>
        <span class="c1"># The rationale for this is that right now the multi-system solvers</span>
        <span class="c1"># doesn&#39;t try to resolve generators to see, for example, if the whole</span>
        <span class="c1"># system is written in terms of sqrt(x + y) so it will just fail, so we</span>
        <span class="c1"># do that step here.</span>
        <span class="k">if</span> <span class="n">lhs</span><span class="o">.</span><span class="n">is_Pow</span> <span class="ow">and</span> <span class="p">(</span>
            <span class="n">lhs</span><span class="o">.</span><span class="n">exp</span><span class="o">.</span><span class="n">is_Integer</span> <span class="ow">and</span> <span class="n">dointpow</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">lhs</span><span class="o">.</span><span class="n">exp</span><span class="o">.</span><span class="n">is_Integer</span> <span class="ow">and</span>
                <span class="nb">len</span><span class="p">(</span><span class="n">symbols</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">lhs</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">free_symbols</span> <span class="o">&amp;</span> <span class="nb">set</span><span class="p">(</span><span class="n">symbols</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">rhs</span> <span class="o">=</span> <span class="n">rhs</span><span class="o">**</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">lhs</span><span class="o">.</span><span class="n">exp</span><span class="p">)</span>
            <span class="n">lhs</span> <span class="o">=</span> <span class="n">lhs</span><span class="o">.</span><span class="n">base</span>

        <span class="k">if</span> <span class="n">lhs</span> <span class="o">==</span> <span class="n">was</span><span class="p">:</span>
            <span class="k">break</span>
    <span class="k">return</span> <span class="n">rhs</span><span class="p">,</span> <span class="n">lhs</span>


<span class="k">def</span> <span class="nf">unrad</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="o">*</span><span class="n">syms</span><span class="p">,</span> <span class="o">**</span><span class="n">flags</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Remove radicals with symbolic arguments and return (eq, cov),</span>
<span class="sd">    None or raise an error:</span>

<span class="sd">    None is returned if there are no radicals to remove.</span>

<span class="sd">    NotImplementedError is raised if there are radicals and they cannot be</span>
<span class="sd">    removed or if the relationship between the original symbols and the</span>
<span class="sd">    change of variable needed to rewrite the system as a polynomial cannot</span>
<span class="sd">    be solved.</span>

<span class="sd">    Otherwise the tuple, ``(eq, cov)``, is returned where::</span>

<span class="sd">        ``eq``, ``cov``</span>
<span class="sd">            ``eq`` is an equation without radicals (in the symbol(s) of</span>
<span class="sd">            interest) whose solutions are a superset of the solutions to the</span>
<span class="sd">            original expression. ``eq`` might be re-written in terms of a new</span>
<span class="sd">            variable; the relationship to the original variables is given by</span>
<span class="sd">            ``cov`` which is a list containing ``v`` and ``v**p - b`` where</span>
<span class="sd">            ``p`` is the power needed to clear the radical and ``b`` is the</span>
<span class="sd">            radical now expressed as a polynomial in the symbols of interest.</span>
<span class="sd">            For example, for sqrt(2 - x) the tuple would be</span>
<span class="sd">            ``(c, c**2 - 2 + x)``. The solutions of ``eq`` will contain</span>
<span class="sd">            solutions to the original equation (if there are any).</span>

<span class="sd">    ``syms``</span>
<span class="sd">        an iterable of symbols which, if provided, will limit the focus of</span>
<span class="sd">        radical removal: only radicals with one or more of the symbols of</span>
<span class="sd">        interest will be cleared. All free symbols are used if ``syms`` is not</span>
<span class="sd">        set.</span>

<span class="sd">    ``flags`` are used internally for communication during recursive calls.</span>
<span class="sd">    Two options are also recognized::</span>

<span class="sd">        ``take``, when defined, is interpreted as a single-argument function</span>
<span class="sd">        that returns True if a given Pow should be handled.</span>

<span class="sd">    Radicals can be removed from an expression if::</span>

<span class="sd">        *   all bases of the radicals are the same; a change of variables is</span>
<span class="sd">            done in this case.</span>
<span class="sd">        *   if all radicals appear in one term of the expression</span>
<span class="sd">        *   there are only 4 terms with sqrt() factors or there are less than</span>
<span class="sd">            four terms having sqrt() factors</span>
<span class="sd">        *   there are only two terms with radicals</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy.solvers.solvers import unrad</span>
<span class="sd">    &gt;&gt;&gt; from sympy.abc import x</span>
<span class="sd">    &gt;&gt;&gt; from sympy import sqrt, Rational, root, real_roots, solve</span>

<span class="sd">    &gt;&gt;&gt; unrad(sqrt(x)*x**Rational(1, 3) + 2)</span>
<span class="sd">    (x**5 - 64, [])</span>
<span class="sd">    &gt;&gt;&gt; unrad(sqrt(x) + root(x + 1, 3))</span>
<span class="sd">    (x**3 - x**2 - 2*x - 1, [])</span>
<span class="sd">    &gt;&gt;&gt; eq = sqrt(x) + root(x, 3) - 2</span>
<span class="sd">    &gt;&gt;&gt; unrad(eq)</span>
<span class="sd">    (_p**3 + _p**2 - 2, [_p, _p**6 - x])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_inv_error</span> <span class="o">=</span> <span class="s1">&#39;cannot get an analytical solution for the inversion&#39;</span>

    <span class="n">uflags</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">check</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">simplify</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_cov</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">e</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">cov</span><span class="p">:</span>
            <span class="c1"># XXX - uncovered</span>
            <span class="n">oldp</span><span class="p">,</span> <span class="n">olde</span> <span class="o">=</span> <span class="n">cov</span>
            <span class="k">if</span> <span class="n">Poly</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span><span class="o">.</span><span class="n">degree</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>
                <span class="n">cov</span><span class="p">[:]</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span><span class="p">,</span> <span class="n">olde</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">oldp</span><span class="p">,</span> <span class="n">_solve</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="o">**</span><span class="n">uflags</span><span class="p">)[</span><span class="mi">0</span><span class="p">])]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">cov</span><span class="p">[:]</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span><span class="p">,</span> <span class="n">e</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_canonical</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">cov</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">cov</span><span class="p">:</span>
            <span class="c1"># change symbol to vanilla so no solutions are eliminated</span>
            <span class="n">p</span><span class="p">,</span> <span class="n">e</span> <span class="o">=</span> <span class="n">cov</span>
            <span class="n">rep</span> <span class="o">=</span> <span class="p">{</span><span class="n">p</span><span class="p">:</span> <span class="n">Dummy</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">name</span><span class="p">)}</span>
            <span class="n">eq</span> <span class="o">=</span> <span class="n">eq</span><span class="o">.</span><span class="n">xreplace</span><span class="p">(</span><span class="n">rep</span><span class="p">)</span>
            <span class="n">cov</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span><span class="o">.</span><span class="n">xreplace</span><span class="p">(</span><span class="n">rep</span><span class="p">),</span> <span class="n">e</span><span class="o">.</span><span class="n">xreplace</span><span class="p">(</span><span class="n">rep</span><span class="p">)]</span>

        <span class="c1"># remove constants and powers of factors since these don&#39;t change</span>
        <span class="c1"># the location of the root; XXX should factor or factor_terms be used?</span>
        <span class="n">eq</span> <span class="o">=</span> <span class="n">factor_terms</span><span class="p">(</span><span class="n">_mexpand</span><span class="p">(</span><span class="n">eq</span><span class="o">.</span><span class="n">as_numer_denom</span><span class="p">()[</span><span class="mi">0</span><span class="p">],</span> <span class="n">recursive</span><span class="o">=</span><span class="bp">True</span><span class="p">),</span> <span class="n">clear</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">eq</span><span class="o">.</span><span class="n">is_Mul</span><span class="p">:</span>
            <span class="n">args</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">eq</span><span class="o">.</span><span class="n">args</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">f</span><span class="o">.</span><span class="n">is_number</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="k">if</span> <span class="n">f</span><span class="o">.</span><span class="n">is_Pow</span> <span class="ow">and</span> <span class="n">_take</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="bp">True</span><span class="p">):</span>
                    <span class="n">args</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">base</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">args</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
            <span class="n">eq</span> <span class="o">=</span> <span class="n">Mul</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>  <span class="c1"># leave as Mul for more efficient solving</span>

        <span class="c1"># make the sign canonical</span>
        <span class="n">free</span> <span class="o">=</span> <span class="n">eq</span><span class="o">.</span><span class="n">free_symbols</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">free</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">eq</span><span class="o">.</span><span class="n">coeff</span><span class="p">(</span><span class="n">free</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span><span class="o">**</span><span class="n">degree</span><span class="p">(</span><span class="n">eq</span><span class="p">))</span><span class="o">.</span><span class="n">could_extract_minus_sign</span><span class="p">():</span>
                <span class="n">eq</span> <span class="o">=</span> <span class="o">-</span><span class="n">eq</span>
        <span class="k">elif</span> <span class="n">eq</span><span class="o">.</span><span class="n">could_extract_minus_sign</span><span class="p">():</span>
            <span class="n">eq</span> <span class="o">=</span> <span class="o">-</span><span class="n">eq</span>

        <span class="k">return</span> <span class="n">eq</span><span class="p">,</span> <span class="n">cov</span>

    <span class="k">def</span> <span class="nf">_Q</span><span class="p">(</span><span class="nb">pow</span><span class="p">):</span>
        <span class="c1"># return leading Rational of denominator of Pow&#39;s exponent</span>
        <span class="n">c</span> <span class="o">=</span> <span class="nb">pow</span><span class="o">.</span><span class="n">as_base_exp</span><span class="p">()[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">as_coeff_Mul</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">c</span><span class="o">.</span><span class="n">is_Rational</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span>
        <span class="k">return</span> <span class="n">c</span><span class="o">.</span><span class="n">q</span>

    <span class="c1"># define the _take method that will determine whether a term is of interest</span>
    <span class="k">def</span> <span class="nf">_take</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">take_int_pow</span><span class="p">):</span>
        <span class="c1"># return True if coefficient of any factor&#39;s exponent&#39;s den is not 1</span>
        <span class="k">for</span> <span class="nb">pow</span> <span class="ow">in</span> <span class="n">Mul</span><span class="o">.</span><span class="n">make_args</span><span class="p">(</span><span class="n">d</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">pow</span><span class="o">.</span><span class="n">is_Symbol</span> <span class="ow">or</span> <span class="nb">pow</span><span class="o">.</span><span class="n">is_Pow</span><span class="p">):</span>
                <span class="k">continue</span>
            <span class="n">b</span><span class="p">,</span> <span class="n">e</span> <span class="o">=</span> <span class="nb">pow</span><span class="o">.</span><span class="n">as_base_exp</span><span class="p">()</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">b</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="o">*</span><span class="n">syms</span><span class="p">):</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">take_int_pow</span> <span class="ow">and</span> <span class="n">_Q</span><span class="p">(</span><span class="nb">pow</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">free</span> <span class="o">=</span> <span class="nb">pow</span><span class="o">.</span><span class="n">free_symbols</span>
            <span class="k">if</span> <span class="n">free</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">syms</span><span class="p">):</span>
                <span class="k">return</span> <span class="bp">True</span>
        <span class="k">return</span> <span class="bp">False</span>
    <span class="n">_take</span> <span class="o">=</span> <span class="n">flags</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;_take&#39;</span><span class="p">,</span> <span class="n">_take</span><span class="p">)</span>

    <span class="n">cov</span><span class="p">,</span> <span class="n">nwas</span><span class="p">,</span> <span class="n">rpt</span> <span class="o">=</span> <span class="p">[</span><span class="n">flags</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span>
        <span class="nb">sorted</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span><span class="n">cov</span><span class="o">=</span><span class="p">[],</span> <span class="n">n</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">rpt</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">items</span><span class="p">())]</span>

    <span class="c1"># preconditioning</span>
    <span class="n">eq</span> <span class="o">=</span> <span class="n">powdenest</span><span class="p">(</span><span class="n">factor_terms</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">radical</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">clear</span><span class="o">=</span><span class="bp">True</span><span class="p">))</span>
    <span class="n">eq</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="n">eq</span><span class="o">.</span><span class="n">as_numer_denom</span><span class="p">()</span>
    <span class="n">eq</span> <span class="o">=</span> <span class="n">_mexpand</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">recursive</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">eq</span><span class="o">.</span><span class="n">is_number</span><span class="p">:</span>
        <span class="k">return</span>

    <span class="n">syms</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">syms</span><span class="p">)</span> <span class="ow">or</span> <span class="n">eq</span><span class="o">.</span><span class="n">free_symbols</span>
    <span class="n">poly</span> <span class="o">=</span> <span class="n">eq</span><span class="o">.</span><span class="n">as_poly</span><span class="p">()</span>
    <span class="n">gens</span> <span class="o">=</span> <span class="p">[</span><span class="n">g</span> <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">poly</span><span class="o">.</span><span class="n">gens</span> <span class="k">if</span> <span class="n">_take</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="bp">True</span><span class="p">)]</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">gens</span><span class="p">:</span>
        <span class="k">return</span>

    <span class="c1"># check for trivial case</span>
    <span class="c1"># - already a polynomial in integer powers</span>
    <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">_Q</span><span class="p">(</span><span class="n">g</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">gens</span><span class="p">):</span>
        <span class="k">return</span>
    <span class="c1"># - an exponent has a symbol of interest (don&#39;t handle)</span>
    <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">as_base_exp</span><span class="p">()[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="o">*</span><span class="n">syms</span><span class="p">)</span> <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">gens</span><span class="p">):</span>
        <span class="k">return</span>

    <span class="k">def</span> <span class="nf">_rads_bases_lcm</span><span class="p">(</span><span class="n">poly</span><span class="p">):</span>
        <span class="c1"># if all the bases are the same or all the radicals are in one</span>
        <span class="c1"># term, `lcm` will be the lcm of the denominators of the</span>
        <span class="c1"># exponents of the radicals</span>
        <span class="n">lcm</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">rads</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">bases</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">poly</span><span class="o">.</span><span class="n">gens</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">_take</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="bp">False</span><span class="p">):</span>
                <span class="k">continue</span>
            <span class="n">q</span> <span class="o">=</span> <span class="n">_Q</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">q</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">rads</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
                <span class="n">lcm</span> <span class="o">=</span> <span class="n">ilcm</span><span class="p">(</span><span class="n">lcm</span><span class="p">,</span> <span class="n">q</span><span class="p">)</span>
                <span class="n">bases</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">base</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">rads</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">lcm</span>
    <span class="n">rads</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">lcm</span> <span class="o">=</span> <span class="n">_rads_bases_lcm</span><span class="p">(</span><span class="n">poly</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">rads</span><span class="p">:</span>
        <span class="k">return</span>

    <span class="n">covsym</span> <span class="o">=</span> <span class="n">Dummy</span><span class="p">(</span><span class="s1">&#39;p&#39;</span><span class="p">,</span> <span class="n">nonnegative</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

    <span class="c1"># only keep in syms symbols that actually appear in radicals;</span>
    <span class="c1"># and update gens</span>
    <span class="n">newsyms</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">rads</span><span class="p">:</span>
        <span class="n">newsyms</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">syms</span> <span class="o">&amp;</span> <span class="n">r</span><span class="o">.</span><span class="n">free_symbols</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">newsyms</span> <span class="o">!=</span> <span class="n">syms</span><span class="p">:</span>
        <span class="n">syms</span> <span class="o">=</span> <span class="n">newsyms</span>
        <span class="n">gens</span> <span class="o">=</span> <span class="p">[</span><span class="n">g</span> <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">gens</span> <span class="k">if</span> <span class="n">g</span><span class="o">.</span><span class="n">free_symbols</span> <span class="o">&amp;</span> <span class="n">syms</span><span class="p">]</span>

    <span class="c1"># get terms together that have common generators</span>
    <span class="n">drad</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">rads</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">rads</span><span class="p">))))))</span>
    <span class="n">rterms</span> <span class="o">=</span> <span class="p">{():</span> <span class="p">[]}</span>
    <span class="n">args</span> <span class="o">=</span> <span class="n">Add</span><span class="o">.</span><span class="n">make_args</span><span class="p">(</span><span class="n">poly</span><span class="o">.</span><span class="n">as_expr</span><span class="p">())</span>
    <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">_take</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="bp">False</span><span class="p">):</span>
            <span class="n">common</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">as_poly</span><span class="p">()</span><span class="o">.</span><span class="n">gens</span><span class="p">)</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">rads</span><span class="p">)</span>
            <span class="n">key</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">([</span><span class="n">drad</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">common</span><span class="p">]))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">key</span> <span class="o">=</span> <span class="p">()</span>
        <span class="n">rterms</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="p">[])</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
    <span class="n">others</span> <span class="o">=</span> <span class="n">Add</span><span class="p">(</span><span class="o">*</span><span class="n">rterms</span><span class="o">.</span><span class="n">pop</span><span class="p">(()))</span>
    <span class="n">rterms</span> <span class="o">=</span> <span class="p">[</span><span class="n">Add</span><span class="p">(</span><span class="o">*</span><span class="n">rterms</span><span class="p">[</span><span class="n">k</span><span class="p">])</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">rterms</span><span class="o">.</span><span class="n">keys</span><span class="p">()]</span>

    <span class="c1"># the output will depend on the order terms are processed, so</span>
    <span class="c1"># make it canonical quickly</span>
    <span class="n">rterms</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">ordered</span><span class="p">(</span><span class="n">rterms</span><span class="p">))))</span>

    <span class="n">ok</span> <span class="o">=</span> <span class="bp">False</span>  <span class="c1"># we don&#39;t have a solution yet</span>
    <span class="n">depth</span> <span class="o">=</span> <span class="n">sqrt_depth</span><span class="p">(</span><span class="n">eq</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">rterms</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="ow">not</span> <span class="p">(</span><span class="n">rterms</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">is_Add</span> <span class="ow">and</span> <span class="n">lcm</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">):</span>
        <span class="n">eq</span> <span class="o">=</span> <span class="n">rterms</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="n">lcm</span> <span class="o">-</span> <span class="p">((</span><span class="o">-</span><span class="n">others</span><span class="p">)</span><span class="o">**</span><span class="n">lcm</span><span class="p">)</span>
        <span class="n">ok</span> <span class="o">=</span> <span class="bp">True</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">rterms</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">rterms</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">is_Add</span><span class="p">:</span>
            <span class="n">rterms</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">rterms</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">args</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">bases</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">b</span> <span class="o">=</span> <span class="n">bases</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">syms</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">free</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">free_symbols</span>
                <span class="n">x</span> <span class="o">=</span> <span class="p">{</span><span class="n">g</span> <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">gens</span> <span class="k">if</span> <span class="n">g</span><span class="o">.</span><span class="n">is_Symbol</span><span class="p">}</span> <span class="o">&amp;</span> <span class="n">free</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">x</span><span class="p">:</span>
                    <span class="n">x</span> <span class="o">=</span> <span class="n">free</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">ordered</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">syms</span>
            <span class="n">x</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">x</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">inv</span> <span class="o">=</span> <span class="n">_solve</span><span class="p">(</span><span class="n">covsym</span><span class="o">**</span><span class="n">lcm</span> <span class="o">-</span> <span class="n">b</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="o">**</span><span class="n">uflags</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">inv</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">NotImplementedError</span>
                <span class="n">eq</span> <span class="o">=</span> <span class="n">poly</span><span class="o">.</span><span class="n">as_expr</span><span class="p">()</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">covsym</span><span class="o">**</span><span class="n">lcm</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">inv</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">_cov</span><span class="p">(</span><span class="n">covsym</span><span class="p">,</span> <span class="n">covsym</span><span class="o">**</span><span class="n">lcm</span> <span class="o">-</span> <span class="n">b</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">_canonical</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">cov</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">NotImplementedError</span><span class="p">:</span>
                <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># no longer consider integer powers as generators</span>
            <span class="n">gens</span> <span class="o">=</span> <span class="p">[</span><span class="n">g</span> <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">gens</span> <span class="k">if</span> <span class="n">_Q</span><span class="p">(</span><span class="n">g</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">]</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">rterms</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">others</span><span class="p">:</span>
                <span class="n">eq</span> <span class="o">=</span> <span class="n">rterms</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="n">lcm</span> <span class="o">-</span> <span class="p">(</span><span class="o">-</span><span class="n">rterms</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">**</span><span class="n">lcm</span>
                <span class="n">ok</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="k">elif</span> <span class="ow">not</span> <span class="n">log</span><span class="p">(</span><span class="n">lcm</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">is_Integer</span><span class="p">:</span>
                <span class="c1"># the lcm-is-power-of-two case is handled below</span>
                <span class="n">r0</span><span class="p">,</span> <span class="n">r1</span> <span class="o">=</span> <span class="n">rterms</span>
                <span class="k">if</span> <span class="n">flags</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;_reverse&#39;</span><span class="p">,</span> <span class="bp">False</span><span class="p">):</span>
                    <span class="n">r1</span><span class="p">,</span> <span class="n">r0</span> <span class="o">=</span> <span class="n">r0</span><span class="p">,</span> <span class="n">r1</span>
                <span class="n">i0</span> <span class="o">=</span> <span class="n">_rads0</span><span class="p">,</span> <span class="n">_bases0</span><span class="p">,</span> <span class="n">lcm0</span> <span class="o">=</span> <span class="n">_rads_bases_lcm</span><span class="p">(</span><span class="n">r0</span><span class="o">.</span><span class="n">as_poly</span><span class="p">())</span>
                <span class="n">i1</span> <span class="o">=</span> <span class="n">_rads1</span><span class="p">,</span> <span class="n">_bases1</span><span class="p">,</span> <span class="n">lcm1</span> <span class="o">=</span> <span class="n">_rads_bases_lcm</span><span class="p">(</span><span class="n">r1</span><span class="o">.</span><span class="n">as_poly</span><span class="p">())</span>
                <span class="k">for</span> <span class="n">reverse</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">reverse</span><span class="p">:</span>
                        <span class="n">i0</span><span class="p">,</span> <span class="n">i1</span> <span class="o">=</span> <span class="n">i1</span><span class="p">,</span> <span class="n">i0</span>
                        <span class="n">r0</span><span class="p">,</span> <span class="n">r1</span> <span class="o">=</span> <span class="n">r1</span><span class="p">,</span> <span class="n">r0</span>
                    <span class="n">_rads1</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">lcm1</span> <span class="o">=</span> <span class="n">i1</span>
                    <span class="n">_rads1</span> <span class="o">=</span> <span class="n">Mul</span><span class="p">(</span><span class="o">*</span><span class="n">_rads1</span><span class="p">)</span>
                    <span class="n">t1</span> <span class="o">=</span> <span class="n">_rads1</span><span class="o">**</span><span class="n">lcm1</span>
                    <span class="n">c</span> <span class="o">=</span> <span class="n">covsym</span><span class="o">**</span><span class="n">lcm1</span> <span class="o">-</span> <span class="n">t1</span>
                    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">syms</span><span class="p">:</span>
                        <span class="k">try</span><span class="p">:</span>
                            <span class="n">sol</span> <span class="o">=</span> <span class="n">_solve</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="o">**</span><span class="n">uflags</span><span class="p">)</span>
                            <span class="k">if</span> <span class="ow">not</span> <span class="n">sol</span><span class="p">:</span>
                                <span class="k">raise</span> <span class="ne">NotImplementedError</span>
                            <span class="n">neweq</span> <span class="o">=</span> <span class="n">r0</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">sol</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="n">covsym</span><span class="o">*</span><span class="n">r1</span><span class="o">/</span><span class="n">_rads1</span> <span class="o">+</span> \
                                <span class="n">others</span>
                            <span class="n">tmp</span> <span class="o">=</span> <span class="n">unrad</span><span class="p">(</span><span class="n">neweq</span><span class="p">,</span> <span class="n">covsym</span><span class="p">)</span>
                            <span class="k">if</span> <span class="n">tmp</span><span class="p">:</span>
                                <span class="n">eq</span><span class="p">,</span> <span class="n">newcov</span> <span class="o">=</span> <span class="n">tmp</span>
                                <span class="k">if</span> <span class="n">newcov</span><span class="p">:</span>
                                    <span class="n">newp</span><span class="p">,</span> <span class="n">newc</span> <span class="o">=</span> <span class="n">newcov</span>
                                    <span class="n">_cov</span><span class="p">(</span><span class="n">newp</span><span class="p">,</span> <span class="n">c</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">covsym</span><span class="p">,</span>
                                        <span class="n">_solve</span><span class="p">(</span><span class="n">newc</span><span class="p">,</span> <span class="n">covsym</span><span class="p">,</span> <span class="o">**</span><span class="n">uflags</span><span class="p">)[</span><span class="mi">0</span><span class="p">]))</span>
                                <span class="k">else</span><span class="p">:</span>
                                    <span class="n">_cov</span><span class="p">(</span><span class="n">covsym</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="n">eq</span> <span class="o">=</span> <span class="n">neweq</span>
                                <span class="n">_cov</span><span class="p">(</span><span class="n">covsym</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
                            <span class="n">ok</span> <span class="o">=</span> <span class="bp">True</span>
                            <span class="k">break</span>
                        <span class="k">except</span> <span class="ne">NotImplementedError</span><span class="p">:</span>
                            <span class="k">if</span> <span class="n">reverse</span><span class="p">:</span>
                                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                                    <span class="s1">&#39;no successful change of variable found&#39;</span><span class="p">)</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="k">pass</span>
                    <span class="k">if</span> <span class="n">ok</span><span class="p">:</span>
                        <span class="k">break</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">rterms</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="c1"># two cube roots and another with order less than 5</span>
            <span class="c1"># (so an analytical solution can be found) or a base</span>
            <span class="c1"># that matches one of the cube root bases</span>
            <span class="n">info</span> <span class="o">=</span> <span class="p">[</span><span class="n">_rads_bases_lcm</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">as_poly</span><span class="p">())</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">rterms</span><span class="p">]</span>
            <span class="n">RAD</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">BASES</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">LCM</span> <span class="o">=</span> <span class="mi">2</span>
            <span class="k">if</span> <span class="n">info</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">LCM</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">:</span>
                <span class="n">info</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">info</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
                <span class="n">rterms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rterms</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
            <span class="k">elif</span> <span class="n">info</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">LCM</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">:</span>
                <span class="n">info</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">info</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
                <span class="n">rterms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rterms</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">info</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">LCM</span><span class="p">]</span> <span class="o">==</span> <span class="n">info</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">LCM</span><span class="p">]</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">info</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">BASES</span><span class="p">]</span> <span class="o">!=</span> <span class="n">info</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="n">BASES</span><span class="p">]:</span>
                    <span class="n">info</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">info</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">info</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">info</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">rterms</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">rterms</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">rterms</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">rterms</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">info</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">BASES</span><span class="p">]</span> <span class="o">==</span> <span class="n">info</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="n">BASES</span><span class="p">]:</span>
                    <span class="n">eq</span> <span class="o">=</span> <span class="n">rterms</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">3</span> <span class="o">+</span> <span class="p">(</span><span class="n">rterms</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">rterms</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">others</span><span class="p">)</span><span class="o">**</span><span class="mi">3</span>
                    <span class="n">ok</span> <span class="o">=</span> <span class="bp">True</span>
                <span class="k">elif</span> <span class="n">info</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="n">LCM</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">:</span>
                    <span class="c1"># a*root(A, 3) + b*root(B, 3) + others = c</span>
                    <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">B</span> <span class="o">=</span> <span class="p">[</span><span class="n">Dummy</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="s1">&#39;abcdAB&#39;</span><span class="p">]</span>
                    <span class="c1"># zz represents the unraded expression into which the</span>
                    <span class="c1"># specifics for this case are substituted</span>
                    <span class="n">zz</span> <span class="o">=</span> <span class="p">(</span><span class="n">c</span> <span class="o">-</span> <span class="n">d</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">A</span><span class="o">**</span><span class="mi">3</span><span class="o">*</span><span class="n">a</span><span class="o">**</span><span class="mi">9</span> <span class="o">+</span> <span class="mi">3</span><span class="o">*</span><span class="n">A</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">B</span><span class="o">*</span><span class="n">a</span><span class="o">**</span><span class="mi">6</span><span class="o">*</span><span class="n">b</span><span class="o">**</span><span class="mi">3</span> <span class="o">-</span>
                        <span class="mi">3</span><span class="o">*</span><span class="n">A</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">a</span><span class="o">**</span><span class="mi">6</span><span class="o">*</span><span class="n">c</span><span class="o">**</span><span class="mi">3</span> <span class="o">+</span> <span class="mi">9</span><span class="o">*</span><span class="n">A</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">a</span><span class="o">**</span><span class="mi">6</span><span class="o">*</span><span class="n">c</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">d</span> <span class="o">-</span> <span class="mi">9</span><span class="o">*</span><span class="n">A</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">a</span><span class="o">**</span><span class="mi">6</span><span class="o">*</span><span class="n">c</span><span class="o">*</span><span class="n">d</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span>
                        <span class="mi">3</span><span class="o">*</span><span class="n">A</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">a</span><span class="o">**</span><span class="mi">6</span><span class="o">*</span><span class="n">d</span><span class="o">**</span><span class="mi">3</span> <span class="o">+</span> <span class="mi">3</span><span class="o">*</span><span class="n">A</span><span class="o">*</span><span class="n">B</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">a</span><span class="o">**</span><span class="mi">3</span><span class="o">*</span><span class="n">b</span><span class="o">**</span><span class="mi">6</span> <span class="o">+</span> <span class="mi">21</span><span class="o">*</span><span class="n">A</span><span class="o">*</span><span class="n">B</span><span class="o">*</span><span class="n">a</span><span class="o">**</span><span class="mi">3</span><span class="o">*</span><span class="n">b</span><span class="o">**</span><span class="mi">3</span><span class="o">*</span><span class="n">c</span><span class="o">**</span><span class="mi">3</span> <span class="o">-</span>
                        <span class="mi">63</span><span class="o">*</span><span class="n">A</span><span class="o">*</span><span class="n">B</span><span class="o">*</span><span class="n">a</span><span class="o">**</span><span class="mi">3</span><span class="o">*</span><span class="n">b</span><span class="o">**</span><span class="mi">3</span><span class="o">*</span><span class="n">c</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">d</span> <span class="o">+</span> <span class="mi">63</span><span class="o">*</span><span class="n">A</span><span class="o">*</span><span class="n">B</span><span class="o">*</span><span class="n">a</span><span class="o">**</span><span class="mi">3</span><span class="o">*</span><span class="n">b</span><span class="o">**</span><span class="mi">3</span><span class="o">*</span><span class="n">c</span><span class="o">*</span><span class="n">d</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span>
                        <span class="mi">21</span><span class="o">*</span><span class="n">A</span><span class="o">*</span><span class="n">B</span><span class="o">*</span><span class="n">a</span><span class="o">**</span><span class="mi">3</span><span class="o">*</span><span class="n">b</span><span class="o">**</span><span class="mi">3</span><span class="o">*</span><span class="n">d</span><span class="o">**</span><span class="mi">3</span> <span class="o">+</span> <span class="mi">3</span><span class="o">*</span><span class="n">A</span><span class="o">*</span><span class="n">a</span><span class="o">**</span><span class="mi">3</span><span class="o">*</span><span class="n">c</span><span class="o">**</span><span class="mi">6</span> <span class="o">-</span> <span class="mi">18</span><span class="o">*</span><span class="n">A</span><span class="o">*</span><span class="n">a</span><span class="o">**</span><span class="mi">3</span><span class="o">*</span><span class="n">c</span><span class="o">**</span><span class="mi">5</span><span class="o">*</span><span class="n">d</span> <span class="o">+</span>
                        <span class="mi">45</span><span class="o">*</span><span class="n">A</span><span class="o">*</span><span class="n">a</span><span class="o">**</span><span class="mi">3</span><span class="o">*</span><span class="n">c</span><span class="o">**</span><span class="mi">4</span><span class="o">*</span><span class="n">d</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">60</span><span class="o">*</span><span class="n">A</span><span class="o">*</span><span class="n">a</span><span class="o">**</span><span class="mi">3</span><span class="o">*</span><span class="n">c</span><span class="o">**</span><span class="mi">3</span><span class="o">*</span><span class="n">d</span><span class="o">**</span><span class="mi">3</span> <span class="o">+</span> <span class="mi">45</span><span class="o">*</span><span class="n">A</span><span class="o">*</span><span class="n">a</span><span class="o">**</span><span class="mi">3</span><span class="o">*</span><span class="n">c</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">d</span><span class="o">**</span><span class="mi">4</span> <span class="o">-</span>
                        <span class="mi">18</span><span class="o">*</span><span class="n">A</span><span class="o">*</span><span class="n">a</span><span class="o">**</span><span class="mi">3</span><span class="o">*</span><span class="n">c</span><span class="o">*</span><span class="n">d</span><span class="o">**</span><span class="mi">5</span> <span class="o">+</span> <span class="mi">3</span><span class="o">*</span><span class="n">A</span><span class="o">*</span><span class="n">a</span><span class="o">**</span><span class="mi">3</span><span class="o">*</span><span class="n">d</span><span class="o">**</span><span class="mi">6</span> <span class="o">+</span> <span class="n">B</span><span class="o">**</span><span class="mi">3</span><span class="o">*</span><span class="n">b</span><span class="o">**</span><span class="mi">9</span> <span class="o">-</span> <span class="mi">3</span><span class="o">*</span><span class="n">B</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">b</span><span class="o">**</span><span class="mi">6</span><span class="o">*</span><span class="n">c</span><span class="o">**</span><span class="mi">3</span> <span class="o">+</span>
                        <span class="mi">9</span><span class="o">*</span><span class="n">B</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">b</span><span class="o">**</span><span class="mi">6</span><span class="o">*</span><span class="n">c</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">d</span> <span class="o">-</span> <span class="mi">9</span><span class="o">*</span><span class="n">B</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">b</span><span class="o">**</span><span class="mi">6</span><span class="o">*</span><span class="n">c</span><span class="o">*</span><span class="n">d</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">3</span><span class="o">*</span><span class="n">B</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">b</span><span class="o">**</span><span class="mi">6</span><span class="o">*</span><span class="n">d</span><span class="o">**</span><span class="mi">3</span> <span class="o">+</span>
                        <span class="mi">3</span><span class="o">*</span><span class="n">B</span><span class="o">*</span><span class="n">b</span><span class="o">**</span><span class="mi">3</span><span class="o">*</span><span class="n">c</span><span class="o">**</span><span class="mi">6</span> <span class="o">-</span> <span class="mi">18</span><span class="o">*</span><span class="n">B</span><span class="o">*</span><span class="n">b</span><span class="o">**</span><span class="mi">3</span><span class="o">*</span><span class="n">c</span><span class="o">**</span><span class="mi">5</span><span class="o">*</span><span class="n">d</span> <span class="o">+</span> <span class="mi">45</span><span class="o">*</span><span class="n">B</span><span class="o">*</span><span class="n">b</span><span class="o">**</span><span class="mi">3</span><span class="o">*</span><span class="n">c</span><span class="o">**</span><span class="mi">4</span><span class="o">*</span><span class="n">d</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span>
                        <span class="mi">60</span><span class="o">*</span><span class="n">B</span><span class="o">*</span><span class="n">b</span><span class="o">**</span><span class="mi">3</span><span class="o">*</span><span class="n">c</span><span class="o">**</span><span class="mi">3</span><span class="o">*</span><span class="n">d</span><span class="o">**</span><span class="mi">3</span> <span class="o">+</span> <span class="mi">45</span><span class="o">*</span><span class="n">B</span><span class="o">*</span><span class="n">b</span><span class="o">**</span><span class="mi">3</span><span class="o">*</span><span class="n">c</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">d</span><span class="o">**</span><span class="mi">4</span> <span class="o">-</span> <span class="mi">18</span><span class="o">*</span><span class="n">B</span><span class="o">*</span><span class="n">b</span><span class="o">**</span><span class="mi">3</span><span class="o">*</span><span class="n">c</span><span class="o">*</span><span class="n">d</span><span class="o">**</span><span class="mi">5</span> <span class="o">+</span>
                        <span class="mi">3</span><span class="o">*</span><span class="n">B</span><span class="o">*</span><span class="n">b</span><span class="o">**</span><span class="mi">3</span><span class="o">*</span><span class="n">d</span><span class="o">**</span><span class="mi">6</span> <span class="o">-</span> <span class="n">c</span><span class="o">**</span><span class="mi">9</span> <span class="o">+</span> <span class="mi">9</span><span class="o">*</span><span class="n">c</span><span class="o">**</span><span class="mi">8</span><span class="o">*</span><span class="n">d</span> <span class="o">-</span> <span class="mi">36</span><span class="o">*</span><span class="n">c</span><span class="o">**</span><span class="mi">7</span><span class="o">*</span><span class="n">d</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">84</span><span class="o">*</span><span class="n">c</span><span class="o">**</span><span class="mi">6</span><span class="o">*</span><span class="n">d</span><span class="o">**</span><span class="mi">3</span> <span class="o">-</span>
                        <span class="mi">126</span><span class="o">*</span><span class="n">c</span><span class="o">**</span><span class="mi">5</span><span class="o">*</span><span class="n">d</span><span class="o">**</span><span class="mi">4</span> <span class="o">+</span> <span class="mi">126</span><span class="o">*</span><span class="n">c</span><span class="o">**</span><span class="mi">4</span><span class="o">*</span><span class="n">d</span><span class="o">**</span><span class="mi">5</span> <span class="o">-</span> <span class="mi">84</span><span class="o">*</span><span class="n">c</span><span class="o">**</span><span class="mi">3</span><span class="o">*</span><span class="n">d</span><span class="o">**</span><span class="mi">6</span> <span class="o">+</span> <span class="mi">36</span><span class="o">*</span><span class="n">c</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">d</span><span class="o">**</span><span class="mi">7</span> <span class="o">-</span>
                        <span class="mi">9</span><span class="o">*</span><span class="n">c</span><span class="o">*</span><span class="n">d</span><span class="o">**</span><span class="mi">8</span> <span class="o">+</span> <span class="n">d</span><span class="o">**</span><span class="mi">9</span><span class="p">)</span>
                    <span class="k">def</span> <span class="nf">_t</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
                        <span class="n">b</span> <span class="o">=</span> <span class="n">Mul</span><span class="p">(</span><span class="o">*</span><span class="n">info</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">RAD</span><span class="p">])</span>
                        <span class="k">return</span> <span class="n">cancel</span><span class="p">(</span><span class="n">rterms</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">/</span><span class="n">b</span><span class="p">),</span> <span class="n">Mul</span><span class="p">(</span><span class="o">*</span><span class="n">info</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">BASES</span><span class="p">])</span>
                    <span class="n">aa</span><span class="p">,</span> <span class="n">AA</span> <span class="o">=</span> <span class="n">_t</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                    <span class="n">bb</span><span class="p">,</span> <span class="n">BB</span> <span class="o">=</span> <span class="n">_t</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
                    <span class="n">cc</span> <span class="o">=</span> <span class="o">-</span><span class="n">rterms</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
                    <span class="n">dd</span> <span class="o">=</span> <span class="n">others</span>
                    <span class="n">eq</span> <span class="o">=</span> <span class="n">zz</span><span class="o">.</span><span class="n">xreplace</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span>
                        <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">),</span>
                        <span class="p">(</span><span class="n">aa</span><span class="p">,</span> <span class="n">AA</span><span class="p">,</span> <span class="n">bb</span><span class="p">,</span> <span class="n">BB</span><span class="p">,</span> <span class="n">cc</span><span class="p">,</span> <span class="n">dd</span><span class="p">))))</span>
                    <span class="n">ok</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="c1"># handle power-of-2 cases</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">ok</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">log</span><span class="p">(</span><span class="n">lcm</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">is_Integer</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="n">others</span> <span class="ow">and</span>
                    <span class="nb">len</span><span class="p">(</span><span class="n">rterms</span><span class="p">)</span> <span class="o">==</span> <span class="mi">4</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">rterms</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">):</span>
                <span class="k">def</span> <span class="nf">_norm2</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
                    <span class="k">return</span> <span class="n">a</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">b</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">a</span><span class="o">*</span><span class="n">b</span>

                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">rterms</span><span class="p">)</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
                    <span class="c1"># (r0+r1)**2 - (r2+r3)**2</span>
                    <span class="n">r0</span><span class="p">,</span> <span class="n">r1</span><span class="p">,</span> <span class="n">r2</span><span class="p">,</span> <span class="n">r3</span> <span class="o">=</span> <span class="n">rterms</span>
                    <span class="n">eq</span> <span class="o">=</span> <span class="n">_norm2</span><span class="p">(</span><span class="n">r0</span><span class="p">,</span> <span class="n">r1</span><span class="p">)</span> <span class="o">-</span> <span class="n">_norm2</span><span class="p">(</span><span class="n">r2</span><span class="p">,</span> <span class="n">r3</span><span class="p">)</span>
                    <span class="n">ok</span> <span class="o">=</span> <span class="bp">True</span>
                <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">rterms</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                    <span class="c1"># (r1+r2)**2 - (r0+others)**2</span>
                    <span class="n">r0</span><span class="p">,</span> <span class="n">r1</span><span class="p">,</span> <span class="n">r2</span> <span class="o">=</span> <span class="n">rterms</span>
                    <span class="n">eq</span> <span class="o">=</span> <span class="n">_norm2</span><span class="p">(</span><span class="n">r1</span><span class="p">,</span> <span class="n">r2</span><span class="p">)</span> <span class="o">-</span> <span class="n">_norm2</span><span class="p">(</span><span class="n">r0</span><span class="p">,</span> <span class="n">others</span><span class="p">)</span>
                    <span class="n">ok</span> <span class="o">=</span> <span class="bp">True</span>
                <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">rterms</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="c1"># r0**2 - (r1+others)**2</span>
                    <span class="n">r0</span><span class="p">,</span> <span class="n">r1</span> <span class="o">=</span> <span class="n">rterms</span>
                    <span class="n">eq</span> <span class="o">=</span> <span class="n">r0</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">_norm2</span><span class="p">(</span><span class="n">r1</span><span class="p">,</span> <span class="n">others</span><span class="p">)</span>
                    <span class="n">ok</span> <span class="o">=</span> <span class="bp">True</span>

    <span class="n">new_depth</span> <span class="o">=</span> <span class="n">sqrt_depth</span><span class="p">(</span><span class="n">eq</span><span class="p">)</span> <span class="k">if</span> <span class="n">ok</span> <span class="k">else</span> <span class="n">depth</span>
    <span class="n">rpt</span> <span class="o">+=</span> <span class="mi">1</span>  <span class="c1"># XXX how many repeats with others unchanging is enough?</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">ok</span> <span class="ow">or</span> <span class="p">(</span>
                <span class="n">nwas</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">rterms</span><span class="p">)</span> <span class="o">==</span> <span class="n">nwas</span> <span class="ow">and</span>
                <span class="n">new_depth</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> <span class="n">new_depth</span> <span class="o">==</span> <span class="n">depth</span> <span class="ow">and</span>
                <span class="n">rpt</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;Cannot remove all radicals&#39;</span><span class="p">)</span>

    <span class="n">flags</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span><span class="n">cov</span><span class="o">=</span><span class="n">cov</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">rterms</span><span class="p">),</span> <span class="n">rpt</span><span class="o">=</span><span class="n">rpt</span><span class="p">))</span>
    <span class="n">neq</span> <span class="o">=</span> <span class="n">unrad</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="o">*</span><span class="n">syms</span><span class="p">,</span> <span class="o">**</span><span class="n">flags</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">neq</span><span class="p">:</span>
        <span class="n">eq</span><span class="p">,</span> <span class="n">cov</span> <span class="o">=</span> <span class="n">neq</span>
    <span class="n">eq</span><span class="p">,</span> <span class="n">cov</span> <span class="o">=</span> <span class="n">_canonical</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">cov</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">eq</span><span class="p">,</span> <span class="n">cov</span>

<span class="kn">from</span> <span class="nn">sympy.solvers.bivariate</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">bivariate_type</span><span class="p">,</span> <span class="n">_solve_lambert</span><span class="p">,</span> <span class="n">_filtered_gens</span><span class="p">)</span>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../../index.html">
              <img class="logo" src="../../../_static/sympylogo.png" alt="Logo"/>
            </a></p><div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../index.html">Documentation overview</a><ul>
  <li><a href="../../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2015 SymPy Development Team.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.4.1</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.7</a>
      
    </div>

    

    
  </body>
</html>